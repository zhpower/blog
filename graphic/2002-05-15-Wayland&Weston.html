<!DOCTYPE HTML>
<html lang="en" >
    <head><meta charset="UTF-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"><title>Wayland&amp;Weston · 学习笔记</title><meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="description" content="Build Jekyll site with the GitBook style.
"><meta name="generator" content="Jekyll (using style of GitBook 3.2.3)"><meta name="author" content="kevin_zh"><link rel="stylesheet" href="/blog/assets/gitbook/style.css">
<link rel="stylesheet" href="/blog/assets/gitbook/gitbook-plugin-back-to-top-button/plugin.css">
<link rel="stylesheet" href="/blog/assets/gitbook/gitbook-plugin-expandable-chapters-small2/expandable-chapters-small.css">
<link rel="stylesheet" href="/blog/assets/gitbook/gitbook-plugin-fontsettings/website.css">
<link rel="stylesheet" href="/blog/assets/gitbook/gitbook-plugin-search-pro/search.css">
<link rel="stylesheet" href="/blog/assets/gitbook/gitbook-plugin-splitter/splitter.css">

<link rel="stylesheet" href="/blog/assets/gitbook/rouge/magritte.css">

<link rel="stylesheet" href="/blog/assets/gitbook/custom.css">
<link rel="stylesheet" href="/blog/assets/gitbook/custom-local.css">

<meta name="HandheldFriendly" content="true"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="/blog/assets/gitbook/images/apple-touch-icon-precomposed-152.png">
<link rel="shortcut icon" href="/blog//assets/gitbook/images/favicon.ico" type="image/x-icon">




            <link rel="prev" href="/blog/graphic/2001-02-01-DRM.html" />
        

        
            <link rel="next" href="/blog/jekyll/2002-06-11-Weston.html" />
        
    </head>
    <body>
        <div class="book"><div class="book-summary">
    <script type="text/javascript">
        // Fixes the page links scroll problem on both desktop and mobile browsers
        function pageScrollToTop(element) {
            // both mobile and non-mobile
            $('div.body-inner').animate({scrollTop: 0});
            $(element).parent().find('li>ul>li').removeClass('active');
            return true;  // propagate
        }
        // Fixes the anchor links scroll problem on mobile browsers
        function mobilePageScrollToAnchor(element) {
            $(element).closest('li.chapter').find('ul>li').removeClass('active');
            $(element).parent().addClass('active');
            if ($(document).width() <= 1240) {
                $('div.body-inner').animate({scrollTop: $($(element).attr('href')).get(0).offsetTop});
            }
            return true;
        }
    </script>

    <nav role="navigation">
        <div id="book-search-input" role="search">
            <input type="text" placeholder="Type to search" />
        </div>
        <div id="book-search-input-link" role="search">
            <a href="/blog/assets/search.html">Click to Search</a>
        </div>
        <ul class="summary">
            
            <li class="chapter" data-level="1.1" data-path="/blog">
            
                <a href="/blog/" onclick="pageScrollToTop(this)">
                    学习笔记
                </a>
            </li>

            <li class="divider"></li>

            
                <!-- <p>pages</p> -->
                
                    

                    

                    
                
            
                <!-- <p>posts</p> -->
                
                    

                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2000-04-27-linux_grpahic_architecture.html">
                        
                            <a href="/blog/jekyll/2000-04-27-linux_grpahic_architecture.html" onclick="pageScrollToTop(this)">
                                Linux graphic架构
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/graphic/2001-02-01-DRM.html">
                        
                            <a href="/blog/graphic/2001-02-01-DRM.html" onclick="pageScrollToTop(this)">
                                DRM子系统
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter active" data-level="1.2" data-path="/blog/graphic/2002-05-15-Wayland&Weston.html">
                        
                            <a href="/blog/graphic/2002-05-15-Wayland&Weston.html" onclick="pageScrollToTop(this)">
                                Wayland&amp;Weston
                            </a>
                            
                                
                                    <ul><li><a href="#1编译" onclick="mobilePageScrollToAnchor(this)" >1.编译</a></li><li><a href="#2运行" onclick="mobilePageScrollToAnchor(this)" >2.运行</a></li><li><a href="#3wayland" onclick="mobilePageScrollToAnchor(this)" >3.Wayland</a><ul><li><a href="#31-code的组成" onclick="mobilePageScrollToAnchor(this)" >3.1 code的组成</a></li><li><a href="#32-基础概念" onclick="mobilePageScrollToAnchor(this)" >3.2 基础概念</a><ul><li><a href="#321-client端object的使用" onclick="mobilePageScrollToAnchor(this)" >3.2.1 Client端object的使用</a></li><li><a href="#322-server端object的实现" onclick="mobilePageScrollToAnchor(this)" >3.2.2 Server端object的实现</a></li><li><a href="#323-client-server通讯" onclick="mobilePageScrollToAnchor(this)" >3.2.3 Client Server通讯</a></li><li><a href="#324-wayland-server实现" onclick="mobilePageScrollToAnchor(this)" >3.2.4 Wayland Server实现</a></li><li><a href="#324-wayland-client实现" onclick="mobilePageScrollToAnchor(this)" >3.2.4 Wayland Client实现</a></li></ul></li><li><a href="#33-简单的wayland-app-流程" onclick="mobilePageScrollToAnchor(this)" >3.3 简单的wayland app 流程</a></li><li><a href="#34-wayland-log" onclick="mobilePageScrollToAnchor(this)" >3.4 Wayland log</a></li><li><a href="#35-xml" onclick="mobilePageScrollToAnchor(this)" >3.5 xml</a></li><li><a href="#36-在线查看-wayland协议" onclick="mobilePageScrollToAnchor(this)" >3.6 在线查看 wayland协议</a></li></ul></li><li><a href="#4weston-简介" onclick="mobilePageScrollToAnchor(this)" >4.Weston 简介</a><ul><li><a href="#41-框架与对象" onclick="mobilePageScrollToAnchor(this)" >4.1 框架与对象</a></li><li><a href="#42-main函数的基本框架" onclick="mobilePageScrollToAnchor(this)" >4.2 main函数的基本框架</a></li><li><a href="#43-backend创建" onclick="mobilePageScrollToAnchor(this)" >4.3 backend创建</a></li><li><a href="#44-shell创建" onclick="mobilePageScrollToAnchor(this)" >4.4 shell创建</a></li><li><a href="#45-head和output" onclick="mobilePageScrollToAnchor(this)" >4.5 head和output</a></li><li><a href="#46-layer-view-surface" onclick="mobilePageScrollToAnchor(this)" >4.6 layer, view, surface</a></li><li><a href="#47-create_surface" onclick="mobilePageScrollToAnchor(this)" >4.7 create_surface</a></li><li><a href="#48-get_shell_surface" onclick="mobilePageScrollToAnchor(this)" >4.8 get_shell_surface</a></li><li><a href="#49-create_pool" onclick="mobilePageScrollToAnchor(this)" >4.9 create_pool</a></li><li><a href="#410-surface_attach-surface_damage" onclick="mobilePageScrollToAnchor(this)" >4.10 surface_attach surface_damage</a></li><li><a href="#411-surface_commit" onclick="mobilePageScrollToAnchor(this)" >4.11 surface_commit</a></li><li><a href="#412-share-buffer" onclick="mobilePageScrollToAnchor(this)" >4.12 share buffer</a><ul><li><a href="#4121-create_shm_buffer" onclick="mobilePageScrollToAnchor(this)" >4.12.1 create_shm_buffer</a></li><li><a href="#4122-import-dmabuf" onclick="mobilePageScrollToAnchor(this)" >4.12.2 import dmabuf</a></li></ul></li><li><a href="#413-weston-event-loop" onclick="mobilePageScrollToAnchor(this)" >4.13 weston event loop</a></li><li><a href="#414-weston-idle-处理" onclick="mobilePageScrollToAnchor(this)" >4.14 weston idle 处理</a></li><li><a href="#415-gl-renderer" onclick="mobilePageScrollToAnchor(this)" >4.15 gl-renderer</a></li><li><a href="#416-libinput" onclick="mobilePageScrollToAnchor(this)" >4.16 libinput</a><ul><li><a href="#4161-udevd" onclick="mobilePageScrollToAnchor(this)" >4.16.1 udevd</a></li><li><a href="#4162-grab-key" onclick="mobilePageScrollToAnchor(this)" >4.16.2 grab key</a></li></ul></li><li><a href="#417-client创建窗口" onclick="mobilePageScrollToAnchor(this)" >4.17 Client创建窗口</a><ul><li><a href="#4171-创建shm窗口" onclick="mobilePageScrollToAnchor(this)" >4.17.1 创建shm窗口</a></li><li><a href="#4172-创建egl窗口" onclick="mobilePageScrollToAnchor(this)" >4.17.2 创建egl窗口</a></li></ul></li><li><a href="#418-调用的backtrace" onclick="mobilePageScrollToAnchor(this)" >4.18 调用的backtrace</a><ul><li><a href="#4181-client-eglswapbuffers" onclick="mobilePageScrollToAnchor(this)" >4.18.1 Client eglSwapBuffers</a></li><li><a href="#4182-wl_output-global的创建" onclick="mobilePageScrollToAnchor(this)" >4.18.2 wl_output global的创建</a></li><li><a href="#4183-wl_surface_commit" onclick="mobilePageScrollToAnchor(this)" >4.18.3 wl_surface_commit</a></li><li><a href="#4184-drm_output_repaint" onclick="mobilePageScrollToAnchor(this)" >4.18.4 drm_output_repaint()</a></li><li><a href="#4185-repaint_views" onclick="mobilePageScrollToAnchor(this)" >4.18.5 repaint_views</a></li><li><a href="#4186-第一次repaint的触发" onclick="mobilePageScrollToAnchor(this)" >4.18.6 第一次repaint的触发</a></li><li><a href="#4187-送显的backtrace" onclick="mobilePageScrollToAnchor(this)" >4.18.7 送显的backtrace</a></li><li><a href="#4188-weston-desktop-shell" onclick="mobilePageScrollToAnchor(this)" >4.18.8 weston-desktop-shell</a></li><li><a href="#4189-weston_keyboard-进程的创建" onclick="mobilePageScrollToAnchor(this)" >4.18.9 Weston_keyboard 进程的创建</a></li><li><a href="#41810-key的处理" onclick="mobilePageScrollToAnchor(this)" >4.18.10 key的处理</a></li></ul></li><li><a href="#419-weston-misc" onclick="mobilePageScrollToAnchor(this)" >4.19 weston misc</a><ul><li><a href="#4191-定时器函数" onclick="mobilePageScrollToAnchor(this)" >4.19.1 定时器函数</a></li><li><a href="#4192-wayland-signal" onclick="mobilePageScrollToAnchor(this)" >4.19.2 wayland signal</a></li><li><a href="#4-123-libwayland-eglsoxxx" onclick="mobilePageScrollToAnchor(this)" >4 12.3 libwayland-egl.so.xxx</a></li><li><a href="#4194-weston_client_start" onclick="mobilePageScrollToAnchor(this)" >4.19.4 weston_client_start()</a></li><li><a href="#4195-weston-screenshooter" onclick="mobilePageScrollToAnchor(this)" >4.19.5 weston-screenshooter</a></li><li><a href="#4196-显示一帧的过程" onclick="mobilePageScrollToAnchor(this)" >4.19.6 显示一帧的过程</a></li><li><a href="#4197-repaint_timer_triger" onclick="mobilePageScrollToAnchor(this)" >4.19.7 repaint_timer_triger</a></li><li><a href="#4198-compositor-sleep-相关" onclick="mobilePageScrollToAnchor(this)" >4.19.8 Compositor sleep 相关</a></li><li><a href="#4199-surface与buffer" onclick="mobilePageScrollToAnchor(this)" >4.19.9 surface与buffer</a></li><li><a href="#41910-drm_virtual_output" onclick="mobilePageScrollToAnchor(this)" >4.19.10 drm_virtual_output</a></li><li><a href="#41911-explicit-synchronization" onclick="mobilePageScrollToAnchor(this)" >4.19.11 explicit-synchronization</a></li></ul></li><li><a href="#420-shell" onclick="mobilePageScrollToAnchor(this)" >4.20 shell</a><ul><li><a href="#4201-kiosk-shell" onclick="mobilePageScrollToAnchor(this)" >4.20.1 kiosk-shell</a></li><li><a href="#4202-ivi-shell" onclick="mobilePageScrollToAnchor(this)" >4.20.2 ivi-shell</a></li><li><a href="#4203-fullscreen-shell" onclick="mobilePageScrollToAnchor(this)" >4.20.3 fullscreen-shell</a></li></ul></li><li><a href="#421-wcap" onclick="mobilePageScrollToAnchor(this)" >4.21 wcap</a></li></ul></li></ul>

                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2002-06-11-Weston.html">
                        
                            <a href="/blog/jekyll/2002-06-11-Weston.html" onclick="pageScrollToTop(this)">
                                Weston Misc
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2002-08-10-Wayland-Misc.html">
                        
                            <a href="/blog/jekyll/2002-08-10-Wayland-Misc.html" onclick="pageScrollToTop(this)">
                                Wayland Misc
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2003-08-20-OpenGL_misc.html">
                        
                            <a href="/blog/jekyll/2003-08-20-OpenGL_misc.html" onclick="pageScrollToTop(this)">
                                OpenGL
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2013-03-02-cobalt.html">
                        
                            <a href="/blog/jekyll/2013-03-02-cobalt.html" onclick="pageScrollToTop(this)">
                                Cobalt
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/graphic/2018-03-21-YUV.html">
                        
                            <a href="/blog/graphic/2018-03-21-YUV.html" onclick="pageScrollToTop(this)">
                                YUV编码
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2018-05-20-memory_check.html">
                        
                            <a href="/blog/jekyll/2018-05-20-memory_check.html" onclick="pageScrollToTop(this)">
                                进程内存检查
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/linux/2018-08-01-DeviceResourceManage.html">
                        
                            <a href="/blog/linux/2018-08-01-DeviceResourceManage.html" onclick="pageScrollToTop(this)">
                                设备资源管理模块
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2020-06-22-misc.html">
                        
                            <a href="/blog/jekyll/2020-06-22-misc.html" onclick="pageScrollToTop(this)">
                                Kernel Misc
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2020-10-02-FuncTrace.html">
                        
                            <a href="/blog/jekyll/2020-10-02-FuncTrace.html" onclick="pageScrollToTop(this)">
                                Function Trace
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2021-04-27-ffmpeg.html">
                        
                            <a href="/blog/jekyll/2021-04-27-ffmpeg.html" onclick="pageScrollToTop(this)">
                                ffmpeg命令
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2022-04-27-bit.html">
                        
                            <a href="/blog/jekyll/2022-04-27-bit.html" onclick="pageScrollToTop(this)">
                                位运算
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2022-05-02-App_misc.html">
                        
                            <a href="/blog/jekyll/2022-05-02-App_misc.html" onclick="pageScrollToTop(this)">
                                linux dev misc
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2024-04-27-git.html">
                        
                            <a href="/blog/jekyll/2024-04-27-git.html" onclick="pageScrollToTop(this)">
                                Git
                            </a>
                            
                                
                            
                        </li>
                    

                    
                        <li class="divider"></li>
                    
                
            
        </ul>
    </nav>
</div>
<div class="book-body">
                <div class="book-header" role="navigation">
                    <!-- Title -->
                    <h1>
                        <i class="fa fa-circle-o-notch fa-spin"></i>
                        
                            <a href="." >Wayland&amp;Weston</a>
                        
                    </h1>
                </div>

                <div class="body-inner"><div class="page-wrapper" tabindex="-1" role="main">
    

    <div class="page-inner">
        <div id="book-search-results">
            <div class="search-noresults">
                <section class="normal markdown-section">
                    
                        <h1 id="/graphic/Wayland&Weston">Wayland&amp;Weston</h1>
                    

                    <h1 id="1编译">1.编译</h1>

<ul>
  <li>预设环境</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nv">$export</span> <span class="nv">WLD</span><span class="o">=</span>“~/xxxxxxxxx”  //定义一个wayland目录，编译生成到这里
    <span class="nb">sudo </span>apt <span class="nb">install </span>meson
    <span class="nb">sudo </span>apt <span class="nb">install </span>some_depenced_libs
</code></pre></div></div>

<ul>
  <li>Wayland</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nv">$ </span>git clone https://gitlab.freedesktop.org/wayland/wayland.git 
    <span class="nv">$ </span><span class="nb">cd </span>wayland 
    <span class="nv">$ </span>meson build/ <span class="nt">--prefix</span><span class="o">=</span><span class="nv">$WLD</span> 
    <span class="nv">$ </span>ninja <span class="nt">-C</span> build/ <span class="nb">install</span> 
    <span class="nv">$ </span><span class="nb">cd</span> .. 
</code></pre></div></div>

<ul>
  <li>Wayland protocols</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nv">$ </span>git clone https://gitlab.freedesktop.org/wayland/wayland-protocols.git
    <span class="nv">$ </span><span class="nb">cd </span>wayland-protocols
    <span class="nv">$ </span>meson build/ <span class="nt">--prefix</span><span class="o">=</span><span class="nv">$WLD</span>
    <span class="nv">$ </span>ninja <span class="nt">-C</span> build/ <span class="nb">install</span>
    <span class="nv">$ </span><span class="nb">cd</span> ..
</code></pre></div></div>

<ul>
  <li>Weston</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nv">$ </span>git clone https://gitlab.freedesktop.org/wayland/weston.git
    <span class="nv">$ </span><span class="nb">cd </span>weston
    <span class="nv">$ </span>meson build/ <span class="nt">--prefix</span><span class="o">=</span><span class="nv">$WLD</span>
    <span class="nv">$ </span>ninja <span class="nt">-C</span> build/ <span class="nb">install</span>
    <span class="nv">$ </span><span class="nb">cd</span> ..
</code></pre></div></div>

<ul>
  <li>
    <p>第三方依赖库的编译</p>

    <p>需要的第三方库</p>
  </li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    Libxml2-dev
    Libexpat-dev
    Libffi-dev
    Libinput-dev
    Libdrm-dev
    Libxkbcommon-dev
    libpixman-1-dev
    libcairo2-dev
    libudev
</code></pre></div></div>
<p>它们有的通过configure配置然后make， 有的通过mesa, ninja编译.  需要注意设置正确的PKG_CONFIG_PATH，使的pkg-config可以找到相关的库信息。
如果是mesa，留意目录下是否有meson_options.txt, 其中定义了各种编译选项，可对它进行修改。</p>

<ul>
  <li>meson</li>
</ul>

<p><strong>交叉编译</strong></p>

<p>在meson系统中进行交叉编译，需要为meson中添加参数 <code class="language-plaintext highlighter-rouge">–cross-file  xxx_filename</code>, 在xxx_filename中定义gcc等的路径路径</p>

<p>下面是一个示例</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="o">[</span>binaries]
    c <span class="o">=</span> <span class="s1">'/opt/cross-arm/bin/arm-linux-gnueabihf-gcc'</span>
    cpp <span class="o">=</span> <span class="s1">'/opt/cross-arm/bin/arm-linux-gnueabihf-g++'</span>
    ld <span class="o">=</span><span class="s1">'/opt/cross-arm/bin/arm-linux-gnueabihf-ld'</span>
    <span class="nv">strip</span><span class="o">=</span> <span class="s1">'/opt/cross-arm/bin/arm-linux-gnueabihf-strip'</span>
    pkgconfig <span class="o">=</span><span class="s1">'/usr/bin/pkg-config'</span>

    <span class="o">[</span>host_machine]
    system <span class="o">=</span> <span class="s1">'linux'</span>
    cpu_family <span class="o">=</span> <span class="s1">'aarch64'</span>
    cpu <span class="o">=</span> <span class="s1">'cortex-a73'</span>
    endian <span class="o">=</span> <span class="s1">'little
</span></code></pre></div></div>
<p>在configure系统中，则是export GCC CFLAG 等环境变量</p>

<p><strong>指定输入输出</strong></p>

<blockquote>
  <p>meson  build_dir/  sourc_code_dir/</p>
</blockquote>

<h1 id="2运行">2.运行</h1>

<ul>
  <li>
    <p>configure file</p>

    <p><code class="language-plaintext highlighter-rouge">copy weston.ini to ~/.config/</code></p>
  </li>
  <li>run weston.
    <ol>
      <li>login as root</li>
      <li>./weston –tty=2</li>
      <li>Ctrl+Alt+Backspace –&gt; 退出Weston界面</li>
    </ol>

    <p>如一般用户启动weston，这时要借助weston-launch 来完成。 相关code：libweston/weston-launch.c</p>
  </li>
  <li>run weston-client test
    <ol>
      <li>login as root</li>
      <li>export WAYLAND_DISPLAY=wayland-1</li>
    </ol>
  </li>
</ul>

<p>示例1, 指定backend 和shell</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    Server: ./weston <span class="nt">--tty</span><span class="o">=</span>2 <span class="nt">--shell</span><span class="o">=</span>fullscreen-shell.so <span class="nt">--backend</span><span class="o">=</span> drm-backend.so
    Client: weston-simple-dmabuf-egl
</code></pre></div></div>

<p>示例2</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    Server：./weston <span class="nt">--tty</span><span class="o">=</span>2 <span class="nt">--shell</span><span class="o">=</span>fullscreen-shell.so <span class="nt">--backend</span><span class="o">=</span>fbdev-backend.so
    Client./weston-simple-damage
</code></pre></div></div>

<h1 id="3wayland">3.Wayland</h1>

<h2 id="31-code的组成">3.1 code的组成</h2>

<p>wayland主要由三部分组成。</p>

<ul>
  <li><strong>Wayland提供了protocol的定义方式</strong></li>
</ul>

<p>在路径protocol文件夹下，以xml的形式定义了Wayland的核心协议。</p>

<p>如下面的xml，就定义了wl_display</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nt">&lt;interface</span> <span class="na">name=</span><span class="s">"wl_display"</span> <span class="na">version=</span><span class="s">"1"</span><span class="nt">&gt;</span>  
           <span class="nt">&lt;description</span> <span class="na">summary=</span><span class="s">"core global object"</span><span class="nt">&gt;</span>
                  The core global object.  This is a special singleton object.  
                  It is used for internal Wayland protocol features.   
           <span class="nt">&lt;/description&gt;</span>
        .....
    <span class="nt">&lt;/interface&gt;</span>

</code></pre></div></div>
<ul>
  <li><strong>xml到code的转换工具</strong></li>
</ul>

<p>xml到code的转换工具是wayland-scanner，它的source code在wayland目录下，可通过编译生成它。</p>

<p><img src="/blog/assets/wayland/wayland_scan.png" alt="wayland_scan" /></p>

<ul>
  <li>
    <p><strong>wayland还实现了一个高效率的 Server+Client通信模式</strong></p>

    <ul>
      <li>
        <p>Server端，主要是使用epoll+socket监听Client端事件，并对收到的消息反序列化。</p>

        <p><img src="/blog/assets/wayland/server_epoll.png" alt="server_epoll" /></p>
      </li>
      <li>
        <p>Client端：wayland-client提供了已实现的序列化接口</p>

        <p><img src="/blog/assets/wayland/client_epoll.png" alt="client_epoll" /></p>
      </li>
    </ul>
  </li>
</ul>

<p>总之，官方提供的Wayland源码，主要包括协议的定义、协议到代码的生成工具，以及一套实现好的通信模型</p>

<h2 id="32-基础概念">3.2 基础概念</h2>

<p>几乎所有的Wayland API都需要Wayland全局对象作为参数。</p>

<table>
  <thead>
    <tr>
      <th>名称</th>
      <th>作用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>wl_display</td>
      <td>表示与服务器的连接。</td>
    </tr>
    <tr>
      <td>wl_registry</td>
      <td>全局对象注册表，全局对象需要通过它获取。</td>
    </tr>
    <tr>
      <td>wl_compositor</td>
      <td>窗口合成器，也是服务器。</td>
    </tr>
    <tr>
      <td>wl_shm</td>
      <td>内存管理器，与窗口合成器共享内存用。</td>
    </tr>
    <tr>
      <td>wl_shell</td>
      <td>支持窗口操作功能。</td>
    </tr>
    <tr>
      <td>wl_seat</td>
      <td>输入设备管理器。 。 通过capabilities( )回调函数得到pointer、keyboard等</td>
    </tr>
    <tr>
      <td>wl_pointer</td>
      <td>代表鼠标设备。</td>
    </tr>
    <tr>
      <td>wl_keyboard</td>
      <td>代表键盘设备。</td>
    </tr>
  </tbody>
</table>

<p>Wayland没有提供Get函数来获取以上全局对象，只能通过wl_registry获取全局对象</p>

<h3 id="321-client端object的使用">3.2.1 Client端object的使用</h3>

<p>Wayland中server提供给client使用的对象可以归为 global object和 resource object。 Global 也是一中resource。</p>

<p>Global object如 wl_display, wl_compositor, wl_seat 等。 它们在client端是通过bind来获取到一个client 对应对象，然后就可以对它进行操作</p>

<p>Resource object  在client端是通过Global object 来创建的， 如 wl_surface, wl_shell_surface 等。</p>

<p><img src="/blog/assets/wayland/client_object.png" alt="client_object" /></p>

<p><img src="/blog/assets/wayland/object_generation.png" alt="object_generation" /></p>

<h3 id="322-server端object的实现">3.2.2 Server端object的实现</h3>

<p><strong>Global 资源的创建</strong>： wayland/src/wayland-server.c</p>

<ol>
  <li>wl_global_create( ….,  bind_xxx_function )</li>
  <li>
    <p>bind_xxx_function           // 在client中调用wl_registry_bind函数时被call</p>

    <ul>
      <li>
        <p>wl_resource_create( )   <br />
<span style="color: red"> wayland protocal 提供的接口，创建一个resource object，并把它插入到client的map表中，以后就可以通过ID 找到对应的resource obj，有利于server&lt;–&gt;client 通讯调用对应函数</span></p>
      </li>
      <li>wl_resource_set_implementation( )   // 设定资源接口的实现, 可供client通过IPC调用</li>
      <li>wl_priv_signal_emit( )   // wl_client_add_resource_created_listener will be notified</li>
    </ul>
  </li>
</ol>

<p><strong>普通 Resource 的创建</strong>：<br />
   应该是由某些 对global 资源的操作触发</p>
<ol>
  <li>wl_resource_create()</li>
  <li>wl_resource_set_implementation( )</li>
</ol>

<h3 id="323-client-server通讯">3.2.3 Client Server通讯</h3>

<p>Listener 是server –&gt; client 的通知方式. Client 注册listener 给server，有监听事件发生，server发信息给client.</p>

<p>Server侧发生通知的函数命名特征:   xxxx_send_xxxx( )</p>

<h3 id="324-wayland-server实现">3.2.4 Wayland Server实现</h3>

<p><img src="/blog/assets/wayland/Wayland_Server_APIs.svg" alt="Wayland_Server_APIs" /></p>

<h3 id="324-wayland-client实现">3.2.4 Wayland Client实现</h3>

<p><img src="/blog/assets/wayland/Wayland_Client_APIs.svg" alt="Wayland_Client_APIs" /></p>

<h2 id="33-简单的wayland-app-流程">3.3 简单的wayland app 流程</h2>

<p><img src="/blog/assets/wayland/simple_wayland_app.png" alt="simple_wayland_app" /></p>

<h2 id="34-wayland-log">3.4 Wayland log</h2>

<p>需设置环境变量： <code class="language-plaintext highlighter-rouge">export WAYLAND_DEBUG=1</code></p>

<p><img src="/blog/assets/wayland/wayland_log.png" alt="wayland_log" /></p>

<h2 id="35-xml">3.5 xml</h2>

<p><img src="/blog/assets/wayland/wayland_xml.png" alt="wayland_xml" /></p>

<p>其中最重要的wayland.xml中定义了如下接口：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ./wayland/protocol/wayland.xml
        wl_display
        wl_registry
        wl_callback
        wl_compositor
        wl_shm_pool
        wl_shm
        wl_buffer
        wl_data_offer
        wl_data_source
        wl_data_device
        wl_data_device_manager
        wl_shell
        wl_shell_surface
        wl_surface
        wl_seat
        wl_pointer
        wl_keyboard
        wl_touch
        wl_output
        wl_region
        wl_subcompositor
        wl_subsurface
</code></pre></div></div>

<h2 id="36-在线查看-wayland协议">3.6 在线查看 wayland协议</h2>

<ul>
  <li>
    <p>各种协议查看 <a href="https://wayland.app/">https://wayland.app/</a></p>
  </li>
  <li>
    <p>The Wayland Protocol 中文版 <a href="https://wayland.arktoria.org/">https://wayland.arktoria.org/</a></p>
  </li>
</ul>

<h1 id="4weston-简介">4.Weston 简介</h1>

<p>Weston是基于wayland协议，实现的Compositor。</p>

<p>Weston的入口在（这里以10.0.0为例）:</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>weston-10.0.0./compositor/main.c
weston-10.0.0./compositor/executable.c
</code></pre></div></div>

<h2 id="41-框架与对象">4.1 框架与对象</h2>

<ul>
  <li><strong>框架</strong></li>
</ul>

<p><img src="/blog/assets/wayland/weston_architecture.png" alt="weston_architecture" /></p>

<p>Weston中有以下几个主要部分：Shell、Compositor、Render、backend、Input</p>

<ol>
  <li>Shell：窗口管理器，画面层级、窗口信息、窗口生命周期、Focus窗口等等一些偏向于业务层的处理。默认的shell为desktop-shell，同时提供了其他shell实现（如ivi-shell）</li>
  <li>Compositor：负责画面的合成，使用DRM连接output，将画面输出到实际显示设备。</li>
  <li>Render：负责渲染，比如gl-render，做一些纹理贴图操作。</li>
  <li>Input：libinput模块，与evdev、uvdev模块交互，从底层设备节点接收touch、key等输入</li>
  <li>backend: Weston 使用后端的概念来抽象其运行环境的底层接口。后端负责处理输入和生成输出</li>
</ol>

<ul>
  <li><strong>对象</strong></li>
</ul>

<p><img src="/blog/assets/wayland/weston_object.png" alt="weston_object" /></p>

<p><img src="/blog/assets/wayland/image-20230209140244854.png" alt="image" /></p>

<h2 id="42-main函数的基本框架">4.2 main函数的基本框架</h2>

<p>实现内容：</p>
<ol>
  <li>解析cmdline</li>
  <li>初始化log系统</li>
  <li>创建wl_display对象，并侦听client接入</li>
  <li>创建weston_compositor对象，从而创建global resource compositor 和 shm， 以前其他资源</li>
  <li>load backend， 默认为drm_backend, 在drm_backend初始化的过程中会load gl_renderer</li>
  <li>load shell, 默认为desktop-shell.so</li>
  <li>调用wl_display_run( ) 循环等待event的发生</li>
</ol>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">wet_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[],</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">weston_testsuite_data</span> <span class="o">*</span><span class="n">test_data</span><span class="p">){</span>
    <span class="c1">// 初始化 layoutput_list</span>
    <span class="n">wl_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wet</span><span class="p">.</span><span class="n">layoutput_list</span><span class="p">);</span>
    <span class="p">...</span>
    <span class="c1">//  parse command line</span>
    <span class="p">...</span>
    <span class="c1">//  init log system</span>
    <span class="p">...</span>    
    <span class="c1">// 调用wayland提供的函数wl_display_create()</span>
    <span class="c1">// 创建 wl_display 对象</span>
    <span class="n">display</span> <span class="o">=</span> <span class="n">wl_display_create</span><span class="p">();</span>
    <span class="p">...</span>    
    <span class="c1">// 创建 weston_compositor 对象  </span>
    <span class="c1">// --&gt; 创建 global resource compositor and shm 以及其他resource</span>
    <span class="n">weston_compositor_create</span><span class="p">(</span> <span class="p">);</span>    
    <span class="c1">// 读取config for compositor</span>
    <span class="p">...</span>    
    <span class="c1">// load backend，通用的为load_drm_backend( )</span>
    <span class="c1">// 最终调用 对应backend实现的weston_backend_init( )</span>
    <span class="c1">// 在backend 初始化的过程中会装载 gl_renderer</span>
    <span class="n">load_backend</span><span class="p">(</span><span class="n">compositor</span><span class="p">,</span> <span class="n">backend</span><span class="p">)</span>
    <span class="p">...</span>    
    <span class="c1">// 创建socket， 侦听client的连接请求</span>
    <span class="n">weston_create_listening_socket</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">socket_name</span><span class="p">)</span>
    <span class="p">...</span>
    <span class="c1">// load shell, 默认为 desktop-shell.so</span>
    <span class="n">wet_load_shell</span><span class="p">(</span><span class="n">compositor</span><span class="p">,</span> <span class="n">shell</span><span class="p">,</span> <span class="p">...)</span>
    <span class="p">...</span>
    <span class="c1">// loop, 循环等待event的发生</span>
    <span class="n">wl_display_run</span><span class="p">(</span><span class="n">display</span><span class="p">)</span>
    <span class="p">...</span>
    <span class="c1">// 退出流程，资源的释放</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="43-backend创建">4.3 backend创建</h2>

<ul>
  <li>Weston 使用后端的概念来抽象其运行环境的底层接口。后端负责<strong>处理输入</strong>和<strong>生成输出</strong>。</li>
  <li>作为 libweston 的用户，Weston 可以在不同的后端上运行，包括嵌套在其他 Wayland 合成器中的方式（使用 wayland 后端），也可以在 X11 上运行，或者在独立的后端上运行，例如 DRM/KMS。</li>
  <li>大多数情况下，人们应该允许 Weston 自动选择后端，因为它会产生最佳结果。例如，在已经运行另一个图形环境的机器上运行 Weston 时，它会自动选择合适的后端，无论是另一个 Wayland 合成器还是 X11 服务器。</li>
  <li>只有在你知道 Weston 自动选择的后端不是最佳选择，或者你想使用不同于默认加载的后端时，才需要手动指定后端。在这种情况下，可以使用 -B [backend] 命令行选项来选择后端。</li>
  <li>可用的后端包括：
    <ul>
      <li>drm：独立运行在 DRM/KMS 和 evdev 上（推荐）。</li>
      <li>wayland：作为 Wayland 应用程序嵌套在另一个 Wayland 合成器实例中。</li>
      <li>x11：作为 X11 应用程序嵌套在 X11 显示服务器实例中。</li>
      <li>rdp：作为一个没有本地输入或输出的 RDP 服务器运行。</li>
      <li>headless：无输入或输出运行，适用于测试套件。</li>
      <li>
        <p>pipewire：无输入，输出到 PipeWire 节点。</p>

        <p><img src="/blog/assets/wayland/backend_tree.png" alt="backend_tree" width="300px" height="200px" /></p>
      </li>
    </ul>
  </li>
</ul>

<p><img src="/blog/assets/wayland/weston_backend.png" alt="weston_backend" /></p>

<p><strong>weston_backend_init</strong></p>

<p><img src="/blog/assets/wayland/weston_backend_init.svg" alt="weston_backend_init" /></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
 <span class="n">destroy</span><span class="p">()</span>
 <span class="n">repaint_begin</span><span class="p">()</span>   <span class="c1">//composite之前调用</span>
 <span class="n">repaint_cancel</span><span class="p">()</span>  <span class="c1">// 中途取消</span>
 <span class="n">repaint_flush</span><span class="p">()</span>   <span class="c1">// composite 完成后调用， 可用于实现提交到display</span>
 <span class="n">create_output</span><span class="p">()</span>   <span class="c1">// 创建weston_output</span>
 <span class="n">device_changed</span><span class="p">()</span>
 <span class="n">can_scanout_dmabuf</span><span class="p">()</span>
<span class="p">}</span><span class="n">Weston_backend</span><span class="p">,</span> <span class="n">Compositor</span><span class="o">-&gt;</span><span class="n">backend</span>

</code></pre></div></div>

<h2 id="44-shell创建">4.4 shell创建</h2>

<p>weston提供了多种shell，比如：desktop shell，ivi-shell, kiosk shell, fullscreen shell等</p>

<p><img src="/blog/assets/wayland/weston_shell.png" alt="weston_shell" /></p>

<h2 id="45-head和output">4.5 head和output</h2>

<p>weston_head 和 weston_output 是libweston中的两个关键概念，用于管理显示输出和图像呈现。</p>

<p><strong>weston_head（头部）</strong></p>
<ul>
  <li>weston_head 表示一个连接器或监视器。</li>
  <li>在硬件驱动中，头部通常指的是一个显示器，但它也可以是另一个窗口系统中的窗口，或者是一个虚拟概念。</li>
  <li>头部是一个可以呈现图像的位置。</li>
  <li>weston_head 负责以下任务：
    <ul>
      <li>管理帧缓冲区。</li>
      <li>跟踪损坏区域。</li>
      <li>处理显示时序。</li>
      <li>管理重绘状态机。</li>
    </ul>
  </li>
  <li>在显示硬件中，weston_head 表示一个CRTC（显示控制器），但仅在成功启用后才会如此。在头部的生命周期内，CRTC 可能会切换到另一个。</li>
  <li>weston_head 的生命周期由libweston用户控制。</li>
  <li>您可以通过将至少一个weston_head 附加到weston_output 来构建一个可供合成器使用的weston_output 对象，然后使用 weston_output_enable() 启用该输出。已启用的输出无法重新配置，但这在未来可能会发生变化。您可以使用 weston_output_disable() 来禁用一个输出，然后重新配置它，但这会导致可见的故障。</li>
</ul>

<p><strong>weston_output（输出）</strong></p>
<ul>
  <li>weston_output 决定了全局合成器坐标空间的哪一部分将被合成成图像以及何时进行合成。</li>
  <li>该图像在附加的头部上呈现。</li>
  <li>weston_output 负责以下任务：
    <ul>
      <li>帧缓冲区管理。</li>
      <li>损坏区域跟踪。</li>
      <li>显示时序。</li>
      <li>重绘状态机。</li>
      <li>视频模式、输出比例和输出变换是输出的属性。</li>
      <li>在显示硬件中，weston_output 表示一个CRTC，但仅在成功启用后才会如此。CRTC 可能会在输出的生命周期内切换到另一个。</li>
      <li>weston_output 的生命周期由libweston用户控制。</li>
    </ul>
  </li>
</ul>

<p><img src="/blog/assets/wayland/head_output.png" alt="head_output" /></p>

<p><strong>下面是各种case的流程图</strong></p>

<ul>
  <li>Heads are being created on compositor start-up with a backend that manages head lifetimes completely on its own</li>
</ul>

<p><img src="/blog/assets/wayland/create_head.png" alt="create_head" /></p>

<ul>
  <li>
    <p>A compositor handles libweston notification of something with heads having changed. This happens on both compositor start-up and later due to hotplug
<img src="/blog/assets/wayland/change_on_head.png" alt="change_on_head" /></p>
  </li>
  <li>
    <p>A compositor creates and configures an output for a head or heads it wants to light up.</p>
  </li>
</ul>

<p><img src="/blog/assets/wayland/create_output.png" alt="create_output" /></p>

<ul>
  <li>A compositor finds out a head has been disconnected and proceeds to destroy the corresponding output.</li>
</ul>

<p><img src="/blog/assets/wayland/disconnect_head.png" alt="disconnect_head" /></p>

<ul>
  <li>The backend realises that a piece of hardware has disappeared and needs to destroy the corresponding head. The head is released, and even when the compositor is not listening for head destroy signal, the output gets automatically disabled, though not destroyed.</li>
</ul>

<p><img src="/blog/assets/wayland/disable_output.png" alt="disable_output" /></p>

<h2 id="46-layer-view-surface">4.6 layer, view, surface</h2>

<p><img src="/blog/assets/wayland/layer_view_surface.png" alt="layer_view_surface" /></p>

<p><img src="/blog/assets/wayland/view_list.png" alt="view_list" /></p>

<h2 id="47-create_surface">4.7 create_surface</h2>

<p><img src="/blog/assets/wayland/client_server_create_object.png" alt="client_server_create_object" /></p>

<h2 id="48-get_shell_surface">4.8 get_shell_surface</h2>

<p><img src="/blog/assets/wayland/client_server_create_shell.png" alt="client_server_create_shell" /></p>

<h2 id="49-create_pool">4.9 create_pool</h2>
<p><img src="/blog/assets/wayland/client_server_create_buffer.png" alt="client_server_create_buffer" /></p>

<h2 id="410-surface_attach-surface_damage">4.10 surface_attach surface_damage</h2>
<p><img src="/blog/assets/wayland/client_server_surface_attach.png" alt="client_server_surface_attach" /></p>

<p><img src="/blog/assets/wayland/create_shm_buffer.svg" alt="create_shm_buffer" /></p>

<h2 id="411-surface_commit">4.11 surface_commit</h2>

<p><img src="/blog/assets/wayland/client_server_surface_commit.png" alt="client_server_surface_commit" /></p>

<h2 id="412-share-buffer">4.12 share buffer</h2>

<h3 id="4121-create_shm_buffer">4.12.1 create_shm_buffer</h3>
<p><img src="/blog/assets/wayland/compositor_create_surface.svg" alt="compositor_create_surface" /></p>

<h3 id="4122-import-dmabuf">4.12.2 import dmabuf</h3>

<p>Client 基本流程如下：</p>

<ol>
  <li>
    <p>绑定 linux_dmabuf
wl_registry_bind(<span style="color:red">zwp_linux_dmabuf_v1_interface</span> )</p>
  </li>
  <li>
    <p>创建一个param对象
zwp_linux_dmabuf_v1_create_params(<span style="color:red"> zwp_linux_dmabuf_v1</span>)</p>
  </li>
  <li>
    <p>在param中设置dmbuf的各种信息(fd，width， height), YUV时，通过数组导入多个plane信息
zwp_linux_buffer_params_v1_add(<span style="color:red">dmabuf_fd</span>)</p>
  </li>
  <li>
    <p>对param对象添加listener
zwp_linux_buffer_params_v1_add_listener()</p>
  </li>
  <li>
    <p>依据param在Server侧导入dmabuf对象
zwp_linux_buffer_params_v1_create( )</p>
  </li>
  <li>
    <p>通过callback接收导入结果
params_listener callback <span style="color:red">create_succeeded()</span></p>
  </li>
</ol>

<p><img src="/blog/assets/wayland/Import_Linux_dmabuf_to_compositor.svg" alt="Import_Linux_dmabuf_to_compositor" /></p>

<h2 id="413-weston-event-loop">4.13 weston event loop</h2>

<p><img src="/blog/assets/wayland/weston_event_loop.png" alt="weston_event_loop" /></p>

<h2 id="414-weston-idle-处理">4.14 weston idle 处理</h2>

<p><img src="/blog/assets/wayland/weston_idle_handler.png" alt="weston_idle_handler" /></p>

<h2 id="415-gl-renderer">4.15 gl-renderer</h2>

<p>weston中的几个renderer</p>

<p><img src="/blog/assets/wayland/render.png" alt="render" width="300px" height="100px" /></p>

<p><img src="/blog/assets/wayland/drm_backend.png" alt="drm_backend" /></p>

<h2 id="416-libinput">4.16 libinput</h2>

<p><img src="/blog/assets/wayland/Libinput_for_Wayland_compositors.svg" alt="libinput" width="400px" height="480px" /></p>

<p>source code：<a href="https://gitlab.freedesktop.org/libinput/libinput">https://gitlab.freedesktop.org/libinput/libinput</a></p>

<p>为了提高输入管理部分的模块性，Weston将对输入设备(键盘，鼠标，触摸屏等)的处理分离到一个单独的库，也就是libinput 中。具体地，它提供了<strong>设备检测</strong>，<strong>设备处理</strong>，<strong>输入事件处理</strong>等基本功能，类似于Android 中的EventHub。此外它还有<strong>pointer acceleration</strong>, <strong>touchpad support</strong> 及<strong>gesture recognition</strong>等功能。</p>

<p>libinput更像是一个框架，它将几个更底层的库的功能整合起来。它主要依赖于以下几个库:</p>

<ol>
  <li>mtdev: Multi-touch 设备处理，比如它会将不带tracking ID的protocol A转化为 protocol B。</li>
  <li>libevdev: 与kernel中evdev 模块对接。</li>
  <li>libudev:主要用于和 udevd(userspace device)的通信，从而获取设备的增加删除事件。也可从kernel获取。</li>
</ol>

<p>Weston 中的输入管理模块与libinput对接，它实现了两大部分的功能:</p>

<ul>
  <li>对输入设备的维护，</li>
  <li>对输入事件的处理。</li>
</ul>

<p>对于输入事件既会在Weston中做处理，也会传给相应的 client。</p>

<p>从事件处理模型上来看，libinput主循环监听udev monitor fd，它主要用于监听设备的添加删除事件。如果有设备添加，会打开该设备并把fd加入到libinput的主循环上。另一方面，Weston中会将 libinput 的 epoll fd加入主循环。这样形成级联的epoll，无论是 udev monitor 还是input device的fd有事件来，都会通知到Weston和libinput的主循环。</p>

<p>Weston中支持三种输入设备，分别是键盘，触摸和鼠标。一套输入设备属于一个seat(严格来说，seat中包括一套输入输出设备)。因此，weston_seat 中包含weston_keyboard,weston_pointer 和weston_touch三个结构。系统中可以有多个seat,它们的结构被串在weston_compositor 的 seat_list链表中。</p>

<p>可以看到，对于焦点处理，每个设备有自己的focus,它指向焦点窗口，用于拖拽和输入等。成员focus_resource_list 中包含了焦点窗口所在client中输入设备 proxy对应的 resource 对象。在这个 list 中意味着可以接收到相应的事件。</p>

<p><img src="/blog/assets/wayland/libinput.png" alt="libinput" /></p>

<p><img src="/blog/assets/wayland/wayland_input.svg" alt="wayland_input" /></p>

<p>对于焦点处理，每个设备有自己的 focus，它指向焦点窗口，用于拖拽和输入等。成员focus_resource_list 中包含了焦点窗口所在 client 中输入设备 proxy 对应的 resource 对象。在这个list中的resource就可以接收到相应的事件。 相关函数<span style="background-color: yellow">weston_keyboard_send_key()</span>, 参考 4.18.10 key的处理</p>

<p><img src="/blog/assets/wayland/libinput_seat.png" alt="libinput_seat" /></p>

<p><img src="/blog/assets/wayland/input.png" alt="input" width="170px" height="70px" /></p>

<h3 id="4161-udevd">4.16.1 udevd</h3>

<p>udev 是 Linux 系统中的一个重要组件，用于动态设备管理。详细介绍一下：</p>

<p>udev 的全称是 “userspace device”，它是一个用户空间的设备管理工具。</p>
<ol>
  <li>
    <p>功能：
 接收来自内核的设备事件（uevents），例如设备的添加、移除或状态变化。
 根据配置的一组规则，对设备进行识别和处理。
 管理设备节点的权限和属性。
 创建符号链接以提供有意义的设备名称。</p>
  </li>
  <li>工作流程：
    <ul>
      <li>内核发出设备事件（uevent）。</li>
      <li>udev 守护进程（通常是 systemd-udevd.service）接收事件。</li>
      <li>udev 根据配置的规则匹配设备属性，识别设备。</li>
      <li>匹配的规则可能会创建符号链接、修改设备节点的权限或运行指定的程序。</li>
    </ul>
  </li>
  <li>规则文件：
    <ul>
      <li>udev 规则存储在不同目录下的文件中，例如 /usr/lib/udev/rules.d、/run/udev/rules.d 和 /etc/udev/rules.d。</li>
      <li>规则文件以 .rules 扩展名结尾。</li>
      <li>每行包含至少一个键值对，用于匹配和赋值。</li>
      <li>规则按照词法顺序处理，可以覆盖系统提供的规则。</li>
    </ul>
  </li>
  <li>库支持：
 udev 处理的所有设备信息存储在 udev 数据库中，并通过 libudev 库提供对存储数据和事件源的访问。</li>
</ol>

<p>总之，udev 是一个关键的 Linux 设备管理工具，负责设备事件的处理、设备识别、权限管理和符号链接的创建</p>

<h3 id="4162-grab-key">4.16.2 grab key</h3>

<p>特殊情况下，shell对key的grab</p>

<p><img src="/blog/assets/wayland/grab_key.svg" alt="grab_key" /></p>

<h2 id="417-client创建窗口">4.17 Client创建窗口</h2>

<h3 id="4171-创建shm窗口">4.17.1 创建shm窗口</h3>

<p><img src="/blog/assets/wayland/simple_create_window.png" alt="simple_create_window" /></p>

<h3 id="4172-创建egl窗口">4.17.2 创建egl窗口</h3>

<p><img src="/blog/assets/wayland/create_egl_window.png" alt="create_egl_window" /></p>

<h2 id="418-调用的backtrace">4.18 调用的backtrace</h2>

<h3 id="4181-client-eglswapbuffers">4.18.1 Client eglSwapBuffers</h3>

<p>Client App 调用eglSwapBuffers 提交buffer给compositor的堆栈</p>

<p><img src="/blog/assets/wayland/client_eglSwapBuffers.png" alt="client_eglSwapBuffers" /></p>

<h3 id="4182-wl_output-global的创建">4.18.2 wl_output global的创建</h3>

<p><img src="/blog/assets/wayland/wl_output_create.png" alt="wl_output_create" /></p>

<h3 id="4183-wl_surface_commit">4.18.3 wl_surface_commit</h3>

<p>wl_surface_commit() 触发的后继操作</p>

<p><img src="/blog/assets/wayland/wl_surface_commit.png" alt="wl_surface_commit" /></p>

<h3 id="4184-drm_output_repaint">4.18.4 drm_output_repaint()</h3>

<p>drm_output_repaint() 的调用栈</p>

<p><img src="/blog/assets/wayland/drm_output_repaint.png" alt="drm_output_repaint" /></p>

<h3 id="4185-repaint_views">4.18.5 repaint_views</h3>

<p>repaint_views() 的调用栈</p>

<p><img src="/blog/assets/wayland/repaint_views.png" alt="repaint_views" /></p>

<h3 id="4186-第一次repaint的触发">4.18.6 第一次repaint的触发</h3>

<p><img src="/blog/assets/wayland/first_repaint.png" alt="first_repaint" /></p>

<h3 id="4187-送显的backtrace">4.18.7 送显的backtrace</h3>

<p><img src="/blog/assets/wayland/shown_on_display.png" alt="shown_on_display" /></p>

<h3 id="4188-weston-desktop-shell">4.18.8 weston-desktop-shell</h3>

<p><img src="/blog/assets/wayland/weston_desktop_shell.png" alt="weston_desktop_shell" /></p>

<h3 id="4189-weston_keyboard-进程的创建">4.18.9 Weston_keyboard 进程的创建</h3>

<p>在weston.ini中的【input-method】设置 <code class="language-plaintext highlighter-rouge">path= 空</code> 来不创建它, 函数launch_input_method() 会检查<code class="language-plaintext highlighter-rouge">path</code>.</p>

<p><img src="/blog/assets/wayland/keyboard.png" alt="keyboard" /></p>

<h3 id="41810-key的处理">4.18.10 key的处理</h3>
<p><img src="/blog/assets/wayland/handle_key.png" alt="handle_key" /></p>

<h2 id="419-weston-misc">4.19 weston misc</h2>

<h3 id="4191-定时器函数">4.19.1 定时器函数</h3>

<ol>
  <li>创建定时器：wl_event_loop_add_timer()</li>
  <li>Enable 定时器：wl_event_source_timer_update( source,  ms_delay)
              // ms_delay ==0  disable</li>
</ol>

<h3 id="4192-wayland-signal">4.19.2 wayland signal</h3>

<ul>
  <li>wl_signal_add( , ) 添加一个listener到 listerner_list 链表</li>
  <li>wl_signal_emit( , ) 触发一个signal, 从listener_list中调用每个listener notify</li>
  <li>listerner_list 其实就是一个callback链表
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">struct</span> <span class="n">wl_listener</span> <span class="p">{</span>
      <span class="k">struct</span> <span class="n">wl_list</span> <span class="n">link</span><span class="p">;</span>
      <span class="n">wl_notify_func_t</span> <span class="n">notify</span><span class="p">;</span>
  <span class="p">};</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="4-123-libwayland-eglsoxxx">4 12.3 libwayland-egl.so.xxx</h3>
<ol>
  <li>由 wayland-1.20.0/egl下文件编译生成</li>
  <li>主要功能生成/销毁wl_egl_window， 并获取它的大小属性</li>
  <li>使用: client/backend-wayland 可以利用它来生成wl_egl_window,  然后传给eglCreateWindowSurface( )</li>
  <li>示例：./clients/simple-egl.c</li>
  <li>好像不需要再分配buffer attch到 wl_surface,  参考simple-egl-window.c</li>
</ol>

<h3 id="4194-weston_client_start">4.19.4 weston_client_start()</h3>

<p>在weston里定义， Weston call 它来 发起一个client 进程, 它会调用weston_client_launch()</p>

<h3 id="4195-weston-screenshooter">4.19.5 weston-screenshooter</h3>

<p>截屏进程， 被desktop-shell 进程call screenshooter_create( )创建</p>

<h3 id="4196-显示一帧的过程">4.19.6 显示一帧的过程</h3>

<ol>
  <li>epoll收到event</li>
  <li>构建compositor View_list， 含有order信息</li>
  <li>backend call gl_renderer set current surface</li>
  <li>依次根据各个view的信息构建纹理，进行渲染</li>
  <li>eglswapbuffer（）</li>
  <li>遍历各个output，完成1～4</li>
  <li>repaint_flash()  -&gt; drm 上屏</li>
</ol>

<h3 id="4197-repaint_timer_triger">4.19.7 repaint_timer_triger</h3>
<p><img src="/blog/assets/wayland/repaint_timer_triger.png" alt="repaint_timer_triger" /></p>

<h3 id="4198-compositor-sleep-相关">4.19.8 Compositor sleep 相关</h3>
<ol>
  <li>In weston.init,  相关配置 idle-time， 单位sec</li>
  <li>在函数weston_compositor_wake()设置 多长时间无操作进入sleep状态</li>
  <li>定时器compositor-&gt;idle_source， 在weston_compositor_create()中创建</li>
  <li>在weston_compositor_offscreen() , weston_compositor_sleep() 中关闭定时器</li>
</ol>

<h3 id="4199-surface与buffer">4.19.9 surface与buffer</h3>

<ul>
  <li>
    <p>Surface：</p>

    <ul>
      <li>Surface 是 DRM 中的一个概念，用于描述一个可绘制的区域。它是一个抽象的图形表面，可以用于绘制图像、文本或其他内容。</li>
      <li>Surface 可以是屏幕上的一部分，也可以是一个窗口、一个图像或其他可视元素。</li>
      <li>应用程序可以将图形绘制到 Surface 上，然后由 DRM 管理其显示。</li>
      <li>例如，在 DRM 中，一个窗口可以有多个关联的 Surface，每个 Surface 对应一个缓冲区。</li>
    </ul>
  </li>
  <li>Buffer：
    <ul>
      <li>Buffer 是一块内存区域，用于存储像素数据。在 DRM 中，它通常与 Surface 关联。</li>
      <li>Buffer 可以是帧缓冲区、纹理、渲染缓冲区等。</li>
      <li>Buffer 存储着图像的像素值，可以直接访问和操作。</li>
      <li>例如，当应用程序绘制图像时，它将像素数据写入 Buffer，然后由 DRM 将其显示在屏幕上。</li>
    </ul>
  </li>
  <li>总结：</li>
  <li>Surface 是一个抽象的图形表面，用于绘制图像。</li>
  <li>Buffer 是实际存储像素数据的内存区域，与 Surface 关联。</li>
</ul>

<h3 id="41910-drm_virtual_output">4.19.10 drm_virtual_output</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>drm_backend_init_virtual_output_api <span class="o">()</span> &lt;- <span class="c">#ifdef BUILD_DRM_VIRTUAL </span>
                 &lt;- /libweston/backend-drm/meson.build
                     &lt;- remoting or pipewire  <span class="k">in </span>configure

</code></pre></div></div>
<p>drm_virtual_output 用于 remoting or pipewire 场景， 在meson_options.txt 里配置</p>

<h3 id="41911-explicit-synchronization">4.19.11 explicit-synchronization</h3>

<p><img src="/blog/assets/wayland/explicit_sync.png" alt="explicit_sync" /></p>

<p><img src="/blog/assets/wayland/linux_explicit_synchronization.svg" alt="linux_explicit_synchronization" /></p>
<ol>
  <li>
    <p>绑定显示同步对象</p>

    <p>wl_registry_bind(zwp_linux_explicit_synchronization_v1_interface)</p>
  </li>
  <li>
    <p>针对surface创建sync对象</p>

    <p>zwp_linux_explicit_synchronization_v1_get_synchronization(expliciti_sync,  surface)</p>
  </li>
  <li>Client 进行Opengl渲染，并通过sync 创建一个fence_fd
    <ul>
      <li>eglCreateSyncKHR() --&gt; sync</li>
      <li>eglDupNativeFenceFDANDROID(sync) --&gt; fence_fd</li>
      <li>eglDestroySyncKHR(sync)</li>
    </ul>
  </li>
  <li>
    <p>为surface_sync对象设置fence_fd， compositor将会等待它的完成</p>

    <p>zwp_linux_surface_synchronization_v1_set_acquire_fence(fence_fd)</p>
  </li>
  <li>
    <p>创建release对象，用于监听server callback</p>

    <p>zwp_linux_surface_synchronization_v1_get_release(surface_sync)</p>
  </li>
  <li>
    <p>提交surface，compositor开始合成并通过callback 返回要client等待的fence_fd</p>

    <p>wl_surface_attach()                                                                                     <br />
wl_surface_commit()</p>
  </li>
  <li>
    <p>Client 等待上面callback 返回的fence_fd</p>

    <p>eglCreateSyncKHR(..fence_fd..)  –&gt; sync                                                                                     <br />
eglWaitSyncKHR(..sync..)</p>
  </li>
</ol>

<h2 id="420-shell">4.20 shell</h2>

<p>weston提供有四种shell， <strong>desktop</strong>、 <strong>IVI</strong>、<strong>kiosk</strong> 和<strong>fullscreen-shell</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="o">./</span><span class="n">kiosk</span><span class="o">-</span><span class="n">shell</span><span class="o">/</span><span class="n">util</span><span class="o">.</span><span class="na">c</span>
    <span class="o">./</span><span class="n">kiosk</span><span class="o">-</span><span class="n">shell</span><span class="o">/</span><span class="n">kiosk</span><span class="o">-</span><span class="n">shell</span><span class="o">.</span><span class="na">c</span>
    <span class="o">./</span><span class="n">kiosk</span><span class="o">-</span><span class="n">shell</span><span class="o">/</span><span class="n">kiosk</span><span class="o">-</span><span class="n">shell</span><span class="o">-</span><span class="n">grab</span><span class="o">.</span><span class="na">c</span>
    
    <span class="o">./</span><span class="n">ivi</span><span class="o">-</span><span class="n">shell</span><span class="o">/</span><span class="n">hmi</span><span class="o">-</span><span class="n">controller</span><span class="o">.</span><span class="na">c</span>
    <span class="o">./</span><span class="n">ivi</span><span class="o">-</span><span class="n">shell</span><span class="o">/</span><span class="n">ivi</span><span class="o">-</span><span class="n">shell</span><span class="o">.</span><span class="na">c</span>
    <span class="o">./</span><span class="n">ivi</span><span class="o">-</span><span class="n">shell</span><span class="o">/</span><span class="n">ivi</span><span class="o">-</span><span class="n">layout</span><span class="o">-</span><span class="n">transition</span><span class="o">.</span><span class="na">c</span>
    <span class="o">./</span><span class="n">ivi</span><span class="o">-</span><span class="n">shell</span><span class="o">/</span><span class="n">ivi</span><span class="o">-</span><span class="n">layout</span><span class="o">.</span><span class="na">c</span>
    
    <span class="o">./</span><span class="n">fullscreen</span><span class="o">-</span><span class="n">shell</span><span class="o">/</span><span class="n">fullscreen</span><span class="o">-</span><span class="n">shell</span><span class="o">.</span><span class="na">c</span>
    
    <span class="o">./</span><span class="n">desktop</span><span class="o">-</span><span class="n">shell</span><span class="o">/</span><span class="n">input</span><span class="o">-</span><span class="n">panel</span><span class="o">.</span><span class="na">c</span>
    <span class="o">./</span><span class="n">desktop</span><span class="o">-</span><span class="n">shell</span><span class="o">/</span><span class="n">exposay</span><span class="o">.</span><span class="na">c</span>
    <span class="o">./</span><span class="n">desktop</span><span class="o">-</span><span class="n">shell</span><span class="o">/</span><span class="n">shell</span><span class="o">.</span><span class="na">c</span>
</code></pre></div></div>

<h3 id="4201-kiosk-shell">4.20.1 kiosk-shell</h3>

<p>在 Weston 中，kiosk-shell 是一种简单的窗口管理器（shell），专为<strong>单应用程序</strong>或<strong>单应用程序模式</strong>（kiosk 模式）设计。让我详细介绍一下：</p>

<ol>
  <li>
    <p><strong>kiosk-shell 的功能</strong>：</p>

    <ul>
      <li>kiosk-shell 使所有顶层应用程序窗口全屏显示。</li>
      <li>它支持定义将哪些应用程序放置在特定输出上。 这通过在 weston.ini 中相应输出部分的 app-ids= 字段中实现。</li>
    </ul>
  </li>
  <li>
    <p><strong>使用示例</strong>：</p>

    <p>在 weston.ini 中，您可以指定哪些应用程序应该在特定输出上运行。
 例如：</p>
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="o">[</span>output]
 <span class="nv">name</span><span class="o">=</span>screen0
 app-ids<span class="o">=</span>org.domain.app1,com.domain.app2
</code></pre></div>    </div>
    <p>要使用 kiosk-shell 运行 Weston，请在 weston.ini 中设置 shell=kiosk-shell.so，或使用命令行选项 –shell=kiosk-shell.so。</p>
  </li>
  <li>
    <p><strong>适用场景</strong>：</p>

    <p>kiosk-shell 适用于嵌入式设备、数字标牌、自助服务终端、展示台等场景，其中<strong>只有一个应用程序需要全屏显示</strong>。</p>
  </li>
</ol>

<h3 id="4202-ivi-shell">4.20.2 ivi-shell</h3>

<p>IVI : <strong>In-Vehicle Information</strong></p>

<p>在 Weston 项目中，IVI-shell 是一个高度可定制的外壳（shell），专注于那些需要<strong>对外壳窗口布局进行自定义控制</strong>的用例，而无需用户进行交互式布局配置。IVI-shell的示例用例包括汽车信息娱乐系统（IVI）应用程序或工业人机界面。通常情况下，当用户界面需要在一个或多个屏幕上<strong>精确定位多个应用程序表面</strong>时，IVI-shell 是一个理想的选择。</p>

<p>以下是关于 IVI-shell的一些重要信息：</p>

<ol>
  <li>
    <p><strong>IVI-shell客户端协议</strong>：</p>

    <p>Wayland 客户端可以实现 ivi_application Wayland 协议，通过该协议，它们可以指定一个 ivi_id，以便 IVI控制器可以识别应用程序。这使得控制器可以为众所周知的应用程序实现特殊行为。此外，IVI-shell也可以处理使用xdg-shell协议的客户端，但在这些情况下，IVI-shell需要其他方式来识别客户端应用程序。</p>
  </li>
  <li><strong>IVI-shell的组成部分</strong>：
    <ul>
      <li>ivi-shell.so：负责处理应用程序ID，并提供抽象来通过ivi_layout_interface配置窗口布局。这个接口在IVI-shell组合器实现中讨论。</li>
      <li>自定义 IVI 控制器：使用 <strong>ivi_layout_interface</strong> 来实现窗口管理器，负责配置窗口布局，即应用程序在屏幕上的位置。由于这种分离，必须在您的weston.ini中加载这两个模块才能使用IVI-shell。</li>
    </ul>
  </li>
  <li><strong>IVI-shell的控制</strong>：
    <ul>
      <li>IVI-shell提供了 <strong>ivi_layout_interface</strong> API，控制器必须使用它来控制IVI-shell的窗口布局。有关此 API 的定义，请参阅 <strong>ivi-shell/ivi-layout-export.h</strong>。</li>
      <li>对于初始配置，控制器必须至少创建一个 <strong>ivi_layout_layer</strong> 并将其添加到一个 <strong>weston_output</strong>。图层允许将多个应用程序表面分组并一起控制，是组织和管理表面的主要机制。</li>
      <li>控制器还必须使用触发器来获取对客户端表面的控制权。客户端表面显示为 <strong>ivi_layout_surface</strong>。这些表面具有 ID，允许控制器识别表面并相应地重新配置窗口布局。</li>
    </ul>
  </li>
</ol>

<p>总之，IVI-shell是一个强大的工具，用于在汽车信息娱乐系统、工业界面等场景中<strong>精确控制应用程序的窗口布局</strong>。</p>

<h3 id="4203-fullscreen-shell">4.20.3 fullscreen-shell</h3>

<p>下图是fullscreen-shell的初始化，以及surface commit时的处理。 可参考 [4.11 surface_commit]</p>

<p><img src="/blog/assets/wayland/Fullscreen-shell.svg" alt="Fullscreen-shell" /></p>

<h2 id="421-wcap">4.21 wcap</h2>

<p>在 Weston项目中，<code class="language-plaintext highlighter-rouge">wcap</code> 目录是用于处理 Weston 的<strong>屏幕录制功能</strong>的。具体来说，wcap 是一种特定于 Weston的<strong>无损</strong>视频格式，它仅<strong>记录帧之间的差异</strong>。这意味着它只捕获屏幕上发生变化的部分，而不是完整的每一帧。这对于屏幕录制非常有用，因为它可以减少文件大小并提高效率。</p>

<p>如果您在 Weston 中进行屏幕录制，生成的录制文件将以 .wcap 格式保存在当前工作目录中。要播放这些录制文件，您需要将 .wcap文件转换为其他媒体播放器可以理解的格式。例如，您可以使用 wcap-decode工具将 .wcap 文件转换为单独的PNG图像文件，以便查看每一帧的屏幕内容。</p>

<p>请注意，这里提到的 wcap 是一种专门用于 Weston 的格式，不同于其他常见的视频格式，如 MP4 或 AVI。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">./</span><span class="n">wcap</span><span class="o">/</span><span class="n">main</span><span class="o">.</span><span class="na">c</span>
<span class="o">./</span><span class="n">wcap</span><span class="o">/</span><span class="n">wcap</span><span class="o">-</span><span class="n">decode</span><span class="o">.</span><span class="na">c</span>
</code></pre></div></div>
</section>
            </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div></div>
    </div>
</div>

<!-- introduce mathjax support -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ['$', '$'], ['\\(', '\\)'] ]
  },
  svg: {
    fontCache: 'global'
  }
};
</script>
<script
  type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>


<!-- introduce per-page mermaid support -->

    <script>
    function render_mermaid() {
        mermaid.initialize({
            startOnLoad: false,
            theme: "default",
        });
        window.mermaid.init(undefined, document.querySelectorAll('.language-mermaid'));
    }

    function initialize_mermaid() {
        if (document.readyState === "loading") {
            // Loading hasn't finished yet
            document.addEventListener("DOMContentLoaded", render_mermaid);
        } else {
            // `DOMContentLoaded` has already fired
            render_mermaid();
        }
    }

    if (window.mermaid_script && window.mermaid) {
        initialize_mermaid();
    } else {
        window.mermaid_script = document.createElement("script");
        mermaid_script.onload = initialize_mermaid;
        document.head.appendChild(mermaid_script);
        mermaid_script.defer = true;
        mermaid_script.id = 'mermaid-script';
        mermaid_script.src = '/blog/assets/gitbook/mermaid.min.js';
    }
</script>



<!-- introduce mathjax support -->
<script>
    function fixes_chrome_anchors() {
        let chrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
        if (window.location.hash && chrome) {
            setTimeout(function () {
                var hash = window.location.hash;
                window.location.hash = "";
                window.location.hash = hash;
            }, 300);
        }
    }

    if (document.readyState === "loading") {
        // Loading hasn't finished yet
        document.addEventListener("DOMContentLoaded", fixes_chrome_anchors);
    } else {
        // `DOMContentLoaded` has already fired
        fixes_chrome_anchors();
    }
</script>


                        <a href="/blog/graphic/2001-02-01-DRM.html" class="navigation navigation-prev navigation-unique" aria-label="Previous page: DRM子系统">
                            <i class="fa fa-angle-left"></i>
                        </a>
                    

                    
                        <a href="/blog/jekyll/2002-06-11-Weston.html" class="navigation navigation-next navigation-unique" aria-label="Next page: Weston Misc">
                            <i class="fa fa-angle-right"></i>
                        </a>
                    
                </div>
            </div>

            <script>
            var gitbook = gitbook || [];
            gitbook.push(function() {
                gitbook.page.hasChanged({
    "page": {
        "title": "Introduction",
        "level": "1.1",
        "depth": 1,
        
        "next": {
            "title": "Weston Misc",
            "level": "1.2",
            "depth": 1,
            "path": "_posts/2019-01-11-Weston.md",
            "ref": "_posts/2019-01-11-Weston.md",
            "articles": []
        },
        
        "dir": "ltr"
    },    "config": {
        "plugins": ["fontsettings", "highlight", "livereload", "lunr", "search", "sharing", "theme-default", "livereload"],
        "styles": {
            "ebook": "styles/ebook.css",
            "epub": "styles/epub.css",
            "mobi": "styles/mobi.css",
            "pdf": "styles/pdf.css",
            "print": "styles/print.css",
            "website": "styles/website.css"
        },
        "pluginsConfig": {
            "expandable-chapter-small2": {
                "articlesExpand": true,
            },
            "fontsettings": {
                "family": "sans",
                "size": 2,
                "theme": "white"
            },
            "highlight": {},
            "livereload": {},
            "lunr": {
                "ignoreSpecialCharacters": false,
                "maxIndexSize": 1000000
            },
            "search": {},            "sharing": {
                "facebook": false,

                "google": false,

                "github": false,
              
                "github_link": "https://github.com",
              

                "telegram": false,
                "telegram_link": "https://t.me",

                "instapaper": false,

                "twitter": false,
              

                "vk": false,

                "weibo": false,

                "all": ["facebook", "google", "twitter", "weibo", "instapaper", "github", "telegram"]
            },
"theme-default": {
                "showLevel": false,
                "styles": {
                    "ebook": "styles/ebook.css",
                    "epub": "styles/epub.css",
                    "mobi": "styles/mobi.css",
                    "pdf": "styles/pdf.css",
                    "print": "styles/print.css",
                    "website": "styles/website.css"
                }
            },
        },
        "theme": "default",
        "author": "Tao He",
        "pdf": {
            "pageNumbers": true,
            "fontSize": 12,
            "fontFamily": "Arial",
            "paperSize": "a4",
            "chapterMark": "pagebreak",
            "pageBreaksBefore": "/",
            "margin": {
                "right": 62,
                "left": 62,
                "top": 56,
                "bottom": 56
            }
        },
        "structure": {
            "langs": "LANGS.md",
            "readme": "README.md",
        },
        "variables": {},
        "title": "学习笔记",
        "language": "en",
        "gitbook": "*"
    },
    "file": {
        "path": "_posts/2018-05-15-Wayland&Weston.md",
        "mtime": "2002-05-15 00:00:00 +0800",
        "type": "markdown"
    },
    "gitbook": {
        "version": "3.2.3"
    },
    "basePath": "/blog",
    "book": {
        "language": ""
    }
});
            });
            </script>
        </div><script src="/blog/assets/gitbook/gitbook.js"></script>
<script src="/blog/assets/gitbook/theme.js"></script>

<script src="/blog/assets/gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
<script src="/blog/assets/gitbook/gitbook-plugin-copy-code-button/toggle.js"></script>
<script src="/blog/assets/gitbook/gitbook-plugin-expandable-chapters-small2/expandable-chapters-small.js"></script>
<script src="/blog/assets/gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
<script src="/blog/assets/gitbook/gitbook-plugin-search-pro/jquery.mark.min.js"></script>
<script src="/blog/assets/gitbook/gitbook-plugin-search-pro/search.js"></script>
<!-- <script src="/blog/assets/gitbook/gitbook-plugin-sharing/buttons.js"></script> -->
<script src="/blog/assets/gitbook/gitbook-plugin-splitter/splitter.js"></script>

<!--
<script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
<script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
<script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
<script src="../gitbook/gitbook-plugin-search/search.js"></script>
-->

</body>
</html>