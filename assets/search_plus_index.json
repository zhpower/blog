{"/blog/pages/about/": {
    "title": "About",
    "keywords": "Jekyll",
    "url": "/blog/pages/about/",
    "body": "日常工作的学习笔记 基本上是工作中遇到问题后，查看各种资料，然后自己做的一些总结。 Email:zh_power@hotmail.com"
  },"/blog/jekyll/2023-04-27-bit.html": {
    "title": "位运算",
    "keywords": "Jekyll",
    "url": "/blog/jekyll/2023-04-27-bit.html",
    "body": "1.位运算概述 从现代计算机中所有的数据二进制的形式存储在设备中。即 0、1 两种状态，计算机对二进制数据进行的运算(+、-、*、/)都是叫位运算，即将符号位共同参与运算的运算。 口说无凭，举一个简单的例子来看下 CPU 是如何进行计算的，比如这行代码： int a = 35; int b = 47; int c = a + b; 计算两个数的和，因为在计算机中都是以二进制来进行运算，所以上面我们所给的 int 变量会在机器内部先转换为二进制在进行相加： 35: 0 0 1 0 0 0 1 1 47: 0 0 1 0 1 1 1 1 ———————————————————— 82: 0 1 0 1 0 0 1 0 所以，相比在代码中直接使用(+、-、*、/ )运算符，合理的运用位运算更能显著提高代码在机器上的执行效率。 2.位运算概览 ![[image-20230313173955848.png]] 3.按位与运算符（&amp;） 定义：参加运算的两个数据，按二进制位进行”与”运算。 3.1 运算规则： 0&amp;0=0 0&amp;1=0 1&amp;0=0 1&amp;1=1 总结：两位同时为1，结果才为1，否则结果为0。 例如：3&amp;5 即 0000 0011&amp; 0000 0101 = 0000 0001，因此 3&amp;5 的值得1。 注意：负数按补码形式参加按位与运算。 3.2 与运算的用途： 1）清零 如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。 2）取一个数的指定位 比如取数 X=1010 1110 的低4位，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位与运算（X&amp;Y=0000 1110）即可得到X的指定位。 3）判断奇偶 只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((a &amp; 1) == 0)代替if (a % 2 == 0)来判断a是不是偶数。 4. 按位或运算符（|） 定义：参加运算的两个对象，按二进制位进行”或”运算。 4.1 运算规则： 0 0=0 0 1=1 1 0=1 1 1=1 总结：参加运算的两个对象只要有一个为1，其值为1。 例如：3 5即 0000 0011 0000 0101 = 0000 0111，因此，3 5的值得7。　 注意：负数按补码形式参加按位或运算。 4.2 或运算的用途： 1）常用来对一个数据的某些位设置为1 比如将数 X=1010 1110 的低4位设置为1，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位或运算（X Y=1010 1111）即可得到。 5.异或运算符（^） 定义：参加运算的两个数据，按二进制位进行”异或”运算。 5.1 运算规则： 0^0=0 0^1=1 1^0=1 1^1=0 总结：参加运算的两个对象，如果两个相应位相同为0，相异为1。 异或的几条性质: 1、交换律 2、结合律 (a^b)^c == a^(b^c) 3、对于任何数x，都有 x^x=0，x^0=x 4、自反性: a^b^b=a^0=a; 5.2 异或运算的用途： 1）翻转指定位 比如将数 X=1010 1110 的低4位进行翻转，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行异或运算（X^Y=1010 0001）即可得到。 2）与0相异或值不变 例如：1010 1110 ^ 0000 0000 = 1010 1110 3）交换两个数 void Swap(int &amp;a, int &amp;b){     if (a != b){         a ^= b;         b ^= a;         a ^= b;     } } 6.取反运算符 (~) 定义：参加运算的一个数据，按二进制进行”取反”运算。 6.1 运算规则：　 ~1=0 ~0=1 总结：对一个二进制数按位取反，即将0变1，1变0。 6.2 取反运算符的用途： 1）使一个数的最低位为零 使a的最低位为0，可以表示为：a &amp; ~1。~1的值为 1111 1111 1111 1110，再按”与”运算，最低位一定为0。因为” ~”运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。 7.左移运算符（«） 定义：将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。 设 a=1010 1110，a = a« 2 将a的二进制位左移2位、右补0，即得a=1011 1000。 7.1 «1 左移 1位 相当于乘2 若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。 8.右移运算符（»） 定义：将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 例如：a=a»2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。 8.1 »1 右移一位相当于除2 操作数每右移一位，相当于该数除以2。 9.复合赋值运算符 位运算符与赋值运算符结合，组成新的复合赋值运算符，它们是： &amp;= 例：a&amp;=b 相当于 a=a&amp;b = 例：a =b 相当于 a=a b &gt;&gt;= 例：a»=b 相当于 a=a»b «= 例：a«=b 相当于 a=a« b ^= 例：a^=b 相当于 a=a^b 运算规则：和前面讲的复合赋值运算符的运算规则相似。 不同长度的数据进行位运算：如果两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算。 以”与运算”为例说明如下：我们知道在C语言中long型占4个字节，int型占2个字节，如果一个long型数据与一个int型数据进行”与运算”，右端对齐后，左边不足的位依下面三种情况补足， 1）如果整型数据为正数，左边补16个0。 2）如果整型数据为负数，左边补16个1。 3）如果整形数据为无符号数，左边也补16个0。 如：long a=123；int b=1；计算a&amp; b。 如：long a=123；int b=-1；计算a&amp; b。 如：long a=123；unsigned intb=1；计算a &amp; b。"
  },"/blog/jekyll/2022-04-27-ffmpeg.html": {
    "title": "ffmpeg命令",
    "keywords": "Jekyll",
    "url": "/blog/jekyll/2022-04-27-ffmpeg.html",
    "body": "01. 视频分割 ffmpeg -ss 00:00:00 -i input.mp4 -c copy -t 60 output.mp4 -ss 表示视频分割的起始时间，-t 表示分割时长，同时也可以用 00:01:00表示 ==注意== ：-ss 要放在 -i 之前 02. 视频区域裁剪： ffmpeg -i 3.mkv -filter_complex crop=1024:50:0:550 -y 4.mkv 03. 视频预览 ffplay 3.mkv -vf crop=1024:50:0:550 04. 视频放大,缩小 ffmpeg -i 2.mp4 -vf \"scale=1280:64\" 4.mp4 ==scale== =w:h 表示放大后的大小 05. 列出所有format // list all pix format ffmpeg -pix_fmts 06. 图片转换 ffmpeg -i temp.jpg -s 1024x680 -pix_fmt yuvj420p 9.yuv ffmpeg.exe -i agf-dog-1280x960.jpg -vf scale=1920:1080 agf-dog-1920x1080.jpg 07. 视频format转换 YUV -&gt; RGB ffmpeg -s 360x270 -pix_fmt yuv420p -i  2_test_360x270_50.yuv -pix_fmt rgb24  aaaa.rgb ffmpeg -s 640x480 -pix_fmt nv12 -i 640x480_1.jpg -vf scale=640:480,setsar=1:1 640x480_1_nv12.yuv -hide_banner 08. 视频叠加 ffmpeg -i input1 -i input2 -filter_complex overlay=x:y output 09. 视频旋转 //mp4向左旋转90度 ffmpeg -i input.mp4 -metadata:s:v rotate=”90” -codec copy outut.mp4 //mp4向右旋转90度 ffmpeg -i input.mp4 -metadata:s:v rotate=”-90” -codec copy outut.mp4 10. 视频镜像 //mp4左右镜像翻转 ffmpeg -i input.mp4 -vf \"hflip\" outut.mp4 //mp4上下镜像翻转 ffmpeg -i input.mp4 -vf \"vflip\" outut.mp4 10. 图片旋转 //图片向右旋转90度 ffmpeg -i input.png -vf rotate='90*PI/180' -y rotate60.png //图片向右旋转90度 ffmpeg -i input.png -vf rotate='-90*PI/180' -y rotate_90.png //图片像左旋转90度 ffmpeg -i input.png -vf transpose=2 -y transpose2.png //图片像右旋转90度 ffmpeg -i input.png -vf transpose=1 -y transpose2.png //逆时针(向左)旋转90°，然后垂直（上下）翻转 ffmpeg -i input.png -vf transpose=0 -y transpose0.png 11. 图片镜像 //图片左右镜像翻转 ffmpeg -i input.png -vf hflip -y hflip.png //图片上下镜像翻转 ffmpeg -i input.png -vf vflip -y vflip.png //yuv数据左右镜像翻转 ffmpeg -s 1920x1080 -pix_fmt nv12 -i nv12_1.yuv -vf hflip -y hflip_nv12.yuv //播放左右翻转后的yuv数据 ffplay -video_size 1920x1080 -pixel_format nv12 hflip_nv12.yuv 12. 音频音量调节大小 //音量翻倍，写在滤镜里 ffmpeg -i input.wav -af volume=2 -y output.wav //音量翻倍，不写在滤镜中 ffmpeg -i input.wav -vol 2000 -y output.wav 13. 调节播放速度 ffmpeg -i test1.mp4 -vf \"setpts=0.25*PTS\" test2.mp4 四倍慢速： ffmpeg -i test1.mp4 -vf \"setpts=4*PTS\" test2.mp4"
  },"/blog/jekyll/2021-04-27-Weston.html": {
    "title": "weston",
    "keywords": "Jekyll",
    "url": "/blog/jekyll/2021-04-27-Weston.html",
    "body": "一. 启动Weston 1.1 实现内容 解析cmdline 初始化log系统 创建wl_display对象，并侦听client接入 创建weston_compositor对象，从而创建global resource compositor 和 shm， 以前其他资源 load backend， 默认为drm_backend, 在drm_backend初始化的过程中会load gl_renderer load shell, 默认为desktop-shell.so 调用wl_display_run( ) 循环等待event的发生 1.2 伪代码 int wet_main(int argc, char *argv[], const struct weston_testsuite_data *test_data){ // 初始化 layoutput_list wl_list_init(&amp;wet.layoutput_list); ... // parse command line ... // init log system ... // 调用wayland提供的函数wl_display_create() // 创建 wl_display 对象 display = wl_display_create(); ... // 创建 weston_compositor 对象 // --&gt; 创建 global resource compositor and shm 以及其他resource weston_compositor_create( ); // 读取config for compositor ... // load backend，通用的为load_drm_backend( ) // 最终调用 对应backend实现的weston_backend_init( ) // 在backend 初始化的过程中会装载 gl_renderer load_backend(compositor, backend) ... // 创建socket， 侦听client的连接请求 weston_create_listening_socket(display, socket_name) ... // load shell, 默认为 desktop-shell.so wet_load_shell(compositor, shell, ...) ... // loop, 循环等待event的发生 wl_display_run(display) ... // 退出流程，资源的释放 } 1.3 backend, renderer, shell的作用 结构图 backend { destroy() repaint_begin() //composite之前调用 repaint_cancel() // 中途取消 repaint_flush() // composite 完成后调用， 可用于实现提交到display create_output() // 创建weston_output device_changed() can_scanout_dmabuf() }Weston_backend, Compositor-&gt;backend renderer: renderer接口供backend内部使用，外部通过调用backend接口触发 { display_create() output_window_create() output_pbuffer_create() output_destroy() output_set_border() create_fence_fd() } gl_renderer_interface 二. Client 动作 2.1 Client的接入和global资源代理的创建 流程 连接display 获得registry，注册listener，用于处理weston资源变化时的callback 根据资源变化的callback， 创建各类资源的proxy 进入loop，不断调用wl_display_dispatch( )，使得wayland内部循环处理各类event 伪代码 static void global_resource_found(void* data, struct wl_registry* registry, uint32_t name, const char* interface, uint32_t version) { // 通过字符串interface 判断是什么resource， // 通过wl_registry_bind() 创建对应的 resource proxy if (strcmp(interface, \"wl_compositor\") == 0) { // 构建了 compositor 的 proxy compositor = wl_registry_bind(registry, name, &amp;wl_compositor_interface, 4)); }else if (strcmp(interface, \"wl_shm\") == 0) { // 构建了 shm 的proxy shm = wl_registry_bind(registry, name, &amp;wl_shm_interface, 1); } ... } // 当weston的global resoure发生变化时，通过如下回调函数通知到client wl_registry_listener registry_listener = { // 发现新global resource的回调函数 global_resource_found, // global resource remove的回调函数 global_resource_remove } int main(int argc, char** argv) { // 1. 调用wayland提供的 wl_display_connect( ), 连接到weston( wayland server) // 对应到weston启动中的weston_create_listening_socket() display = wl_display_connect(NULL); ... // 2. 获取 wl_registry, 并侦听它的callback registry= wl_display_get_registry(display); wl_registry_add_listener(registry, &amp;registry_listener, display); ... // 3. 循环等待， // 调用wl_display_dispatch( )，由wayland处理weston发来的event while(ret != -1){ ret = wl_display_dispatch( ); } } 2.2 内部weston - client 通讯机制 request: Client –&gt; Server event : Server –&gt; Client 术语上，Wayland 中把 Client 发给 Server 的跨进程函数调用称为 request，反方向的跨进程函数调用称为 event。 本质上，它们处理的方式是类似的。 要让两个进程通过 socket 进行函数调用，首先需要将调用抽象成数据流的形式。这个数据流应该包含函数名、参数等信息。 RPC 函数的接口定义是应该同时包含在 Client 和 Server 端的库中的，其中包含了接口对象所支持的 request 和 event 的函数签名。因此这部分不用传输，只要传输目标对象 id，方法 id 和参数列表这些信息就可以了。 这些信息会通过 wl_closure_marshal()写入 wl_closure 结构，再由 serialize_closure()变成数据流。 等到了目标进程后， 会从数据流通过 wl_connection_demarshal()转回 wl_closure。 RPC 图示 object RPC 机制 这个过程类似于 Android 中的 Parcel 机制。那么 问题来了，参数中的整形，字符串什么的都好搞，拷贝就行。但如果参数中包含对象，我们不能把整个对象 拷贝过去，也不能传引用过去。那么需要一种机制来作同一对象在 Server 和 Client 端的映射，这是通过 wl_map 实现的。 wl_map 在 Client 和 Server 端各有一个，它们分别存了 wl_proxy 和 wl_resource 的数组，且是 一一对应的。这些对象在这个数组中的索引作为它们的 id。这样，参数中的对象只要传 id，这个 id 被传到目 的地后会通过查找这个 wl_map 表来得到本地相应的对象。在功能上类似于 Android 中的 BpXXX 和 BnXXX。 wl_proxy 和 wl_resource 都包含 wl_object 对象。这个 wl_object 和面向对象语言里的对象概念类似，它有 interface 成员描述了这个对象所实现的接口，implementation 是这些接口的实现函数的函数指针数组，id 就是 在 wl_map 结构里数组中的索引。 前面所说的 Client 绑定 Server 端资源的过程就是在 Client 端创建 wl_proxy， 在 Server 端创建 wl_resource。然后 Client 就可以通过 wl_proxy 调用 Server 端对应 wl_resource 的 request， Server 端就可以通过 wl_resource 调用 Client 端对应 wl_proxy 的 event。 这个映射过程如下图所示(以 wl_registry 为例) 2.3 Client 创建各类资源proxy 主要资源proxy // wl_surface wl_surface = wl_compositor_create_surface(compositor) // wl_buffer wl_shm_pool = wl_shm_create_pool( ) wl_buffer = wl_shm_pool_create_buffer( ) // attach buffer to surface wl_surface_attach(wl_surface, wl_buffer) /* 以下与窗口的管理\\显示相关 */ // xdg_surface // xdg_wm_base 它也是一个global resouce，对应到 desktop-shell xdg_surface = xdg_wm_base_get_xdg_surface(xdg_wm_base, wl_surface) // xdg_toplevel xdg_toplevel = xdg_surface_get_toplevel(xdg_toplevel) // wl_keyboard // wl_seat 是一个global resource // 通过wl_keyboard 创建一个listener就可接收按键 wl_keyboard = wl_seat_get_keyboard(wl_seat) wl_keyboard_add_listener(wl_keyboard, keyboard_listener) // wl_pointer 鼠标指针 // 通过wl_pointer 创建一个listener可以接收鼠标的移动信息 wl_pointre = wl_seat_get_pointer(wl_weat) wl_pointer_add_listener（wl_pointer, pointer_listener) ... ... 2.4 Client 渲染 伪代码 simple-egl.c /*-------------------- egl 初始化工作 ------------------------*/ // egl lib 应该要支持wayland。 // 这样在调用一些egl接口时，在其内部会调用wayland接口与Wayland server交换信息 // 如函数：eglGetDisplay( ) , eglCreateWindowSurface( )， eglSwapBuffers 等 // 1. 获取egl_display egl_display = weston_platform_get_egl_display(EGL_PLATFORM_WAYLAND_KHR, wl_display, ...) or egl_display = eglGetDisplay(wl_display) // 2. 初始化 egl eglInitialize(egl_display) // 3. 通用elg 配置 eglGetConfigs() eglChooseConfig( ) eglCreateContext( ) /* ----------------------gl 准备工作------------------------------*/ // 1.创建 shader glCreateShader( ) // 2.创建 Program glCreateProgram( ) // 3. attach shader to program glAttachShader( ) // 4. Link program glLinkProgram( ) // 5. 使用program glUseProgram( ) /*-------------------------wl_surface 关联egl_surface----------------*/ wl_egl_window-&gt;surface = wl_surface; wl_egl_window-&gt;width = width; wl_egl_window-&gt;height = height; eglCreateWindowSurface(egl_display, ... , wl_egl_window) /*------------------------------------------------------------------*/ gl 绘制图形 /*-------------------------------------------------------------------*/ // 内部实现应该调用wayland接口来swap buffer eglSwapBuffers(egl_display, egl_surface) ... 2.5. Client 提交渲染好的surface 提交函数 wl_surface_commit( ) 三. Weston 合成各个App的surface并呈现 流程 compositor遍历每个weston_output 发起repaint。weston_output_schedule_repaint( ) 通知weston_output具体实现–backend_output, 开始repaint的前期准备工作, 对应函数start_repaint_loop( )， drm实现暂无内容 backend_output通知compositor可以开始output repaint compositor 调用weston_output相关backend的repaint_begin( )，drm_backend 创建了pending_state compoistor 调用weston_output_repaint(), 开始repaint。 调用weston_compositor_build_view_list( ) 构建view_list, 得到output的一个paint_node_z_order_list 调用drm_backend assign_planes( ) 设置输出plane 调用drm_backend drm_output_repaint( ), 最终指向gl_renderer_repaint_output( ) 依据paint_node_z_order_list, OpenGL依次建立shader，texture等进行渲染 全部完成后，提交呈现 sequenceDiagram participant C as Compositor participant O as Weston_output participant B as Backend loop 遍历weston_output_list C -&gt;&gt; O: 要开始repaint_loop &lt;br /&gt;call backend_output start_repaint_loop( ) C -&gt;&gt; B: repaint_begin( ) Note right of B: 创建 pending_state C -&gt;&gt; O: 通知output repaint O -&gt;&gt; C: 构建view_list, build_view_list( ) Note left of C:构建paint_node_z_order_list C -&gt;&gt; B: assign_planes( ),设置输出plane C -&gt;&gt; B: drm_output_repaint( ) Note right of B: 调用OpenGL API &lt;br/&gt;结合paint_node_z_order_list&lt;br/&gt;进行渲染 end"
  },"/blog/linux/2018-08-01-DeviceResourceManage.html": {
    "title": "设备资源管理模块",
    "keywords": "linux",
    "url": "/blog/linux/2018-08-01-DeviceResourceManage.html",
    "body": "1.解决的问题 相信每一个写过Linux driver的工程师，都在probe函数中遇到过上面的困惑：在顺序申请多种资源（IRQ、Clock、memory、regions、ioremap、dma、等等）的过程中，只要任意一种资源申请失败，就要回滚释放之前申请的所有资源。 于是在函数的最后，就一定会出现很多的goto标签，用于释放不同的资源（如上面的exit_free_irq、exit_free_dma、等等）。 在申请资源出错时，小心翼翼的goto到正确的标签上，以便释放已申请资源。 这样在代码中，整个函数被大段的、重复的如下代码充斥。 if (!condition) { err = xxx; goto xxx; } 既浪费精力容易出错，也不美观。 有困惑，就有改善的办法。 方法就是Linux设备模型中的device resource management（设备资源管理）。 2.解决的思路 devres提供了一种机制，用资源节点的形式记录它申请的资源，并在系统中为设备分配一个链表，当申请某个资源时，就构建一个资源节点，然后把它加入到这个链表中，对应的释放函数也会被记录，以便在driver detach的时候，自动释放。 为了使用devres机制，资源要对各自的资源分配函数重新封装，加入资源节点的申请、添加和释放，一般新函数名改成了devm_xxx()的形式。driver作者只管调用这些devm_xxx()接口来申请资源，不用考虑释放，设备模型会在适当的时候释放它们。 device resource management位于“drivers/base/devres.c”中，它实现了上述机制。 3.提供的接口 以下是devres提供的几个基本接口 interface Description devres_alloc( ) // 分配资源节点 devres_free( ) // 释放资源节点 devres_add( ) // 添加资源节点到链表 devres_destroy( ) // 释放资源 devres_release_all() //释放所有资源 4.接口的使用 其他资源模块，可以通过调用devres提供的接口，利用devres机制实现资源的自动释放。 4.1 资源节点函数的应用举例 下面的代码是利用devres机制实现分配中断资源函数 devm_request_threaded_irq( ), 上层模块可以调用它来分配中断资源，在出错时，不必考虑对该资源的释放，系统会自动释放。 主要涉及到devres_alloc()、devres_free()和devres_add() 4.2 资源释放函数的应用举例 资源释放函数devres_destroy()的使用举例，资源模块可以用它来封装资源释放函数。 5. 函数的内部实现 5.1 devres_alloc() devrs_alloc()函数的实现，主要调用了内部函数alloc_dr(), 它会分配size+sizeof(struct devres)的内存大小, struct devres用于存储资源节点信息，并记录release 函数。 5.2 devres_add() devres_add()主要实现把资源节点添加到设备的资源链表中。 5.3 devres_destroy() devres_destroy()主要涉及到以下几个内部函数： devres_remove() //查找到资源节点，并从链表中删除 find_dr() //根据release函数指针、match函数查找资源节点 devres_free() //释放资源节点 可以结合上面它的使用实例来学习。 5.4 devers_release_all() devers_release_all()的调用会释放所有资源。它的被调用时机有两个： really_probe()失败 设备与驱动分离时, deriver_dettach时 就是driver_remove时。"
  },"/blog/jekyll/2018-04-27-test.html": {
    "title": "only test",
    "keywords": "Jekyll",
    "url": "/blog/jekyll/2018-04-27-test.html",
    "body": "only for test new txt 123 dsf graph TD; A--&gt;B; A--&gt;C; B--&gt;D; C--&gt;D; Syntax Description Header Title Paragraph Text test_abc"
  },"/blog/jekyll/2018-03-21-YUV.html": {
    "title": "YUV资料",
    "keywords": "Jekyll",
    "url": "/blog/jekyll/2018-03-21-YUV.html",
    "body": "1.简介 YUV数据由Y、U、V三个分量组成，现在通常说的YUV指的是YCbCr。 Y：表示亮度（Luminance、Luma），占8bit（1字节） Cb、Cr：表示色度（Chrominance、Chroma） Cb（U）：蓝色色度分量，占8bit（1字节） Cr（V）：红色色度分量，占8bit（1字节） 2.采样方式(444, 422, 420的区别) 把Y、U、V数据转变为R、G、B时用到 2.1 采样方式 采样方式通常用A:B:C的形式来表示，比如4:4:4、4:2:2、4:2:0等 A：假定在一块A*2个像素的概念区域，一般都是4. B：第1行的色度(UV)采样数目。 C：第2行的色度(UV)采样数目 所以这里的B,C指的分别是在第一行，第二行UV采样的数目。 C的值一般要么等于B，要么等于0 示意图1： 示意图2 上图中，不管是哪种采样格式，Y分量都是全水平、全垂直分辨率采样的，每一个像素都有自己独立的Y分量 2.2 占用字节数 由上可以推算出不同采样方式下每个像素需要的平均字节数。 4:4:4 一个像素YUV各占一个字节，总共3个字节 24bit 4:2:2 8个像素 ： 8个Y + 2个U +2个V +2个U +2个V = 16字节 每个像素：16字节/8 = 2个字节 16bit 4:2:0 8个像素 ： 8个Y + 2个U +2个V = 12字节 每个像素：12字节/8 = 1.5个字节 12bit 3.存储方式(Planar, Semi-Planar和Packed的区别) 存储格式，表示的是Y、U、V数据是如何排列和存储的。 读取或写入Y、U、V数据时用到. 3.1 分类 YUV的存储格式可以分为3大类： 名称 特点 Planar(平面) Y、U、V分量分开单独存储,名称通常以字母p结尾, 3个planar Semi-Planar（半平面） Y分量单独存储，U、V分量交错存储, 名称通常以字母sp结尾, 1个planar Packed（紧凑） 或者叫Interleaved(交错), Y、U、V分量交错存储, 1个planar 3.2 444 I444 和YV24 主要是UV次序的不同 semi-planar NV24 和NV42 主要是UV交替次序的不同 3.3 422 Planar I422 YV16 区别：VU 次序 Semi-Planar NV16 NV61 区别：VU 次序 Packed UYVY YUYV YVYU 区别：VU 次序 3.4 420 Planar I420 YV12 采样方式420 I420，像素示意图 Semi-Planar NV12 NV21 采样方式420，各种存储方式， 像素示意图 4.借助ffmpeg格式转换 PNG -&gt; YUV ffmpeg -i in.png -s 512x512 -pix_fmt yuv420p out.yuv YUV -&gt; PNG ffmpeg -s 512x512 -pix_fmt yuv420p -i in.yuv out.jpg YUV 文件只是存储数据的文件，没有大小信息，所以转换时一定要给出它的尺寸 PNG 文件含有尺寸信息，所以转YUV时可以不指定大小，默认原大小 5.借助ffplay显示YUV 可以通过ffplay显示YUV数据。 YUV中直接存储的是所有像素的颜色信息（可以理解为是图像的一种原始数据） 必须得设置YUV的尺寸（-s）、像素格式（-pix_fmt）才能正常显示 ffplay -s 512x512 -pix_fmt yuv420p in.yuv # 在ffplay中 # -s已经过期，建议改为：-video_size # -pix_fmt已经过期，建议改为：-pixel_format ffplay -video_size 512x512 -pixel_format yuv420p in.yuv 6.GLSL实现YUV转RGBA 6.1 基本计算公式 根据的标准不同，有不同的计算公式。下面是一个可以在shader中使用的计算方法。 只要先得到Y,U,V， 就可以按下面方法转换RGB \" yuv.y = yuv.y - 0.5; \\n\" \" yuv.z = yuv.z - 0.5; \\n\" \" \\n\" \" rgb.r = yuv.x + 1.402 * yuv.z; \\n\" \" rgb.g = yuv.x - 0.34413 * yuv.y - 0.71414 * yuv.z; \\n\" \" rgb.b = yuv.x + 1.772 * yuv.y; \\n\" YUV到RGBA的转换其实就两个要点 构建合适的纹理 在shader中提前YUV 6.2 YUV444P-&gt;ARGB 6.2.1 构建纹理 static GLuint build_texture_4_yuv444p(int width, int height, void *data){ GLuint texture; glGenTextures(1, &amp;texture); glBindTexture(GL_TEXTURE_2D, texture); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexImage2D(GL_TEXTURE_2D, 0, GL_RED, width, height, 0, GL_RED, GL_UNSIGNED_BYTE, data); glBindTexture(GL_TEXTURE_2D, 0); return texture; } 6.2.2 在shader中提取YUV static const char* yuv444_2_rgba_frag_src = \"uniform sampler2D Sampler; \\n\" \"varying highp vec2 TexCoord; \\n\" \"void main (void) \\n\" \"{ \\n\" \" highp vec3 yuv; \\n\" \" highp vec3 rgb; \\n\" \" yuv.x = texture2D(Sampler, TexCoord).r; \\n\" \" yuv.y = texture2D(Sampler, vec2(TexCoord.x, TexCoord.y+0.3333333)).r;\\n\" \" yuv.z = texture2D(Sampler, vec2(TexCoord.x, TexCoord.y+0.6666667)).r;\\n\" \" \\n\" \" yuv.y = yuv.y - 0.5; \\n\" \" yuv.z = yuv.z - 0.5; \\n\" // 矩阵计算方法 \" rgb = mat3( \\n\" \"1, 1, 1, \\n\" \"0, -.34413, 1.772, \\n\" \"1.402, -.71414, 0 \\n\" \" ) * yuv; \\n\" \" \\n\" \" gl_FragColor = vec4(rgb, 1.0); \\n\" \"} \\n\"; 6.3 NV24-&gt;ARGB 6.3.1 构建纹理 这里需要构建两个纹理，一个是Y的纹理， 一个是UV的纹理 static GLuint build_texture_4_nv24_y(int width, int height, void *y_data){ GLuint texture; glGenTextures(1, &amp;texture); glBindTexture(GL_TEXTURE_2D, texture); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexImage2D(GL_TEXTURE_2D, 0, GL_LUMINANCE, width, height, 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, y_data); glBindTexture(GL_TEXTURE_2D, 0); return texture; } static GLuint build_texture_4_nv24_uv(int width, int height, void *uv_data){ GLuint texture; glGenTextures(1, &amp;texture); glBindTexture(GL_TEXTURE_2D, texture); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexImage2D(GL_TEXTURE_2D, 0, GL_LUMINANCE_ALPHA, width, height, 0, GL_LUMINANCE_ALPHA, GL_UNSIGNED_BYTE, uv_data); glBindTexture(GL_TEXTURE_2D, 0); return texture; } 6.3.2 在shader中提取YUV static const char* nv24_2_rgba_frag_src = \"uniform sampler2D Sampler_y; \\n\" \"uniform sampler2D Sampler_uv; \\n\" \"varying highp vec2 TexCoord; \\n\" \"void main (void) \\n\" \"{ \\n\" \" highp vec3 yuv; \\n\" \" highp vec3 rgb; \\n\" \" \\n\" \" yuv.x = texture2D(Sampler_y, TexCoord).r; \\n\" \" yuv.y = texture2D(Sampler_uv, TexCoord).r; \\n\" \" yuv.z = texture2D(Sampler_uv, TexCoord).a; \\n\" \" \\n\" \" yuv.y = yuv.y - 0.5; \\n\" \" yuv.z = yuv.z - 0.5; \\n\" \" \\n\" \" rgb.r = yuv.x + 1.402 * yuv.z; \\n\" \" rgb.g = yuv.x - 0.34413 * yuv.y - 0.71414 * yuv.z; \\n\" \" rgb.b = yuv.x + 1.772 * yuv.y; \\n\" \" \\n\" \" gl_FragColor = vec4(rgb, 1.0); \\n\" \"} \\n\"; 6.4 NV16-&gt;ARGB 6.4.1 构建纹理 这里需要构建两个纹理，一个是Y的纹理， 一个是UV的纹理 static GLuint build_texture_4_nv16_y(int width, int height, void *data){ GLuint texture; glGenTextures(1, &amp;texture); glBindTexture(GL_TEXTURE_2D, texture); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexImage2D(GL_TEXTURE_2D, 0, GL_LUMINANCE, width, height, 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, data); glBindTexture(GL_TEXTURE_2D, 0); return texture; } 注意glTexImage2D()的第四参数值发生了变化 static GLuint build_texture_4_nv16_uv(int width, int height, void *data){ GLuint texture; glGenTextures(1, &amp;texture); glBindTexture(GL_TEXTURE_2D, texture); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexImage2D(GL_TEXTURE_2D, 0, GL_LUMINANCE_ALPHA, width/2, height, 0, GL_LUMINANCE_ALPHA, GL_UNSIGNED_BYTE, data); glBindTexture(GL_TEXTURE_2D, 0); return texture; } 6.4.2 在shader中提取YUV 与NV24方法相同 6.5 NV12-&gt;ARGB 6.5.1 构建纹理 这里需要构建两个纹理，一个是Y的纹理， 一个是UV的纹理 static GLuint build_texture_4_nv12_y(int width, int height, void *data){ GLuint texture; glGenTextures(1, &amp;texture); glBindTexture(GL_TEXTURE_2D, texture); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexImage2D(GL_TEXTURE_2D, 0, GL_LUMINANCE, width, height, 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, data); glBindTexture(GL_TEXTURE_2D, 0); return texture; } 注意glTexImage2D()的第四,五参数值发生了变化 static GLuint build_texture_4_nv12_uv(int width, int height, void *data){ GLuint texture; glGenTextures(1, &amp;texture); glBindTexture(GL_TEXTURE_2D, texture); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); CHK_GL_ERR(); glTexImage2D(GL_TEXTURE_2D, 0, GL_LUMINANCE_ALPHA, width/2, height/2, 0, GL_LUMINANCE_ALPHA, GL_UNSIGNED_BYTE, data); CHK_GL_ERR(); glBindTexture(GL_TEXTURE_2D, 0); return texture; } 6.5.2 在shader中提取YUV 与NV24方法相同"
  },"/blog/jekyll/2018-02-27-interrupte.html": {
    "title": "硬中断",
    "keywords": "Jekyll",
    "url": "/blog/jekyll/2018-02-27-interrupte.html",
    "body": "【转帖】 本来想写内核如何接收一个网络包这个过程，但发现把整个过程捋顺了，还是很难的。 推导整个过程的起点是中断，包括硬中断和软中断。 而这个过程要是讲清楚吧，感觉在整个网络包接收原理的大流程中有点喧宾夺主。但要是一笔带过吧，那对于这块有困惑的人就很难受，一切的起点没整明白在心里总是个疙瘩。所以，单拎出来一个主题中断，给大家把这个问题搞明白了。 另外，整个操作系统就是一个中断驱动的死循环，操作系统原理如果用一行代码解释，下面这样再合适不过了。 while(true) { doNothing(); } 其他所有事情都是由操作系统提前注册的中断机制和其对应的中断处理函数完成，我们点击一下鼠标，敲击一下键盘，执行一个程序，都是用中断的方式来通知操作系统帮我们处理这些事件，当没有任何需要操作系统处理的事件时，它就乖乖停在死循环里不出来。 所以，中断，非常重要，它也是理解整个操作系统的根基，掌握它，不亏！ 那我们开始吧。 五花八门的中断分类 关于中断的分类，教科书上和网上有很多”标准”答案了，如果你用搜索引擎去寻找答案，可能会找出很多不一样的分类结果。 所以我打算直接在 Intel 手册上找个最官方的标准答案。 在 Intel 手册 Volume 1 Chapter 6.4 Interrupts and Exception 给出。 翻译过来就是，中断可以分为中断和异常，异常又可以分为故障、陷阱、中止。 第一句话有点奇怪，啥叫中断分为中断和异常呢？你看好多文章的时候也是这么写的，不知道你有没有曾疑惑过。 但其实原文的意思准确说是，CPU 提供了两种中断程序执行的机制，中断和异常。第一个中断是个动词，第二个中断才是真正的机制种类。 好吧，我感觉原文也挺奇怪的，但人家就这么叫，没辙。 接下来我只需要翻译一下就好了，再夹杂点自己的解读。 An interrupt is an asynchronous event that is typically triggered by an I/O device. 先说第一个机制中断（interrupt），中断是一个异步事件，通常由 IO 设备触发。比如点击一下鼠标、敲击一下键盘等。 An exception is a synchronous event that is generated when the processor detects one or more predefined conditions while executing an instruction. 再说第二个机制异常（exception），异常是一个同步事件，是 CPU 在执行指令时检测到的反常条件。比如除法异常、错误指令异常，缺页异常等。 这两个机制，殊途同归，都是让 CPU 收到一个中断号，至于 CPU 收到这个中断号之后干嘛，我们暂且不管。 我们先看看收到中断号之前，具体就是中断和异常到底是怎么做到给 CPU 一个中断号的。 先说中断，别眨眼。 有一个设备叫做可编程中断控制器，它有很多的 IRQ 引脚线，接入了一堆能发出中断请求的硬件设备，当这些硬件设备给 IRQ 引脚线发一个信号时，由于可编程中断控制器提前被设置好了 IRQ 与中断号的对应关系，所以就转化成了对应的中断号，把这个中断号存储在自己的一个端口上，然后给 CPU 的 INTR 引脚发送一个信号，CPU 收到 INTR 引脚信号后去刚刚的那个端口读取到这个中断号的值。 估计你被绕晕了，但读我的文章有个好处，太复杂就上动图，来吧。 ![[image-20230320094930185.png]] 你看，最终的目标，就是让 CPU 知道，有中断了，并且也知道中断号是多少。 比如上图中按下了键盘，最终到 CPU 那里的反应就是，得到了一个中断号 0x21。 那异常的机制就更简单了，是 CPU 自己执行指令时检测到的一些反常情况，然后自己给自己一个中断号即可，无需外界给。 比如 CPU 执行到了一个无效的指令，则自己给自己一个中断号 0x06，这个中断号是 Intel 的 CPU 提前就规定好写死了的硬布线逻辑。 好了，到目前为止，我们知道了无论是中断还是异常，最终都是通过各种方式，让 CPU 得到一个中断号。只不过中断是通过外部设备给 CPU 的 INTR 引脚发信号，异常是 CPU 自己执行指令的时候发现特殊情况触发的，自己给自己一个中断号。 还有一种方式可以给到 CPU 一个中断号，但 Intel 手册写在了后面，Chapter 6.4.4 INT n，就是大名鼎鼎的 INT 指令。 ![[image-20230320095004648.png]] INT 指令后面跟一个数字，就相当于直接用指令的形式，告诉 CPU 一个中断号。 比如 INT 0x80，就是告诉 CPU 中断号是 0x80。Linux 内核提供的系统调用，就是用了 INT 0x80 这种指令。 那我们上面的图又丰富了起来。 ![[image-20230320095040034.png]] 有的地方喜欢把他们做一些区分，把 INT n 这种方式叫做软件中断，因为他是由软件程序主动触发的。相应的把上面的中断和异常叫做硬件中断，因为他们都是硬件自动触发的。 但我觉得大可不必，一共就这么几个分类，干嘛还要增加一层理解的成本呢，记三个方式不好么？ 好了，总结一下，给 CPU 一个中断号有三种方式，而这也是中断分类的依据。 1. 通过中断控制器给 CPU 的 INTR 引脚发送信号，并且允许 CPU 从中断控制器的一个端口上读取中断号，比如按下键盘的一个按键，最终会给到 CPU 一个 0x21 中断号。 2. CPU 执行某条指令发现了异常，会自己触发并给自己一个中断号，比如执行到了无效指令，CPU 会给自己一个 0x06 的中断号。 3. 执行 INT n 指令，会直接给 CPU 一个中断号 n，比如触发了 Linux 的系统调用，实际上就是执行了 INT 0x80 指令，那么 CPU 收到的就是一个 0x80 中断号。 再往后，CPU 以各种不同的方式收到的这些 0x21 0x06 0x80，都会一视同仁，做同样的后续处理流程，所以从现在开始，前面的事情就不用再管了，这也体现了分层的好处。 收到中断号之后 CPU 干嘛？ 那 CPU 收到中断号后，如何处理呢？ 先用一句不太准确的话总结，CPU 收到一个中断号 n 后，会去中断向量表中寻找第 n 个中断描述符，从中断描述符中找到中断处理程序的地址，然后跳过去执行。 为什么说不准确呢？因为从中断描述符中找到的，并不直接是程序的地址，而是段选择子和段内偏移地址。然后段选择子又会去全局描述符表中寻找段描述符，从中取出段基址。之后段基址 + 段内偏移地址，才是最终处理程序的入口地址。 当然这个入口地址，还不是最终的物理地址，如果开启了分页，又要经历分页机制的转换，就像下面这样。 不过不要担心，这不是中断的主流程，因为分段机制和分页机制是所有地址转换过程的必经之路，并不是中断这个流程所特有的。 所以我们简单的把中断描述符表中存储的地址，直接当做 CPU 可以跳过去执行的中断处理程序的入口地址，就好了，不影响理解他们。 你看，这是不是简单很多。 那接下来的问题就很简单了，这里出现了两个名词，那就分别对他们进行发问。 1. 中断描述符表是啥？ 2. 中断描述符是啥？ 3. 去哪里找他们？ 分别回答即可 中断描述符表是啥？ 就是一个在内存中的数组而已，操作系统初始化过程中，有很多结构都称之为 XXX 表，其实就是个数组罢了。 以 linux-2.6.0 源码为例，就很直观了。 struct desc_struct idt_table[256] = { {0, 0}, }; 你看，是一个大小为 256 的数组。idt_table 这个名字就是 Interrupt Descriptor Table，逐字翻译过来确实就是中断描述符表。 中断描述符是啥？ 就是中断描述符表这个数组里的存储的数据结构，通过刚刚的源码也可以看出来，是一个叫 desc_struct 的结构。 struct desc_struct {    unsigned long a,b;}; 好家伙，Linux 源码里就这么简单粗暴表示，一个中断描述符的大小为 64 位，也就是 8 个字节，具体里面存的啥通过这个源码看不出来。 翻一下 Intel 手册，在 Volumn 3 Chapter 5.11 IDT Descriptors 中找到了一张图。 可以看到，中断描述符具体还分成好几个种类，有： Task Gate：任务门描述符 Interrupt Gate：中断门描述符 Trap Gate：陷阱门描述符 不要慌，其中任务门描述符 Linux 中几乎没有用到。 中断门描述符和陷阱门描述符的区别仅仅是是否允许中断嵌套，实现方式非常简单粗暴，就是 CPU 如果收到的中断号对应的是一个中断门描述符，就修改 IF 标志位（就是一个寄存器中一位的值），修改了这个值后就屏蔽了中断，也就防止了中断的嵌套。而陷阱门没有改这个标志位，也就允许了中断的嵌套。 所以简单理解的话，你把他们当做同样一个描述符就好了，先别管这些细节，他们的结构几乎完全一样，只是差了一个类型标识罢了。 那这个中断描述符的结构长什么样呢？我们可以清晰地看到，里面有段选择子和段内偏移地址。 回顾下刚刚说的中断处理流程。 没骗你吧。 但以上这些如果你都搞不明白，还是那句话，记这个最简单的流程就好了，不影响理解。 好了，现在我们直观地看到了中断描述符表这个 256 大小的数组，以及它里面存的中断描述符长什么样子，最终的目的，还是帮助 CPU 找到一个程序的入口地址，然后跳转过去。 OK，下一个问题，就是 CPU 怎么寻找到这个中断描述符表的位置呢？它是在内存中一个固定的位置么？ CPU 怎么找到中断描述符表 答案是否定的，中断描述符表在哪里，全凭各个操作系统的喜好，想放在哪里就放在哪里，但需要通过某种方式告诉 CPU，即可。 怎么告诉呢？CPU 提前预留了一个寄存器叫 IDTR 寄存器，这里面存放的就是中断描述符表的起始地址，以及中断描述符表的大小。 在 Volumn 3 Chapter 5.10 Interrupt Descriptor Table 中告诉了我们 IDTR 寄存器的结构。 操作系统的代码可以通过 LIDT 指令，将中断描述符表的地址放在这个寄存器里。 还记得刚刚看的源码么？中断描述符表就是这个。 struct desc_struct idt_table[256] = { {0, 0}, }; 然后操作系统把这个的地址用 LIDT 指令放在 IDTR 寄存器就行了。IDTR 寄存器里的值一共 48 位，前 16 位是中断描述符表大小（字节数），后 32 位是中断描述符表的起始内存地址，就是这个 idt_table 的位置。 Linux-2.6.0 源码中是这样构造这个结构的，简单粗暴。 idt_descr:    .word 256 * 8 - 1    .long idt_table 紧接着，一个 LIDT 指令把这个结构放到 IDTR 寄存器中。 lidt idt_descr 整个过程一气呵成，呵得我连代码格式都懒得调了，是不是很清晰明了。 这样，CPU 收到一个中断号后，中断描述符表的起始位置从 IDTR 寄存器中可以知道，而且里面的每个中断描述符都是 64 位大小，也就是 8 个字节，那自然就可以找到这个中断号对应的中断描述符。 接下来的问题就是，这个中断描述符表是谁来提前写好的？又是怎么写的？ 谁把中断描述符表这个结构写在内存的 很简单，操作系统呗。 在 Linux-2.6.0 内核源码的 traps.c 文件中，有这样一段代码。 void __init trap_init(void) {    set_trap_gate(0, &amp;divide_error);    ...    set_trap_gate(6, &amp;invalid_op);    ...    set_intr_gate(14, &amp;page_fault);    ...    set_system_gate(0x80, &amp;system_call);} 你看，我们刚刚提到的除法异常、非法指令异常、缺页异常，以及之后可能通过 INT 0x80 触发系统调用的中断处理函数 system_call，就是这样被写到了中断描述符表里。 经过这样一番操作后，我们的中断描述符表里的值就丰富了起来。 好了，现在只剩下最后一个问题了，CPU 在找到一个中断描述符后，如何跳过去执行？ 找到中断描述符后，干嘛 现在这个问题可以再问得大一些了，就是 CPU 在收到一个中断号并且找到了中断描述符之后，究竟做了哪些事？ 当然，最简单的办法就是，直接把中断描述符里的中断程序地址取出来，放在自己的 CS:IP 寄存器中，因为这里存的值就是下一跳指令的地址，只要放进去了，到下一个 CPU 指令周期时，就会去那里继续执行了。 但 CPU 并没有这样简单粗暴，而是帮助我们程序员做了好多额外的事情，这增加了我们的学习和理解成本，但方便了写操作系统的程序员，拿到一些中断的信息，以及中断程序结束后的返回工作。 但其实，就是做了一些压栈操作。 1. 如果发生了特权级转移，压入之前的堆栈段寄存器 SS 及栈顶指针 ESP 保存到栈中，并将堆栈切换为 TSS 中的堆栈。 2. 压入标志寄存器 EFLAGS。 3. 压入之前的代码段寄存器 CS 和指令寄存器 EIP，相当于压入返回地址。 4. 如果此中断有错误码的，压入错误码 ERROR_CODE 5. 结束（之后就跳转到中断程序了） 压栈操作结束后，栈就变成了这个样子。 特权级的转移需要切换栈，所以提前将之前的栈指针压入。错误码可以方便中断处理程序做一些工作，如果需要，从栈顶拿到就好了。 抛开这两者不说，剩下的就只有标志寄存器和中断发生前的代码地址，被压入了栈，这很好理解，就是方便中断程序结束后，返回原来的代码嘛~ 具体的压栈工作，以及如何利用这些栈的信息达到结束中断并返回原程序的效果，Intel 手册中也写得很清楚。 Volumn 3A System Programming Guide  Chapter 5.12.1Exception- or Interrupt-Handler Procedures 看下面的话，通过配合 IRET 或 IRETD 指令返回。 由于后续版本的 Linux 自己的玩法比较多，已经不用 Intel 提供的现成指令了，所以这回我们从 Linux-0.11 版源码中寻找答案。 比如除法异常的中断处理函数，在 asm.s 中。 _divide_error: push dword ptr _do_divide_error ;no_error_code: ; xchg [esp],eax ; push ebx push ecx push edx push edi push esi push ebp push ds ; push es push fs push 0 ; lea edx,[esp+44] ; push edx mov edx,10h ; mov ds,dx mov es,dx mov fs,dx call eax ; add esp,8 ; pop fs pop es pop ds pop ebp pop esi pop edi pop edx pop ecx pop ebx pop eax ;// 弹出原来eax 中的内容。 iretd 只看最后一行，确实用了 iretd 指令。 这个指令会依次弹出栈顶的三个元素，把它们分别赋值给 EIP，CS 和 EFLAGS，而栈顶的三个元素，又恰好是 EIP，CS 和 EFLAGS 这样的顺序，你说这巧不巧？ 当然不巧，人家 CPU 执行中断函数前做了压栈操作，然后又提供了 iret 指令做弹栈操作，当然是给你配套使用的！ 你看，中断是如何切到中断处理程序的？就是靠中断描述符表中记录的地址。那中断又如何回到原来的代码继续执行呢？是通过 CPU 帮我们把中断发生前的地址压入了栈中，然后我们程序自己利用他们去返回，当然也可以不返回。 这就是 CPU 和操作系统配合的结果，把中断这个事给解决了。 总结 所以总结起来就是，理解中断，只要回答了这几个问题就好。 如何给 CPU 一个中断号？ 外部设备通过 INTR 引脚，或者 CPU 执行指令的过程中自己触发，或者由软件通过 INT n 指令强行触发。 同样中断也是这样进行分类的。 CPU 收到中断号后如何寻找到中断程序的入口地址？ 通过 IDTR 寄存器找到中断描述符表，通过中断描述符表和中断号定位到中断描述符，取出中断描述符表中存储的程序入口地址。 中断描述符表是谁写的？ 操作系统代码写上去的。 找到程序入口地址之后，CPU 做了什么？ 简单说，实际上做的事情就是压栈，并跳转到入口地址处执行代码。而压栈的目的，就是保护现场（原来的程序地址、原来的程序堆栈、原来的标志位）和传递信息（错误码） 好了，中断讲完了，如果再往后扩大一点点概念，以上说的中断，统统都是硬中断。注意，不叫硬件中断哦。 为什么叫硬中断呢？因为这是 Intel CPU 这个硬件实现的中断机制，注意这里是实现机制，并不是触发机制，因为触发可以通过外部硬件，也可以通过软件的 INT 指令。 那与硬中断对应的还有软中断，这个概念网上好多地方都讲错了，把软中断和 INT 指令这种软件中断混淆了，所以我觉得软件中断最好称其为，由软件触发的中断，而软中断称其为软件实现的中断。 软中断是纯粹由软件实现的一种类似中断的机制，实际上它就是模仿硬件，在内存中有一个地方存储着软中断的标志位，然后由内核的一个线程不断轮询这些标志位，如果有哪个标志位有效，则再去另一个地方寻找这个软中断对应的中断处理程序。 软中断是 Linux 实现中断的下半部的一种非常常见的方式，之后我讲 Linux 内核如何接受网络包这个事情的时候也可以看到，软中断是研究整个过程的一个突破口。 EOF - 推荐阅读  点击标题可跳转 1、10 分钟看懂 Docker 和 K8S 2、这才是中国被卡脖子最严重的软件！ 3、如果让你来设计网络，你会把它弄成啥样？ 看完本文有收获？请分享给更多人 推荐关注「Linux 爱好者」，提升Linux技能 Linux爱好者 点击获取《每天一个Linux命令》系列和精选Linux技术资源。「Linux爱好者」日常分享 Linux/Unix 相关内容，包括：工具资源、使用技巧、课程书籍等。 75篇原创内容 公众号 点赞和在看就是最大的支持❤️ 分享收藏 微信扫一扫 关注该公众号"
  },"/blog/drm/2018-02-01-DRM.html": {
    "title": "DRM子系统",
    "keywords": "DRM",
    "url": "/blog/drm/2018-02-01-DRM.html",
    "body": "一、DRM总述 1.1在整个系统中的位置 App角度 DRM内部 wayland实例 二、图形buffer相关 2.1 dumb buffer 旧时的显卡由一块很小的显存（通常为640x480）加一块数模转换电路（DAC）组成，说白了就是一块 Framebuffer + Display Controller。显卡的功能极其简单，只负责将显存中的图像数据转换成RGB信号发送出去即可，而所有的绘图操作则都交给 CPU 来完成。行业里将这种显卡称为 VGA(Video Graphics Array) Card，它的显存则被称为“Dumb Frame Buffer”。而到了后期，随着显卡技术的不断发展，许多原来由 CPU 干的活，渐渐的都被显卡取代了。从最初支持某些特定绘图指令（如画点、画线）的显卡，到后来支持视频解码的 Video Card，再到现代支持复杂3D渲染指令（如OpenGL）的 GPU 显卡，CPU 绘图的繁重任务彻底得到了解放。与 VGA Card 相比较，行业里将后来显卡的显存称为“Smart Frame Buffer”。 首先从这两种称谓上我们就可以看出，dumb 是 smart 的反义词，因此 dumb 在这里的解释应该是“傻的”或“傻瓜式的”，而不是“哑的”。 dumb buffer 和 smart buffer 的区别就在于，你写到显存里的数据，是可以直接上屏显示的图像内容，还是一堆需要GPU解析的命令和资源数据。 与 dumb buffer 命名类似的还有： dumb-terminal：不支持特殊字符的终端，如“清屏”、“粗体”、“彩色字符”等等 dumb-panel：不带 GRAM 的 panel dumb-TV：与 Smart-TV 相反，指以前老式的黑白电视 如今的 IT 领域，dumb一词更多的代表 “功能简单的”、“老式的”、“传统的” 含义 2.1.1超简单DUMB实现 与dumb buffer相关的userspace接口有四个, 下表列出了它们的名字, 作用和对应要实现的函数 interface Description drm driver ioctl(fd, DRM_IOCTL_MODE_CREATE_DUMB, …) 向驱动申请一个dumb buffer，返回一个handle，指向新分配的buffer .dumb_create() ioctl(fd, DRM_IOCTL_MODE_MAP_DUMB, …) 为buffer map做准备，传入handle，得到一个offset .dumb_map_offset() ioctl(fd, DRM_IOCTL_MODE_DESTROY_DUMB, …) 销毁该dumb buffer .dumb_destroy() mmap(fd, …) 传入 buffer对应的offset，映射到进程空间，返回一个用户空间可使用的地址。 .fops.mmap() 2.1.1.1 简单应用程序 下面是一个简单的应用程序，演示了dumb buffer的申请，mmap，使用和销毁。 #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; #include &lt;sys/mman.h&gt; #include &lt;unistd.h&gt; #include &lt;xf86drm.h&gt; #define log(fmt, args...) printf(\"%s():%d \" fmt \"\\n\", __func__, __LINE__, ##args) #define err(fmt, args...) printf(\"\\033[35m%s():%d \" fmt \"\\033[0m\\n\", __func__, __LINE__, ##args) static int create_dumb_buffer(int fd, int width, int height){ int ret = 0; struct drm_mode_create_dumb create = {}; create.width = width; create.height =height; create.bpp = 4*8; // byte per pixel ret = drmIoctl(fd, DRM_IOCTL_MODE_CREATE_DUMB, &amp;create); if(ret){ err(\"ret:%d\", ret); return 0; } return create.handle; } static int get_dumb_buffer_offset(int fd, int handle){ struct drm_mode_map_dumb map = {}; map.handle = handle; int ret = drmIoctl(fd, DRM_IOCTL_MODE_MAP_DUMB, &amp;map); if(ret){ err(\"ret:%d\", ret); return 0; } return map.offset; } static void* mmap_dumb_buffer(int fd, int size, int offset){ void *addr = NULL; addr = mmap(0, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, offset); if(!addr){ err(\"mmap dumb buffer offset:0x%x failed\", offset); return NULL; } return addr; } static void destroy_dumb_buffer(int fd, int handle){ struct drm_mode_destroy_dumb destroy = {}; destroy.handle = handle; int ret = drmIoctl(fd, DRM_IOCTL_MODE_DESTROY_DUMB, &amp;destroy); if(ret){ err(\"DRM_IOCTL_MODE_DESTROY_DUMB failed. ret:%d\", ret); return; } } int main(int argc, char **argv){ int fd; int width = 1024; int height = 1; int size = width*height; fd = open(\"/dev/dri/card0\", O_RDWR | O_CLOEXEC); if(fd&lt;=0){ err(\"open dev failed.\"); return -1; } int handle = create_dumb_buffer(fd, width, height); log(\"create dumb buffer, get handle:%d\", handle); int offset = get_dumb_buffer_offset(fd, handle); log(\"get dumb buffer offset:0x%x\", offset); void *addr = mmap_dumb_buffer(fd, size, offset); log(\"get dumb buffer addr:%p\",addr); //在addr所指向的buffer上进行绘图 memset(addr, 0, width*height); munmap(addr, size); destroy_dumb_buffer(fd, handle); log(\"destroy dumb buffer\"); getchar(); close(fd); return 0; } 2.1.1.2 实现简单的驱动 基于kernel 5.15.126， 主要是.dumb_create(), .dumb_map_offset(), .dumb_destroy, fops.mmap()的实现 #include &lt;linux/module.h&gt; #include &lt;linux/platform_device.h&gt; #include &lt;drm/drm_drv.h&gt; #include &lt;drm/drm_file.h&gt; #include &lt;drm/drm_ioctl.h&gt; #define DRIVER_NAME \"drm dumb driver\" #define DRIVER_DESC \"Virtual drm dumb driver\" #define DRIVER_DATE \"20191114\" #define DRIVER_MAJOR 1 #define DRIVER_MINOR 0 #define MAX_NUM 10 #define log(fmt, args...) printk(\"%s():%d \" fmt \"\\n\", __func__, __LINE__, ##args) #define err(fmt, args...) printk(\"\\033[35m%s():%d \" fmt \"\\033[0m\\n\", __func__, __LINE__, ##args) struct dumb_device { struct drm_device drm; struct platform_device *platform_dev; }; static struct dumb_device* dumb_device = NULL; static struct page *pages[MAX_NUM] = {0}; static u32 buffer_size[MAX_NUM] = {0}; static int page_idx = 0; static int dumb_mmap_impl(struct file* filp, struct vm_area_struct* vma) { unsigned long pfn_start = 0; unsigned long size = vma-&gt;vm_end - vma-&gt;vm_start; int ret = 0; int idx = 0; /********************************************************************* * vm_pgoff: 也是vm_are_struct的一个字段 * 表示偏移量，它是以page size计数的。 pg表示page计数，off表示偏移 *********************************************************************/ idx = vma-&gt;vm_pgoff; pfn_start = page_to_pfn(pages[idx]); log(\"idx:%d phy: 0x%lx, vm_pgoff: 0x%lx, vma-&gt;vm_start:0x%lx, size: 0x%lx\", idx, pfn_start &lt;&lt; PAGE_SHIFT, vma-&gt;vm_pgoff, vma-&gt;vm_start, size); ret = remap_pfn_range(vma, vma-&gt;vm_start, pfn_start, size, vma-&gt;vm_page_prot); if (ret) err(\"remap_pfn_range failed at [0x%lx 0x%lx]\", vma-&gt;vm_start, vma-&gt;vm_end); else{ unsigned long virt_start = (unsigned long)page_address(pages[idx]); log(\"map 0x%lx to 0x%lx, size: 0x%lx\", virt_start, vma-&gt;vm_start, size); } return 0; } static const struct file_operations dumb_driver_fops = { .owner = THIS_MODULE, .open = drm_open, .release = drm_release, .unlocked_ioctl = drm_ioctl, .compat_ioctl = drm_compat_ioctl, .mmap = dumb_mmap_impl, }; static void dumb_release(struct drm_device* dev) { log(); } static int dumb_create_impl(struct drm_file *file_priv, struct drm_device *dev, struct drm_mode_create_dumb* args) { u32 size = 0; log(); if(page_idx&gt;=MAX_NUM){ err(\"only support alloc %d buffers\", MAX_NUM); return -ENOMEM; } size = roundup((args-&gt;width * args-&gt;height * args-&gt;bpp/8), PAGE_SIZE); // 分配页面 pages[page_idx] = alloc_pages(GFP_KERNEL, get_order(size)); if (!pages[page_idx]) { err(\"alloc_pages() failed\"); return -ENOMEM; } buffer_size[page_idx] = size; // 赋值返回参数 args-&gt;size = size; args-&gt;pitch = args-&gt;width * args-&gt;bpp/8; args-&gt;handle = page_idx++; return 0; } static int dumb_map_offset_impl(struct drm_file *file_priv, struct drm_device *dev, uint32_t handle, uint64_t* offset) { log(\"%d\", handle); //根据handle得到一个offset，为了简单，这里直接使用handle *offset = 0x1000*(u64)handle; return 0; } static int dumb_destroy_impl(struct drm_file *file_priv, struct drm_device *dev, uint32_t handle){ log(\"handle:%d\", handle); free_pages((unsigned long)page_address(pages[handle]), get_order(buffer_size[handle])); return 0; } static struct drm_driver dumb_driver = { .fops = &amp;dumb_driver_fops, .release = dumb_release, .dumb_create = dumb_create_impl, .dumb_map_offset = dumb_map_offset_impl, .dumb_destroy = dumb_destroy_impl, .name = DRIVER_NAME, .desc = DRIVER_DESC, .date = DRIVER_DATE, .major = DRIVER_MAJOR, .minor = DRIVER_MINOR, }; static int __init dumb_drv_init(void) { int ret; struct platform_device* pdev = NULL; log(\"build time: %s %s\", __DATE__, __TIME__); pdev = platform_device_register_simple(DRIVER_NAME, -1, NULL, 0); if (IS_ERR(pdev)) return PTR_ERR(pdev); if (!devres_open_group(&amp;pdev-&gt;dev, NULL, GFP_KERNEL)) { ret = -ENOMEM; goto out_unregister; } // 分配 dumb_device = devm_drm_dev_alloc(&amp;pdev-&gt;dev, &amp;dumb_driver, struct dumb_device, drm); if (IS_ERR(dumb_device)) { ret = PTR_ERR(dumb_device); goto out_devres; } // 注册 ret = drm_dev_register(&amp;dumb_device-&gt;drm, 0); if (ret) goto out_devres; dumb_device-&gt;platform_dev = pdev; log(\"Finish\"); return 0; out_devres: devres_release_group(&amp;pdev-&gt;dev, NULL); out_unregister: platform_device_unregister(pdev); return ret; } static void __exit dumb_drv_exit(void) { struct platform_device *pdev = dumb_device-&gt;platform_dev; log(); drm_dev_unregister(&amp;dumb_device-&gt;drm); devres_release_group(&amp;pdev-&gt;dev, NULL); platform_device_unregister(pdev); } module_init(dumb_drv_init); module_exit(dumb_drv_exit); MODULE_AUTHOR(\"kevin\"); MODULE_DESCRIPTION(DRIVER_DESC); MODULE_LICENSE(\"GPL\"); 2.1.1.3 它们是如何衔接起来的 2.1.2 基于GEM的实现 GEM是系统提供的一套实现框架或者帮助工具。在各自实现私有的drm driver时，总有一些内容是相同或相似的，GEM就对这些相同部分进行了总结，抽象，然后实现了它们，供开发者使用。具体实现在drm_gem.c 2.1.2.1 实现代码 下面是基于GEM对上面driver实现的改造。 它利用了GEM 提供的如下函数： interface 功能 drm_gem_object_init() 初始化一个gem对象 drm_gem_handle_create() 通过gem对象生成一个handle drm_gem_object_lookup() 根据handle 找到对应的gem对象 drm_gem_dumb_map_offset() 通过gem对象生成一个offset drm_gem_mmap() 对mmap()的支持，如果开发者使用它，就可利用gem mmap的实现部分 struct drm_gem_object_funcs 使用gem对象时可能调用到一组函数,此处实现了.mmap,对应drm_gem_mmap() #include &lt;linux/module.h&gt; #include &lt;linux/platform_device.h&gt; #include &lt;drm/drm_gem.h&gt; #include &lt;drm/drm_drv.h&gt; #include &lt;drm/drm_file.h&gt; #include &lt;drm/drm_ioctl.h&gt; #define DRIVER_NAME \"drm dumb gem driver\" #define DRIVER_DESC \"Virtual drm dumb driver\" #define DRIVER_DATE \"20191116\" #define DRIVER_MAJOR 1 #define DRIVER_MINOR 0 #define log(fmt, args...) printk(\"%s():%d \" fmt \"\\n\", __func__, __LINE__, ##args) #define err(fmt, args...) printk(\"\\033[35m%s():%d \" fmt \"\\033[0m\\n\", __func__, __LINE__, ##args) #define DRM_GEM_OBJECT_TO_DUMB_BUFFER_OBJ(target) \\ container_of(target, struct dumb_buffer_object, gem_obj) struct dumb_device { struct drm_device drm; struct platform_device *platform_dev; }; struct dumb_buffer_object{ struct drm_gem_object gem_obj; struct page *start_page; u32 size; }; static struct dumb_device* dumb_device = NULL; static int dumb_gem_mmap_impl(struct file* filp, struct vm_area_struct* vma) { log(\"call drm_gem_mmap()\"); // 利用GEM方法进行mapping， // 在它里面会调用之前设置好的drm_gem_object_funcs.mmap() return drm_gem_mmap(filp, vma); } static const struct file_operations dumb_driver_fops = { .owner = THIS_MODULE, .open = drm_open, .release = drm_release, .poll = drm_poll, .read = drm_read, .llseek = noop_llseek, .mmap = dumb_gem_mmap_impl, .unlocked_ioctl = drm_ioctl, .compat_ioctl = drm_compat_ioctl, }; static int dumb_gem_obj_mmap(struct drm_gem_object *gem_obj, struct vm_area_struct *vma){ int ret = 0; unsigned long pfn_start = 0; unsigned long size = vma-&gt;vm_end - vma-&gt;vm_start; struct dumb_buffer_object *dumb_buffer_obj = NULL; dumb_buffer_obj = DRM_GEM_OBJECT_TO_DUMB_BUFFER_OBJ(gem_obj); log(\"mmaping dumb_buffer_obj:%p\", dumb_buffer_obj); pfn_start = page_to_pfn(dumb_buffer_obj-&gt;start_page); ret = remap_pfn_range(vma, vma-&gt;vm_start, pfn_start, size, vma-&gt;vm_page_prot); if (ret){ err(\"remap_pfn_range failed at [0x%lx 0x%lx]\", vma-&gt;vm_start, vma-&gt;vm_end); } return 0; } static const struct drm_gem_object_funcs dumb_gem_obj_funcs = { .open = NULL, .mmap = dumb_gem_obj_mmap, //.vm_ops = &amp;dumb_gem_vm_ops, // 赋值到struct vm_area_struct 的vm_ops, 供缺页时调用。 }; static void dumb_release(struct drm_device* dev) { log(); } static int dumb_create_gem_impl(struct drm_file* file_priv, struct drm_device* dev, struct drm_mode_create_dumb* args) { u32 size = 0; int ret = 0; struct dumb_buffer_object *dumb_buffer_obj; struct drm_gem_object *gem_obj; log(); size = ALIGN((args-&gt;width * args-&gt;height * args-&gt;bpp/8), PAGE_SIZE); //1. 分配buffer_obj // 可以在此处分配page,也可以在fault时再分配 dumb_buffer_obj = kzalloc(sizeof(*dumb_buffer_obj), GFP_KERNEL); size = roundup(size, PAGE_SIZE); log(\"page_size:%d\",size); // 2. 初始化dumb_buffer_obj内的drm_gem_object gem_obj = &amp;(dumb_buffer_obj-&gt;gem_obj); gem_obj-&gt;funcs = &amp;dumb_gem_obj_funcs; /* 设置该gem object的操作函数 */ drm_gem_object_init(dev, gem_obj, size); // 3. 利用GEM方法生成一个gem_obj对应的handle ret = drm_gem_handle_create(file_priv, gem_obj, &amp;args-&gt;handle); if(ret){ log(); } dumb_buffer_obj-&gt;start_page = alloc_pages(GFP_KERNEL, get_order(size)); if (!dumb_buffer_obj-&gt;start_page) { err(\"alloc_pages() failed\"); return -ENOMEM; } dumb_buffer_obj-&gt;size = size; // 4. 赋值返回参数 args-&gt;size = size; args-&gt;pitch = args-&gt;width*args-&gt;bpp/8; //TODO: 应计算得到 log(\"create dumb_buffer_obj:%p success, return handle:%d\", dumb_buffer_obj, args-&gt;handle); return 0; } static int dumb_map_offset_gem_impl(struct drm_file* file_priv, struct drm_device* dev, uint32_t handle, uint64_t* offset) { int ret; log(\"handle:%d\", handle); // 利用GEM方法得到一个offset ret =drm_gem_dumb_map_offset(file_priv, dev, handle, offset); if(ret){ err(\"drm_gem_dumb_map_offset failed. ret:%d\", ret); }else{ log(\"get offset:0x%llx from drm_gem_dumb_map_offset()\", *offset); } return ret; } static int dumb_release_gem_impl(struct drm_file *file_priv, struct drm_device *dev, u32 handle){ struct drm_gem_object *gem_obj; struct dumb_buffer_object *dumb_buffer_obj = NULL; log(\"\"); gem_obj = drm_gem_object_lookup(file_priv, handle); dumb_buffer_obj = DRM_GEM_OBJECT_TO_DUMB_BUFFER_OBJ(gem_obj); log(\"free page:%p\",dumb_buffer_obj-&gt;start_page); free_pages((unsigned long)page_address(dumb_buffer_obj-&gt;start_page), get_order(dumb_buffer_obj-&gt;size)); kfree(dumb_buffer_obj); return 0; } static struct drm_driver dumb_driver = { .driver_features = DRIVER_GEM, .fops = &amp;dumb_driver_fops, .release = dumb_release, .dumb_create = dumb_create_gem_impl, .dumb_map_offset = dumb_map_offset_gem_impl, .dumb_destroy = dumb_release_gem_impl, .name = DRIVER_NAME, .desc = DRIVER_DESC, .date = DRIVER_DATE, .major = DRIVER_MAJOR, .minor = DRIVER_MINOR, }; static int __init dumb_drv_init(void) { int ret; struct platform_device* pdev = NULL; log(\"build time: %s %s\", __DATE__, __TIME__); pdev = platform_device_register_simple(DRIVER_NAME, -1, NULL, 0); if (IS_ERR(pdev)) return PTR_ERR(pdev); if (!devres_open_group(&amp;pdev-&gt;dev, NULL, GFP_KERNEL)) { ret = -ENOMEM; goto out_unregister; } dumb_device = devm_drm_dev_alloc(&amp;pdev-&gt;dev, &amp;dumb_driver, struct dumb_device, drm); if (IS_ERR(dumb_device)) { ret = PTR_ERR(dumb_device); goto out_devres; } ret = drm_dev_register(&amp;dumb_device-&gt;drm, 0); if (ret) goto out_devres; dumb_device-&gt;platform_dev = pdev; log(\"Finish\"); return 0; out_devres: devres_release_group(&amp;pdev-&gt;dev, NULL); out_unregister: platform_device_unregister(pdev); return ret; } static void __exit dumb_drv_exit(void) { struct platform_device *pdev = dumb_device-&gt;platform_dev; log(); drm_dev_unregister(&amp;dumb_device-&gt;drm); devres_release_group(&amp;pdev-&gt;dev, NULL); platform_device_unregister(pdev); } module_init(dumb_drv_init); module_exit(dumb_drv_exit); MODULE_AUTHOR(\"kevin\"); MODULE_DESCRIPTION(DRIVER_DESC); MODULE_LICENSE(\"GPL\"); 2.1.2.2 流程图 2.2 PRIME PRIME 在 DRM 驱动中其实是一种buffer共享机制，它是基于 dma-buf 来实现的. 2010年2月9日，NVIDIA 官方发布了一项新的双显卡技术 —— Optimus Technology。该技术主要运用于带双显卡的笔记本（集成显卡+独立显卡），可以根据当前集成显卡的工作负载，自动的将一部分图形任务交给独立显卡去处理，以此来达到功耗和性能的最佳平衡。举例来说，一个带 Intel 集成显卡和 NVIDIA 独立显卡的笔记本，通常将集成显卡做为默认显卡，且充当了 Display Controller 的角色。当用户使用办公软件时，由于需要渲染的任务量不多，此时直接由 Intel 集成显卡来完成。而当用户玩3D游戏时，由于图形渲染的负载较重，此时系统会将部分或全部的任务交给 NVIDIA 独立显卡去处理，等处理完后再将结果送回给集成显卡做最后的合成显示。而这整个过程都是由软硬件自动完成的，中间无需人为干预，用户体验十分流畅。只可惜，该技术只能用在 Windows 系统上，Linux 系统不支持。 当时的 Linux 开源社区，Dave Airlie （RedHat Graphics 工程师，DRM 社区 maintainer）在业余时间里研究起 Optimus 技术，并琢磨着怎样在 Linux 平台上实现类似的功能。结果不到2周时间，他就做出了该方案的原型设计，并在自己的笔记本上（Intel集成显卡+ATI独立显卡）实现了该功能的验证。 他将这项技术命名为“PRIME”。 命名为PRIME 主要是映射Optimus Optimus Prime 就是变形金刚 擎天柱的名字！ NVIDIA 当初给他们 Optimus 技术命名的精妙之处：擎天柱本身所具有的变形能力，形象的表达了 Optimus 这项技术可以在功耗和性能之间来回自由变换。 Dave 将他这项 Linux 下的技术命名为 “PRIME”，其实是很巧妙的玩了一把文字游戏，隐晦的告诉大家：DRM Prime 技术就是用来对标 NVIDIA Optimus 技术的。 2.2.1 PRIME的实现 为了实现设备间的buffer共享，需要有一套机制来导出、导入buffer。提供buffer的驱动负责导出buffer，使用buffer的设备导入buffer。 DMA_BUF已经提供了这样一套机制。 在DRM的实现中就使用了这套机制，具体是通过借助dmabuf fd来完成的。 导出buffer的驱动对外提供一个fd，来代表一个buffer， 而要使用这个buffer的其他设备驱动就通过这个fd导入buffer，从而访问该buffer。 在DRM中我们需要实现一定的DMA_BUF接口来支持buffer的导出、导入。 2.2.1.1 export驱动实现 在驱动的实现中主要添加 .prime_handle_to_fd 和 .prime_fd_to_handle_impl的实现。 interface 实现功能 prime_handle_to_fd 需要实现buffer handle 到dmabuf fd的转换 prime_fd_to_handle_impl 需要实现dmabuf fd 到buffer handle的转换 下面是支持buffer导出的简单实现. 在前面code的基础上添加了对dma-buf export的支持,主要是对struct dma_buf_ops的实现。 struct dma_buf_ops结构如下： #include &lt;linux/module.h&gt; #include &lt;linux/platform_device.h&gt; #include &lt;linux/slab.h&gt; #include &lt;linux/dma-buf.h&gt; #include &lt;drm/drm_drv.h&gt; #include &lt;drm/drm_file.h&gt; #include &lt;drm/drm_ioctl.h&gt; #define DRIVER_NAME \"drm prime driver\" #define DRIVER_DESC \"test drm prime driver\" #define DRIVER_DATE \"20191124\" #define DRIVER_MAJOR 1 #define DRIVER_MINOR 0 #define log(fmt, args...) printk(\"%s():%d \" fmt \"\\n\", __func__, __LINE__, ##args) #define err(fmt, args...) printk(\"\\033[35m%s():%d \" fmt \"\\033[0m\\n\", __func__, __LINE__, ##args) struct dumb_device { struct drm_device drm; struct platform_device* platform_dev; }; #define MAX_NUM 10 static struct dumb_device* dumb_device = NULL; static struct page* pages[MAX_NUM] = {0}; static u32 buffer_size[MAX_NUM] = {0}; static int page_idx = 0; static int prime_dmabuf_attach_impl(struct dma_buf* dmabuf, struct dma_buf_attachment* attachment) { log(\"attach dmabuf to device, return attachment\"); return 0; } static void prime_dmabuf_detach_impl(struct dma_buf* dmabuf, struct dma_buf_attachment* attachment) { log(\"detach dmabuf\"); } static struct sg_table* prime_dmabuf_map_impl(struct dma_buf_attachment* attachment, enum dma_data_direction dir) { struct page* page = attachment-&gt;dmabuf-&gt;priv; struct sg_table* table; int err; log(\"page:%p\", page); table = kmalloc(sizeof(*table), GFP_KERNEL); if (!table) { log(); return ERR_PTR(-ENOMEM); } // 生成散列表并赋值 err = sg_alloc_table(table, 1, GFP_KERNEL); if (err) { log(); kfree(table); return ERR_PTR(err); } sg_set_page(table-&gt;sgl, page, PAGE_SIZE, 0); sg_dma_address(table-&gt;sgl) = dma_map_page(&amp;(dumb_device-&gt;platform_dev-&gt;dev), page, 0, PAGE_SIZE, dir); log(\"map attachment into sg_table and return sg_table\"); return table; } static void prime_dmabuf_unmap_impl(struct dma_buf_attachment* attachment, struct sg_table* table, enum dma_data_direction dir) { log(); dma_unmap_page(attachment-&gt;dev, sg_dma_address(table-&gt;sgl), PAGE_SIZE, dir); sg_free_table(table); kfree(table); } static void prime_dmabuf_release_impl(struct dma_buf* dma_buf) { struct page* page = dma_buf-&gt;priv; log(\"put_page:%p\", page); put_page(page); } static int prime_dmabuf_vmap_impl(struct dma_buf* dma_buf, struct dma_buf_map* map) { void* vaddr = NULL; struct page* page = dma_buf-&gt;priv; vaddr = vmap(&amp;page, 1, 0, PAGE_KERNEL); dma_buf_map_set_vaddr(map, vaddr); log(\"mapping page:%p, get virtual addr:%p\", page, vaddr); return 0; } static void prime_dmabuf_vunmap_impl(struct dma_buf* dma_buf, struct dma_buf_map* map) { log(\"unmapping addr:%p\", map-&gt;vaddr); vunmap(map-&gt;vaddr); } static int prime_dmabuf_mmap_impl(struct dma_buf* dma_buf, struct vm_area_struct* vma) { struct page* page = dma_buf-&gt;priv; log(); return remap_pfn_range(vma, vma-&gt;vm_start, page_to_pfn(page), PAGE_SIZE, vma-&gt;vm_page_prot); } static const struct dma_buf_ops exp_dmabuf_ops = { .attach = prime_dmabuf_attach_impl, .detach = prime_dmabuf_detach_impl, .map_dma_buf = prime_dmabuf_map_impl, .unmap_dma_buf = prime_dmabuf_unmap_impl, .release = prime_dmabuf_release_impl, .mmap = prime_dmabuf_mmap_impl, .vmap = prime_dmabuf_vmap_impl, .vunmap = prime_dmabuf_vunmap_impl, }; static int prime_handle_to_fd_impl(struct drm_device* dev, struct drm_file* file_priv, uint32_t handle, uint32_t flags, int* prime_fd) { DEFINE_DMA_BUF_EXPORT_INFO(exp_info); struct dma_buf* dmabuf; log(\"dma_buf -&gt; page:%p\", pages[handle]); exp_info.ops = &amp;exp_dmabuf_ops; exp_info.size = buffer_size[handle]; exp_info.flags= O_CLOEXEC; exp_info.priv = pages[handle]; // buffer和dmabuf建立关联 // 构建一个dma_buf dmabuf = dma_buf_export(&amp;exp_info); if (IS_ERR(dmabuf)) { log(); return -1; } // 为该dma_buf生成fd *prime_fd = dma_buf_fd(dmabuf, O_CLOEXEC); if (prime_fd &lt;= 0) { log(); return -1; } return 0; } static int prime_fd_to_handle_impl(struct drm_device* dev, struct drm_file* file_priv, int prime_fd, uint32_t* handle) { struct dma_buf* dma_buf; struct page* page = NULL; int idx = 0; log(); dma_buf = dma_buf_get(prime_fd); page = dma_buf-&gt;priv; if (dma_buf-&gt;ops == &amp;exp_dmabuf_ops) { for (idx = 0; idx &lt; MAX_NUM; idx++) { if (pages[idx] == page) { break; } } *handle = idx; log(\"return handle:%d\", *handle); } else { log(\"doesn't support\"); return -1; } dma_buf_put(dma_buf); return 0; } static const struct file_operations dumb_driver_fops = { .owner = THIS_MODULE, .open = drm_open, .release = drm_release, .unlocked_ioctl = drm_ioctl, .compat_ioctl = drm_compat_ioctl, }; static void dumb_release(struct drm_device* dev) { log(); } static int dumb_create_impl(struct drm_file *file_priv, struct drm_device *dev, struct drm_mode_create_dumb* args) { u32 size = 0; log(); if(page_idx&gt;=MAX_NUM){ err(\"only support alloc %d buffers\", MAX_NUM); return -ENOMEM; } size = roundup((args-&gt;width * args-&gt;height * args-&gt;bpp/8), PAGE_SIZE); // 分配页面 pages[page_idx] = alloc_pages(GFP_KERNEL, get_order(size)); if (!pages[page_idx]) { err(\"alloc_pages() failed\"); return -ENOMEM; } buffer_size[page_idx] = size; // 赋值返回参数 args-&gt;size = size; args-&gt;pitch = args-&gt;width * args-&gt;bpp/8; args-&gt;handle = page_idx++; return 0; } static int dumb_destroy_impl(struct drm_file *file_priv, struct drm_device *dev, uint32_t handle){ log(\"handle:%d\", handle); //__free_pages(pages[handle], get_order(dumb_buffer_size[handle])); free_pages((unsigned long)page_address(pages[handle]), get_order(buffer_size[handle])); return 0; } static struct drm_driver dumb_driver = { .release = dumb_release, .fops = &amp;dumb_driver_fops, .dumb_create = dumb_create_impl, .dumb_destroy = dumb_destroy_impl, .prime_handle_to_fd = prime_handle_to_fd_impl, .prime_fd_to_handle = prime_fd_to_handle_impl, //其他驱动分配的dma_buf导入到DRM系统 .name = DRIVER_NAME, .desc = DRIVER_DESC, .date = DRIVER_DATE, .major = DRIVER_MAJOR, .minor = DRIVER_MINOR, }; static int __init dumb_drv_init(void) { int ret; struct platform_device* pdev = NULL; log(\"build time: %s %s\", __DATE__, __TIME__); pdev = platform_device_register_simple(DRIVER_NAME, -1, NULL, 0); if (IS_ERR(pdev)) return PTR_ERR(pdev); if (!devres_open_group(&amp;pdev-&gt;dev, NULL, GFP_KERNEL)) { ret = -ENOMEM; goto out_unregister; } // 分配 dumb_device = devm_drm_dev_alloc(&amp;pdev-&gt;dev, &amp;dumb_driver, struct dumb_device, drm); if (IS_ERR(dumb_device)) { ret = PTR_ERR(dumb_device); goto out_devres; } // 注册 ret = drm_dev_register(&amp;dumb_device-&gt;drm, 0); if (ret) goto out_devres; dumb_device-&gt;platform_dev = pdev; log(\"Finish\"); return 0; out_devres: devres_release_group(&amp;pdev-&gt;dev, NULL); out_unregister: platform_device_unregister(pdev); return ret; } static void __exit dumb_drv_exit(void) { struct platform_device *pdev = dumb_device-&gt;platform_dev; log(); drm_dev_unregister(&amp;dumb_device-&gt;drm); devres_release_group(&amp;pdev-&gt;dev, NULL); platform_device_unregister(pdev); } module_init(dumb_drv_init); module_exit(dumb_drv_exit); MODULE_AUTHOR(\"kevin\"); MODULE_DESCRIPTION(DRIVER_DESC); MODULE_LICENSE(\"GPL\"); 2.2.1.1 import驱动实现 import dmabuf 的驱动部分实现较为简单，主要是对下列函数的调用,这些函数正好和上面struct dma_buf_ops的实现相对应。 function 功能 dma_buf_get 由fd得到对应的struct dma_buf dma_buf_attach attach dmabuf 到一个设备，得到一个 dma_buf_attachment dma_buf_map_attachment 把一个dmabuf映射到一个设备的地址空间 dma_buf_unmap_attachment 取消dmabuf在设备地址空间的映射 dma_buf_detach 取消与设备的关联 #include &lt;linux/dma-buf.h&gt; #include &lt;linux/module.h&gt; #include &lt;linux/miscdevice.h&gt; #include &lt;linux/slab.h&gt; #define log(fmt, args...) printk(\"%s():%d \" fmt \"\\n\", __func__, __LINE__, ##args) static int test_dma_buf(struct dma_buf* dma_buf) { struct dma_buf_attachment* attachment; struct sg_table* table; struct device* dev; unsigned int reg_addr, reg_size; struct scatterlist* sg; struct page* page; int i = 0; if (!dma_buf) { log(); return -EINVAL; } dev = kzalloc(sizeof(*dev), GFP_KERNEL); if (!dev) { log(); return -ENOMEM; } dev_set_name(dev, \"importer\"); attachment = dma_buf_attach(dma_buf, dev); if (IS_ERR(attachment)) { pr_err(\"dma_buf_attach() failed\\n\"); return PTR_ERR(attachment); } log(\"call dma_buf_map_attachment to get sg_table\"); table = dma_buf_map_attachment(attachment, DMA_BIDIRECTIONAL); if (IS_ERR(table)) { pr_err(\"dma_buf_map_attachment() failed\\n\"); dma_buf_detach(dma_buf, attachment); return PTR_ERR(table); } log(\"table-&gt;nents:%d\", table-&gt;nents); sg = table-&gt;sgl; for (i = 0; i &lt; table-&gt;nents; i++) { reg_addr = sg_dma_address(sg); reg_size = sg_dma_len(sg); page = sg_page(sg); log(\"addr = 0x%08x, size = 0x%08x %p %p\\n\", reg_addr, reg_size, page, page_address(page)); sg = sg_next(sg); } // do something on dma-buf log(\"unmap and detach dma_buf\"); dma_buf_unmap_attachment(attachment, table, DMA_BIDIRECTIONAL); dma_buf_detach(dma_buf, attachment); return 0; } static long importer_ioctl(struct file* filp, unsigned int cmd, unsigned long arg) { int fd; struct dma_buf* dma_buf; if (copy_from_user(&amp;fd, (void __user*)arg, sizeof(int))) { log(\"copy_from_user() failed\"); return -EFAULT; } dma_buf = dma_buf_get(fd); log(\"get dma_buf:%p by fd:%d\", dma_buf, fd); if (IS_ERR(dma_buf)) { log(); return PTR_ERR(dma_buf); } test_dma_buf(dma_buf); return 0; } static struct file_operations importer_fops = { .owner = THIS_MODULE, .unlocked_ioctl = importer_ioctl, }; static struct miscdevice mdev = { .minor = MISC_DYNAMIC_MINOR, .name = \"importer\", .fops = &amp;importer_fops, }; static int __init importer_init(void) { log(); return misc_register(&amp;mdev); } static void __exit importer_exit(void) { log(); misc_deregister(&amp;mdev); } module_init(importer_init); module_exit(importer_exit); MODULE_LICENSE(\"GPL v2\"); 2.2.1.1 进程间分享fd 如果要不同设备中共享buffer，就需要导入dmabuf到不同的设备中，这就涉及到一个fd共享的问题。我们知道fd是和进程相关的，每个进程都有它自己的文件描述符表，不同进程的fd表是不同的。所以不能把一个进程的fd直接传递给另一个进程中使用，需要通过一定的方法来共享fd，也就是fd的跨进程传递。 这个方法就是UNIX域的socket接口。 代码如下： 发送方代码： #define SHARE_DMABUF_PATH \"./share_dmabuf_file\" static void send_fd(int fd) { int ret = 0; char c = 0; struct iovec iov[1]; iov[0].iov_base = &amp;c; iov[0].iov_len = 1; int sockfd = 0; struct sockaddr_un addr; bzero(&amp;addr, sizeof(addr)); addr.sun_family = AF_UNIX; strcpy(addr.sun_path, SHARE_DMABUF_PATH); sockfd = socket(AF_UNIX, SOCK_STREAM, 0); if (sockfd &lt; 0) { perror(\"socket error\"); exit(-1); } ret = connect(sockfd, (struct sockaddr *)&amp;addr, sizeof(addr)); if(ret &lt;0){ perror(\"connect() failed\"); exit(0); } int cmsgsize = CMSG_LEN(sizeof(int)); struct cmsghdr* cmptr = (struct cmsghdr*)malloc(cmsgsize); if(cmptr == NULL){ err_exit(); } cmptr-&gt;cmsg_level = SOL_SOCKET; cmptr-&gt;cmsg_type = SCM_RIGHTS; cmptr-&gt;cmsg_len = cmsgsize; struct msghdr msg; msg.msg_iov = iov; msg.msg_iovlen = 1; msg.msg_name = NULL; msg.msg_namelen = 0; msg.msg_control = cmptr; msg.msg_controllen = cmsgsize; *(int *)CMSG_DATA(cmptr) = fd; ret = sendmsg(sockfd, &amp;msg, 0); if (ret == -1){ perror(\"sendmsg() failed.\"); err_exit(); } free(cmptr); close(sockfd); } 接收方代码 static int recv_fd(int sock) { struct cmsghdr* pcmsg = NULL; union { struct cmsghdr cm; char control[CMSG_SPACE(sizeof(int))]; } control_un; char buf; struct iovec iov[1]; iov[0].iov_base = &amp;buf; iov[0].iov_len = sizeof(buf); struct msghdr msg; msg.msg_iov = iov; msg.msg_iovlen = 1; msg.msg_name = NULL; msg.msg_namelen = 0; msg.msg_control = control_un.control; msg.msg_controllen = sizeof(control_un.control);; int ret = recvmsg(sock, &amp;msg, 0); if (ret == -1) { printf(\"\\033[31m%s:%d sock:%d err:%m \\033[0m\\n\\n\",__func__,__LINE__, sock); exit(1); } pcmsg = CMSG_FIRSTHDR(&amp;msg); int fd = *(int *)CMSG_DATA(pcmsg); return fd; } static int recv_prime_fd_from_socket(void){ int sockfd = 0; struct sockaddr_un addr; unlink(SHARE_DMABUF_PATH); addr.sun_family = AF_UNIX; strcpy(addr.sun_path, SHARE_DMABUF_PATH); int prime_fd; int clientfd; struct sockaddr cliaddr; socklen_t clilen; unsigned int len = strlen(addr.sun_path) + sizeof(addr.sun_family); sockfd = socket(AF_UNIX, SOCK_STREAM, 0); if (sockfd &lt; 0) { perror(\"socket error\"); exit(-1); } if (bind(sockfd, (struct sockaddr*)&amp;addr, len) &lt; 0) { perror(\"bind error\"); close(sockfd); exit(-1); } listen(sockfd, 2); clientfd = accept(sockfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen); if(clientfd&lt;=0){ log(\"clientfd:%d %m\", clientfd); exit(-1); } prime_fd = recv_fd(clientfd); log(\"Recv prime_fd: %d\", prime_fd); return prime_fd; } 2.2.1.2 测试程序 基于上述进程间分享fd的方法，结合PRIME export和import驱动实现，可以写出如下测试PRIME的code 导出 prime 部分 #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;xf86drm.h&gt; #include &lt;sys/socket.h&gt; #include &lt;sys/un.h&gt; #define SHARE_DMABUF_PATH \"./tt\" #define log(fmt, args...) printf(\"%s():%d \" fmt \"\\n\", __func__, __LINE__, ##args) #define err_return(fmt, args...) do{ \\ printf(\"%s():%d \" fmt \"\\n\", __func__, __LINE__, ##args); \\ return -1;\\ }while(0) #define err_exit(fmt, args...) do{ \\ printf(\"%s():%d \" fmt \"\\n\", __func__, __LINE__, ##args); \\ exit(1);\\ }while(0) struct buffer_object { uint32_t width; uint32_t height; uint32_t pitch; uint32_t handle; uint32_t size; int prime_fd; }; struct buffer_object buf; static int create_dumb_get_prime_fd(int fd, struct buffer_object *bo){ int ret = 0; struct drm_mode_create_dumb create = {}; create.width = bo-&gt;width; create.height = bo-&gt;height; create.bpp = 4*8; //ARGB ret = drmIoctl(fd, DRM_IOCTL_MODE_CREATE_DUMB, &amp;create); if(ret){ err_return(\"drmIoctl(DRM_IOCTL_MODE_CREATE_DUMB) failed\"); } ret = drmPrimeHandleToFD(fd, create.handle, DRM_CLOEXEC, &amp;bo-&gt;prime_fd); if(ret){ err_return(\"drmPrimeHandleToFD() failed\"); } bo-&gt;handle = create.handle; log(\"get handle:%d prime fd:%d\", create.handle, bo-&gt;prime_fd); return 0; } static void destroy_fd(int fd, struct buffer_object *bo){ int ret = 0; uint32_t handle = 0; struct drm_mode_destroy_dumb destroy = {}; ret = drmPrimeFDToHandle(fd, bo-&gt;prime_fd, &amp;handle); if(ret){ err_exit(\"drmFDToPrimeHandle() failed\"); } log(\"handle:%d vs bo-&gt;handle:%d\", handle, bo-&gt;handle); destroy.handle = handle; drmIoctl(fd, DRM_IOCTL_MODE_DESTROY_DUMB, &amp;destroy); } int main(int argc, char **argv){ int fd; fd = open(\"/dev/dri/card0\", O_RDWR | O_CLOEXEC); if(fd&lt;=0){ printf(\"%s():%d\\n\", __func__,__LINE__); return -1; } buf.width = 1024; buf.height = 1; create_dumb_get_prime_fd(fd, &amp;buf); send_fd(buf.prime_fd); printf(\"press any key to exit\\n\"); getchar(); destroy_fd(fd, &amp;buf); close(fd); return 0; } 导入prime 部分 #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/socket.h&gt; #include &lt;sys/un.h&gt; #include &lt;sys/ioctl.h&gt; #define log(fmt, args...) printf(\"%s():%d \" fmt \"\\n\", __func__, __LINE__, ##args) #define SHARE_DMABUF_PATH \"./tt\" #define err_return(fmt, args...) do{ \\ printf(\"%s():%d \" fmt \"\\n\", __func__, __LINE__, ##args); \\ return -1;\\ }while(0) #define err_return_void(fmt, args...) do{ \\ printf(\"%s():%d \" fmt \"\\n\", __func__, __LINE__, ##args); \\ return;\\ }while(0) int main(int argc, char **argv){ int ret = 0; int fd; int prime_fd = 5; fd = open(\"/dev/importer\", O_RDWR | O_CLOEXEC); if(fd&lt;=0){ printf(\"%s():%d\\n\", __func__,__LINE__); return -1; } prime_fd = recv_prime_fd_from_socket(); // 把fd传递给import驱动进行访问 ret = ioctl(fd, 0, &amp;prime_fd); if(ret&lt;0){ err_return(\"ioctl failed\"); } close(prime_fd); close(fd); return 0; } 2.3 系统现有的两种实现 2.3.1 share memory 2.3.2 CMA 三、KMS的相关 3.1 传统实现 3.2 atomic实现"
  }}
