{"/blog/jekyll/2024-04-27-git.html": {
    "title": "git",
    "keywords": "Jekyll",
    "url": "/blog/jekyll/2024-04-27-git.html",
    "body": "åœ¨Gitä¸­ï¼Œä½ å¯ä»¥ä½¿ç”¨git diffå‘½ä»¤æ¥æ¯”è¾ƒä¸åŒåˆ†æ”¯ä¸­æŸä¸ªæ–‡ä»¶çš„å·®å¼‚ã€‚ä»¥ä¸‹æ˜¯å…·ä½“çš„å‘½ä»¤ï¼š git diff &lt;branch1&gt;..&lt;branch2&gt; -- &lt;file&gt; å…¶ä¸­ï¼Œ&lt;branch1&gt;å’Œ&lt;branch2&gt;æ˜¯ä½ æƒ³è¦æ¯”è¾ƒçš„ä¸¤ä¸ªåˆ†æ”¯çš„åç§°ï¼Œ&lt;file&gt;æ˜¯ä½ æƒ³è¦æ¯”è¾ƒçš„æ–‡ä»¶çš„è·¯å¾„ã€‚è¿™ä¸ªå‘½ä»¤ä¼šæ˜¾ç¤ºå‡º&lt;branch1&gt;å’Œ&lt;branch2&gt;ä¹‹é—´&lt;file&gt;çš„å·®å¼‚ã€‚ ä¾‹å¦‚ï¼Œå¦‚æœä½ æƒ³è¦æ¯”è¾ƒmasteråˆ†æ”¯å’Œdevåˆ†æ”¯ä¸­README.mdæ–‡ä»¶çš„å·®å¼‚ï¼Œä½ å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ï¼š git diff master..dev -- README.md è¿™ä¸ªå‘½ä»¤ä¼šæ˜¾ç¤ºå‡ºmasteråˆ†æ”¯å’Œdevåˆ†æ”¯ä¸­README.mdæ–‡ä»¶çš„å·®å¼‚ã€‚å¸Œæœ›è¿™ä¸ªä¿¡æ¯å¯¹ä½ æœ‰æ‰€å¸®åŠ©ï¼"
  },"/blog/jekyll/2022-05-02-App_misc.html": {
    "title": "linux dev misc",
    "keywords": "Jekyll",
    "url": "/blog/jekyll/2022-05-02-App_misc.html",
    "body": "pthread_mutex_t&amp;pthread_cond_t å‡½æ•°å®šä¹‰ï¼š int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex) int pthread_cond_broadcast(pthread_cond_t *cond) å‡½æ•°è¯´æ˜ï¼š pthread_cond_wait ï¼šæœ‰ä¸¤ä¸ªè¾“å…¥å‚æ•°ï¼Œä¸€ä¸ªæ˜¯pthread_cond_tï¼Œæ˜¯å‡½æ•°å°†è¦ç­‰å¾…çš„ä¿¡å·ï¼Œå¦ä¸€ä¸ªæ˜¯ pthread_mutex_tï¼Œä¸€ä¸ªäº’æ–¥é”ã€‚ç”¨äºå¯¹ä¿¡å·é‡è¿›è¡Œä¿æŠ¤ï¼Œé˜²æ­¢å¤šä¸ªçº¿ç¨‹åŒæ—¶å¯¹å…¶è¿›è¡Œæ“ä½œã€‚åœ¨çº¿ç¨‹å¼€å§‹ç­‰å¾…ä¿¡å·é‡å‰ï¼Œå¿…é¡»ç”±æœ¬çº¿ç¨‹å¯¹äº’æ–¥é”è¿›è¡Œé”å®šï¼Œç„¶åpthread_cond_waitä¼šæ›´æ–°æ¡ä»¶ç­‰å¾…é˜Ÿåˆ—ï¼Œå¹¶ä¸”é‡Šæ”¾äº’æ–¥é‡ï¼Œå…è®¸å…¶ä»–çº¿ç¨‹è¿›è¡Œè®¿é—®ï¼›å½“cond æ»¡è¶³æ¡ä»¶å…è®¸çº¿ç¨‹ç»§ç»­æ‰§è¡Œæ—¶ï¼Œwait_condä¹Ÿä¼šå…ˆå¯¹mutex è¿›è¡Œé”å®šï¼Œå¯¹condè¿›è¡Œå¤„ç†ï¼Œç„¶åå†å…è®¸çº¿ç¨‹ç»§ç»­è¿è¡Œã€‚æ‰€ä»¥pthread_cond_wait() åçš„pthread_mutex_unlock()è¿˜æ˜¯å¿…è¦çš„ã€‚ #include &lt;pthread.h&gt; #include &lt;iostream&gt; #include &lt;unistd.h&gt; using namespace std; static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER; static pthread_cond_t cond = PTHREAD_COND_INITIALIZER; static void* func_1(void* arg){ cout &lt;&lt; \"func_1 start\" &lt;&lt; endl; pthread_mutex_lock(&amp;mtx); cout &lt;&lt; \"func_1 lock mtx\" &lt;&lt; endl; cout &lt;&lt; \"func_1 wait cond\" &lt;&lt; endl; pthread_cond_wait(&amp;cond, &amp;mtx); cout &lt;&lt; \"func_1 unlock mtx\" &lt;&lt; endl; pthread_mutex_unlock(&amp;mtx); cout &lt;&lt; \"func_1 end\" &lt;&lt; endl; sleep(5); return NULL; } static void* func_2(void* arg){ cout &lt;&lt; \"func_2 start\" &lt;&lt; endl; pthread_mutex_lock(&amp;mtx); cout &lt;&lt; \"func_2 lock mtx\" &lt;&lt; endl; cout &lt;&lt; \"func_2 wait cond\" &lt;&lt; endl; pthread_cond_wait(&amp;cond, &amp;mtx); cout &lt;&lt; \"func_2 unlock mtx\" &lt;&lt; endl; pthread_mutex_unlock(&amp;mtx); cout &lt;&lt; \"func_2 end\" &lt;&lt; endl; sleep(5); return NULL; } int main(){ pthread_t tid1, tid2; cout &lt;&lt; \"main create thread\" &lt;&lt; endl; pthread_create(&amp;tid1, NULL, func_1, NULL); pthread_create(&amp;tid2, NULL, func_2, NULL); sleep(3); cout &lt;&lt; \"main boradcast signal\" &lt;&lt; endl; pthread_cond_broadcast(&amp;cond); // pthread_cond_signal(&amp;cond); cout &lt;&lt; \"main join thread\" &lt;&lt; endl; pthread_join(tid1, NULL); pthread_join(tid2, NULL); cout &lt;&lt; \"main end\" &lt;&lt; endl; return 0; } char *a vs char a[] é¦–å…ˆè¦ææ¸…æ¥šç¼–è¯‘ç¨‹åºå ç”¨çš„å†…å­˜çš„åˆ†åŒºå½¢å¼ï¼š ä¸€ã€é¢„å¤‡çŸ¥è¯†â€”ç¨‹åºçš„å†…å­˜åˆ†é… ä¸€ä¸ªç”±c/C++ç¼–è¯‘çš„ç¨‹åºå ç”¨çš„å†…å­˜åˆ†ä¸ºä»¥ä¸‹å‡ ä¸ªéƒ¨åˆ†: æ ˆåŒºï¼ˆstackï¼‰â€”ç”±ç¼–è¯‘å™¨è‡ªåŠ¨åˆ†é…é‡Šæ”¾ï¼Œå­˜æ”¾å‡½æ•°çš„å‚æ•°å€¼ï¼Œå±€éƒ¨å˜é‡çš„å€¼ç­‰ã€‚å…¶æ“ä½œæ–¹å¼ç±»ä¼¼äºæ•°æ®ç»“æ„ä¸­çš„æ ˆã€‚ å †åŒºï¼ˆheapï¼‰â€”ä¸€èˆ¬ç”±ç¨‹åºå‘˜åˆ†é…é‡Šæ”¾ï¼Œè‹¥ç¨‹åºå‘˜ä¸é‡Šæ”¾ï¼Œç¨‹åºç»“æŸæ—¶å¯èƒ½ç”±OSå›æ”¶ã€‚æ³¨æ„å®ƒä¸æ•°æ®ç»“æ„ä¸­çš„å †æ˜¯ä¸¤å›äº‹ï¼Œåˆ†é…æ–¹å¼å€’æ˜¯ç±»ä¼¼äºé“¾è¡¨ï¼Œå‘µå‘µã€‚ å…¨å±€åŒºï¼ˆé™æ€åŒºï¼‰ï¼ˆstaticï¼‰â€”å…¨å±€å˜é‡å’Œé™æ€å˜é‡çš„å­˜å‚¨æ˜¯æ”¾åœ¨ä¸€å—çš„ï¼Œåˆå§‹åŒ–çš„å…¨å±€å˜é‡å’Œé™æ€å˜é‡åœ¨ä¸€å—åŒºåŸŸï¼Œæœªåˆå§‹åŒ–çš„å…¨å±€å˜é‡å’Œæœªåˆå§‹åŒ–çš„é™æ€å˜é‡åœ¨ç›¸é‚»çš„å¦ä¸€å—åŒºåŸŸã€‚ç¨‹åºç»“æŸåç”±ç³»ç»Ÿé‡Šæ”¾ã€‚ å­—ç¬¦å¸¸é‡åŒºâ€”å¸¸é‡å­—ç¬¦ä¸²å°±æ˜¯æ”¾åœ¨è¿™é‡Œçš„ã€‚ç¨‹åºç»“æŸåç”±ç³»ç»Ÿé‡Šæ”¾ã€‚ ç¨‹åºä»£ç åŒº è¿™æ˜¯ä¸€ä¸ªåˆ«äººå†™çš„ï¼Œéå¸¸è¯¦ç»† int a=0; //å…¨å±€åˆå§‹åŒ–åŒº char p1; //å…¨å±€æœªåˆå§‹åŒ–åŒº main() { int b; //æ ˆ char s[]=\"abc\"; //æ ˆ char p2; //æ ˆ char p3=\"123456\"; //123456\\0åœ¨å¸¸é‡åŒºï¼Œp3åœ¨æ ˆä¸Šã€‚ static int c = 0; //å…¨å±€ï¼ˆé™æ€ï¼‰åˆå§‹åŒ–åŒº p1 = (char)malloc(10); p2 = (char)malloc(20); //åˆ†é…å¾—æ¥å¾—10å’Œ20å­—èŠ‚çš„åŒºåŸŸå°±åœ¨å †åŒºã€‚ strcpy(p1,\"123456\"); //123456\\0æ”¾åœ¨å¸¸é‡åŒºï¼Œç¼–è¯‘å™¨å¯èƒ½ä¼šå°†å®ƒä¸p3æŒ‡å‘çš„\"123456\"ä¼˜åŒ–æˆä¸€ä¸ªåœ°æ–¹ã€‚ } é¦–å…ˆï¼Œæˆ‘ä»¬è¦çŸ¥é“ char *aä¸­çš„aæ˜¯ä¸ªæŒ‡å‘å­—ç¬¦ç±»å‹çš„æŒ‡é’ˆï¼Œè¿™æ˜¯ä¸€ä¸ªå˜é‡ï¼› char a[]ä¸­çš„aä¹Ÿæ˜¯ä¸€ä¸ªæŒ‡å‘å­—ç¬¦ç±»å‹çš„æŒ‡é’ˆï¼Œä½†å®ƒæ˜¯ä¸€ä¸ªå¸¸é‡ï¼Œå¸¸é‡æ˜¯ä¸èƒ½å†ç»™å®ƒèµ‹å€¼çš„ï¼Œå°±åƒæ¯”ä¸èƒ½å†™ 3=2 è¿™æ ·çš„ä»£ç æ¥ç»™3èµ‹å€¼, ä½†å¯ä»¥å¯¹å¥¹æŒ‡å‘çš„å†…å­˜å†…å®¹è¿›è¡Œä¿®æ”¹ã€‚ é€šè¿‡é˜…è¯»æˆ‘ä»¬å¯ä»¥çŸ¥é“ï¼Œchar * a=â€œabcâ€å’Œchar a[]=â€abcâ€åœ¨å†…å­˜ä¸­å­˜æ”¾æ˜¯æœ‰å·®åˆ«çš„ï¼Œ char *a=â€œabcâ€ä¸­çš„â€œabcâ€æ˜¯å­˜æ”¾äºå­—ç¬¦å¸¸é‡åŒºçš„ï¼ŒæŒ‡é’ˆaåªæ˜¯æŒ‡å‘äº†è¿™ä¸ªåœ°å€ï¼› char a[]=â€abcâ€ä¸­çš„â€œabcâ€å…¶å®æ˜¯æ”¾åœ¨æ ˆä¸­çš„ï¼Œå®ƒæ˜¯å­—ç¬¦å¸¸é‡åŒºä¸­â€œabcâ€çš„ä¸€ä»½æ‹·è´ã€‚ çœ‹çœ‹ä¸‹é¢è¿™æ®µä»£ç ä½ å°±æ˜ç™½äº† #include &lt;stdio.h&gt; int main() { char * a1 = \"abc\"; char a2[] = \"abc\"; char * a3 = \"abc\"; char a4[] = \"abc\"; printf(\"char * a:%p\\n\", a1);//æ‰“å°a1çš„å€¼ printf(\"char a2[]:%p\\n\",a2);//æ‰“å°a2çš„å€¼ printf(\"char *a3:%p\\n\", a3);//æ‰“å°a2çš„å€¼ printf(\"char a4[]:%p\\n\",a4);//æ‰“å°a2çš„å€¼ return 0; } æˆ‘åœ¨è¿™æ®µä»£ç é‡Œå£°æ˜äº†ä¸¤ä¸ªå­—ç¬¦æŒ‡é’ˆå˜é‡ã€ä¸¤ä¸ªæ•°ç»„å¸¸é‡æŒ‡é’ˆï¼Œä»£ç æ‰§è¡Œç»“æœå¦‚ä¸‹ï¼š æ˜¾è€Œæ˜“è§å­—ç¬¦æŒ‡é’ˆå˜é‡a å’Œa3çš„å€¼æ˜¯ä¸€æ ·çš„ï¼Œè¿™è¯´æ˜å®ƒä»¬æŒ‡å‘åŒä¸€å—å†…å­˜ï¼Œè¿™å—å†…å­˜å°±æ˜¯ä¸Šæ–‡æ‰€è¯´çš„å­—ç¬¦å¸¸é‡åŒºï¼› å­—ç¬¦æ•°ç»„æŒ‡é’ˆa2å’Œa3çš„å€¼ä¸åŒä¸”ç›¸å·®4å­—èŠ‚ï¼Œè¿™è¯´æ˜å®ƒä»¬æŒ‡å‘çš„å†…å­˜æ˜¯ä¸ç›¸åŒçš„ï¼Œå®ƒä»¬çš„â€œabcâ€å…¶å®æ˜¯å¯¹å­—ç¬¦å¸¸é‡åŒºä¸­â€œabcâ€çš„ä¸€ä»½æ‹·è´ï¼Œå¹¶ä¸”æ•°æ®æ˜¯å­˜æ”¾åœ¨æ ˆä¸­çš„ï¼Œè‡³äºå®ƒä»¬çš„åœ°å€ç›¸å·®å››ä¸ªå­—èŠ‚ï¼Œæ˜¯å› ä¸ºå­—ç¬¦æ•°ç»„ä¸­åœ¨ç»“å°¾åŠ äº†ä¸€ä¸ªç»“æŸç¬¦â€”â€”â€˜\\0â€™ï¼ˆä¹Ÿç§°ä¸ºNULï¼‰ã€‚ è‡³äºä¹‹å‰è¯´çš„â€œä¸èƒ½ç›´æ¥å°†ä¸€ä¸ªå­—ç¬¦ä¸²å¸¸é‡èµ‹å€¼ç»™å­—ç¬¦æ•°ç»„â€å¯ä»¥è¿™æ ·ç†è§£ï¼šçš„ç¡®æ˜¯ä¸èƒ½ç›´æ¥èµ‹å€¼ï¼Œä½†å¯ä»¥é€šè¿‡å¤åˆ¶ä»¥åå†èµ‹å€¼å‘€ï¼Œå³æŠŠå­—ç¬¦ä¸²æ‹·è´åˆ°æ ˆä¸­ï¼Œç„¶åç»™æ•°ç»„æŒ‡é’ˆèµ‹å€¼ï¼ä»£ç çš„è¯å°±æ˜¯ï¼šchar a[]=â€œabcâ€ã€‚ æˆ‘ä»¬å†æ¥è€ƒè™‘ä¸€ä¸ªé—®é¢˜ï¼šèƒ½ä¸èƒ½ä¿®æ”¹char *aæŒ‡å‘çš„å­—ç¬¦å¸¸é‡åŒºçš„å€¼å‘¢ï¼Ÿ ä»£ç å¦‚ä¸‹ï¼š #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { char * a=\"abc\"; *a = 'b'; printf(\"%c\\n\",*a); return 0; } æˆ‘å°†æŒ‡é’ˆaæ‰€æŒ‡å‘çš„ç¬¬ä¸€ä¸ªå­—ç¬¦â€”â€”â€˜aâ€™ä¿®æ”¹ä¸ºå­—ç¬¦â€˜bâ€™ã€‚ ç»“æœç¨‹åºå´©æºƒäº† è¿™è¯´æ˜å­—ç¬¦å¸¸é‡åŒºçš„æ•°æ®æ˜¯ä¸å¯ä»¥ä¿®æ”¹çš„ï¼ä¸ºä»€ä¹ˆå‘¢ï¼Ÿå› ä¸ºåœ¨ä½ çš„ç¨‹åºä¸­å¯èƒ½æœ‰å¾ˆå¤šä¸ªç±»ä¼¼äºchar *aè¿™æ ·çš„æŒ‡é’ˆå˜é‡åœ¨ä½¿ç”¨åˆ°äº†å­—ç¬¦å¸¸é‡åŒºçš„â€œabcâ€ï¼Œå¦‚æœä½ åœ¨è¿™é‡Œé€šè¿‡æŒ‡é’ˆä¿®æ”¹äº†â€œabcâ€çš„å€¼ï¼Œé‚£ä¹ˆç¨‹åºä¸­ä½¿ç”¨â€œabcâ€çš„å…¶ä»–åœ°æ–¹å°±å˜å¾—ä¸ç¡®å®šäº†ï¼ å…¶å®å¦‚æœä½ ç¿»çœ‹äº†ã€Šcå’ŒæŒ‡é’ˆã€‹ä½ è¿˜ä¼šå‘ç°ï¼Œåœ¨K&amp;R Cæ ‡å‡†ä¸­ï¼Œè¿™é‡Œçš„ä¿®æ”¹æ“ä½œæ˜¯å¯ä»¥çš„ï¼Œå› ä¸ºåœ¨è¯¥æ ‡å‡†ä¸­å­—ç¬¦ä¸²å¸¸é‡æ˜¯åˆ†å¼€å­˜å‚¨çš„ï¼Œè€Œä¸æ˜¯åªå­˜å‚¨åœ¨ä¸€ä¸ªåœ°æ–¹ã€‚ æ€ä¹ˆæ ·ï¼Œæœ‰æ²¡æœ‰æ„Ÿå—åˆ°Cè¯­è¨€æŒ‡é’ˆçš„å±é™©å’Œé­…åŠ›æ‰€åœ¨ï¼Ÿ char a[ ] çš„åº”ç”¨åœºæ™¯: ç¼–è¯‘å™¨é¦–å…ˆåˆ¤æ–­æ•°ç»„çš„å®¹é‡ï¼Œç„¶ååˆ†é…ä¸€ç‰‡å†…å­˜æ¥å­˜å‚¨æ•°ç»„çš„æ¯ä¸ªå…ƒç´ ã€‚å¦‚æœæ˜¯å­—ç¬¦ä¸²èµ‹å€¼æ–¹å¼ï¼Œåˆ™å®¹é‡æ˜¯strlen(å­—ç¬¦ä¸²)+1, èµ‹å€¼æ—¶åœ¨å°¾éƒ¨åŠ  0 char a[ ] å¿…é¡»åœ¨ç”³æ˜çš„åŒæ—¶ç»™å®ƒèµ‹å€¼ï¼Œ å¦åˆ™ç¼–è¯‘å™¨æ— æ³•çŸ¥é“åº”è¯¥åˆ†é…å¤šå¤§çš„å†…å­˜ç»™è¯¥æ•°ç»„ //å¦‚ä¸‹æ“ä½œä¼šå¯¼è‡´ ç¼–è¯‘é”™è¯¯ï¼Œç¼–è¯‘å™¨ä¸èƒ½çŸ¥é“dè¿™ä¸ªæ•°ç»„çš„å¤§å° char d[]; char d[] = a; char a[ ]çš„ä¸¤ç§èµ‹å€¼æ–¹å¼ï¼Œ char a[ ]çš„ä¼˜ç‚¹ char a[] = \"dfdsfsdfas\"; // char a[]çš„ä¼˜ç‚¹ ç›´æ¥æŠŠå­—ç¬¦ä¸²å¤åˆ¶ç»™æŸä¸ªæ•°ç»„ï¼Œé•¿åº¦+1 char a[] = {'a','a','b','c'}; // ä¸ä¼šæœ‰ç»“å°¾ç¬¦\\0 sizeof(a) è¿”å›çš„æ˜¯ aæ•°ç»„å®¹é‡ * sizeof(a[0]) char *s = â€œdfdsfâ€ çš„åº”è¯¥åœºæ™¯: æŠŠsæŒ‡å‘å†…å­˜çš„å­—ç¬¦ä¸²å¸¸é‡åŒºï¼Œä¸èƒ½é€šè¿‡s[index] æ¥ä¿®æ”¹å®ƒ, ä¿®æ”¹åˆ™ä¼šcrash sizeof(s) è¿”å›çš„æ˜¯ sizeof(char *) #include &lt;stdio.h&gt; /*----------------------------------------------------------------------------- * char b[], éµå¾ª â€œå³å·¦åŸåˆ™ â€ æ¥æŸ¥çœ‹å˜é‡çš„ç±»å‹ï¼Œ æ‰€ä»¥å®ƒæ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œå­—ç¬¦æ•°ç»„ * å®ƒæœ‰ä¸¤ç§èµ‹å€¼æ–¹å¼ * 1. char b[] = {'1','2','3'}; * 2. char b[] = \"123\"; ç­‰ä»·ä¸ char b[4] = {'1','2','3', 0}; *------------------------------------------------------------------------------*/ int main(int argc, char *argv[]){ char *a = \"12345\"; // a æ˜¯æŒ‡é’ˆï¼Œ æŒ‡å‘äº†å­—ç¬¦å¸¸é‡åŒºä¸­\"12345\"çš„åœ°å€ char b[] = \"12345\"; // b æ˜¯é¦–å…ˆæ˜¯æ•°ç»„ï¼Œå­˜å‚¨çš„å…ƒç´ æ˜¯{'1', '2','3','4', '5', 0}; char bb[] = {'1', '2','3','4', '5'}; // bb æ˜¯æ²¡æœ‰ç»“å°¾ç¬¦çš„ char bbb[5] = {'1', '2','3','4', '5'}; int c[] = {1,2,3,4,5}; // char a[ ] éœ€è¦åœ¨ç”³æ˜çš„åŒæ—¶ç»™å®ƒèµ‹å€¼ï¼Œ å¦åˆ™ç¼–è¯‘å™¨æ— æ³•çŸ¥é“åº”è¯¥åˆ†é…å¤šå¤§çš„å†…å­˜ç»™è¯¥æ•°ç»„ // ç¼–è¯‘é”™è¯¯ï¼Œç¼–è¯‘å™¨ä¸èƒ½çŸ¥é“dè¿™ä¸ªæ•°ç»„çš„å¤§å° // char d[]; // char d[] = a; // ç¼–è¯‘é”™è¯¯ æŠŠæŒ‡é’ˆèµ‹å€¼æ•°ç»„ // b = a; //sizeof è¿”å›å˜é‡å ç”¨çš„å†…å­˜å¤§å° // æ•°ç»„çš„sizeof è®¡ç®—æ˜¯ sizeof(æˆå‘˜)Ã—æ•°ç›® printf(\"sizeof(a):%ld sizeof(b):%ld sizeof(bb):%ld sizeof(bbb):%ld sizeof(c):%ld\\n\", \\ sizeof(a), sizeof(b), sizeof(bb), sizeof(bbb), sizeof(c)); b[2] = 'g'; printf(\"%s():%d\\n\",__FUNCTION__,__LINE__); a[2] = 'r'; // ä¿®æ”¹å­—ç¬¦å¸¸é‡åŒºä¼šå¯¼è‡´ crash printf(\"%s():%d\\n\",__FUNCTION__,__LINE__); a = \"dfasdfa\"; printf(\"%s\\n\",a); return 0; } è¾“å‡ºå¦‚ä¸‹: sizeof(a):8 sizeof(b):6 sizeof(bb):5 sizeof(bbb):5 sizeof(c):20 main():23 Segmentation fault (core dumped) mmap() ä»¥ä¸‹æ˜¯mmap()å‡½æ•°å®ç°çš„åŸºæœ¬è¿‡ç¨‹ï¼š kernelåœ¨å½“å‰è¿›ç¨‹çš„è™šæ‹Ÿåœ°å€ç©ºé—´ä¸­åˆ†é…æ»¡è¶³æ¡ä»¶çš„è™šæ‹Ÿåœ°å€å— åˆ†é…vm_area_structç»“æ„æ¥ç®¡ç†è¯¥è™šæ‹Ÿåœ°å€å—ï¼Œå¹¶æ’å…¥åˆ°è¿›ç¨‹çš„è™šæ‹Ÿåœ°å€åŒºåŸŸé“¾è¡¨ä¸­ é€šè¿‡æ–‡ä»¶æè¿°ç¬¦ï¼Œæ‰¾åˆ°å¯¹åº”è®¾å¤‡é©±åŠ¨æ³¨å†Œçš„file_operations,å¹¶è°ƒç”¨å®ƒçš„mmapå‡½æ•°ã€‚ åœ¨è¯¥æ–‡ä»¶æè¿°ç¬¦çš„mmapä¸­ï¼Œé€šè¿‡è°ƒç”¨remap_pfn_rangeå‡½æ•°æ¥å»ºç«‹é¡µè¡¨ï¼Œå¹¶è®°å½•æ–‡ä»¶åœ°å€å’Œè™šæ‹Ÿåœ°å€çš„æ˜ å°„å…³ç³»ã€‚ æ­¤æ—¶åªæ˜¯è™šæ‹Ÿåœ°å€ï¼Œå¹¶æ²¡æœ‰å…³è”åˆ°å†…å­˜ã€‚ è¿›ç¨‹åœ¨è¯»å†™è¯¥åœ°å€æ—¶ï¼Œè§¦å‘ç¼ºé¡µï¼Œä»è€Œåˆ†é…å†…å­˜ï¼Œè½½å…¥æ–‡ä»¶æ•°æ®ï¼Œå»ºç«‹è™šæ‹Ÿåœ°å€ä¸å†…å­˜çš„æ˜ å°„ã€‚ fork() çš„è¿›ç¨‹ç©ºé—´ å½“çˆ¶è¿›ç¨‹ä½¿ç”¨ malloc åˆ†é…å†…å­˜åï¼Œè¿™å—å†…å­˜å¯ä»¥è¢«å®ƒ fork çš„å­è¿›ç¨‹è®¿é—®ã€‚è®©æˆ‘è¯¦ç»†è§£é‡Šä¸€ä¸‹ã€‚ å†…å­˜åˆ†é…ï¼š çˆ¶è¿›ç¨‹ä½¿ç”¨ malloc åˆ†é…çš„å†…å­˜ä½äºå †ï¼ˆheapï¼‰ä¸­ã€‚è¿™å—å†…å­˜ç”¨äºå­˜å‚¨åŠ¨æ€åˆ†é…çš„æ•°æ®ï¼Œä¾‹å¦‚å­—ç¬¦ä¸²ã€æ•°ç»„ç­‰ã€‚ fork è¿‡ç¨‹ï¼š å½“çˆ¶è¿›ç¨‹è°ƒç”¨ fork åˆ›å»ºå­è¿›ç¨‹æ—¶ï¼Œæ“ä½œç³»ç»Ÿä¼šå¤åˆ¶çˆ¶è¿›ç¨‹çš„åœ°å€ç©ºé—´ã€‚ è¿™åŒ…æ‹¬ä»£ç æ®µã€æ•°æ®æ®µã€å †å’Œæ ˆã€‚ä½†æ˜¯ï¼Œå®é™…çš„å¤åˆ¶å¹¶ä¸ä¼šç«‹å³å‘ç”Ÿã€‚ Copy-on-Writeï¼ˆå†™æ—¶å¤åˆ¶ï¼‰ï¼š å†™æ—¶å¤åˆ¶æ˜¯ä¸€ç§ä¼˜åŒ–ç­–ç•¥ï¼Œç”¨äºé¿å…ä¸å¿…è¦çš„å†…å­˜å¤åˆ¶ã€‚ åœ¨ fork ä¹‹åï¼Œçˆ¶å­è¿›ç¨‹å…±äº«ç›¸åŒçš„ç‰©ç†å†…å­˜é¡µï¼Œä½†è¿™äº›é¡µè¢«æ ‡è®°ä¸ºåªè¯»ã€‚ å¦‚æœçˆ¶è¿›ç¨‹æˆ–å­è¿›ç¨‹å°è¯•ä¿®æ”¹è¿™äº›å…±äº«çš„å†…å­˜é¡µï¼Œæ“ä½œç³»ç»Ÿä¼šåˆ›å»ºä¸€ä¸ªå‰¯æœ¬ï¼Œä½¿å¾—çˆ¶å­è¿›ç¨‹ä¹‹é—´ä¸ä¼šç›¸äº’å½±å“ã€‚ å› æ­¤ï¼Œçˆ¶è¿›ç¨‹å’Œå­è¿›ç¨‹ä»ç„¶å¯ä»¥è®¿é—® fork ä¹‹å‰åˆ†é…çš„æ‰€æœ‰æ•°æ®ï¼ŒåŒ…æ‹¬ä½¿ç”¨ malloc åˆ†é…çš„å †å†…å­˜ã€‚ æ€»ä¹‹ï¼Œçˆ¶è¿›ç¨‹ä½¿ç”¨ malloc åˆ†é…çš„å†…å­˜å¯ä»¥è¢«å®ƒ fork çš„å­è¿›ç¨‹è®¿é—®ï¼Œä½†åœ¨ä¿®æ”¹æ—¶ä¼šè¿›è¡Œå¤åˆ¶ï¼Œä»¥ä¿æŒæ•°æ®çš„ç‹¬ç«‹æ€§Â¹Â²ã€‚ å¦‚æœæ‚¨è¿˜æœ‰å…¶ä»–é—®é¢˜ï¼Œæ¬¢è¿ç»§ç»­æé—®ï¼ ğŸ˜Š"
  },"/blog/jekyll/2022-04-27-bit.html": {
    "title": "ä½è¿ç®—",
    "keywords": "Jekyll",
    "url": "/blog/jekyll/2022-04-27-bit.html",
    "body": "1.ä½è¿ç®—æ¦‚è¿° ä»ç°ä»£è®¡ç®—æœºä¸­æ‰€æœ‰çš„æ•°æ®äºŒè¿›åˆ¶çš„å½¢å¼å­˜å‚¨åœ¨è®¾å¤‡ä¸­ã€‚å³ 0ã€1 ä¸¤ç§çŠ¶æ€ï¼Œè®¡ç®—æœºå¯¹äºŒè¿›åˆ¶æ•°æ®è¿›è¡Œçš„è¿ç®—(+ã€-ã€*ã€\\/)éƒ½æ˜¯å«ä½è¿ç®—ï¼Œå³å°†ç¬¦å·ä½å…±åŒå‚ä¸è¿ç®—çš„è¿ç®—ã€‚ å£è¯´æ— å‡­ï¼Œä¸¾ä¸€ä¸ªç®€å•çš„ä¾‹å­æ¥çœ‹ä¸‹ CPU æ˜¯å¦‚ä½•è¿›è¡Œè®¡ç®—çš„ï¼Œæ¯”å¦‚è¿™è¡Œä»£ç ï¼š int a = 35; int b = 47; int c = a + b; è®¡ç®—ä¸¤ä¸ªæ•°çš„å’Œï¼Œå› ä¸ºåœ¨è®¡ç®—æœºä¸­éƒ½æ˜¯ä»¥äºŒè¿›åˆ¶æ¥è¿›è¡Œè¿ç®—ï¼Œæ‰€ä»¥ä¸Šé¢æˆ‘ä»¬æ‰€ç»™çš„ int å˜é‡ä¼šåœ¨æœºå™¨å†…éƒ¨å…ˆè½¬æ¢ä¸ºäºŒè¿›åˆ¶åœ¨è¿›è¡Œç›¸åŠ ï¼š 35: 0 0 1 0 0 0 1 1 47: 0 0 1 0 1 1 1 1 â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” 82: 0 1 0 1 0 0 1 0 æ‰€ä»¥ï¼Œç›¸æ¯”åœ¨ä»£ç ä¸­ç›´æ¥ä½¿ç”¨(+ã€-ã€*ã€/ )è¿ç®—ç¬¦ï¼Œåˆç†çš„è¿ç”¨ä½è¿ç®—æ›´èƒ½æ˜¾è‘—æé«˜ä»£ç åœ¨æœºå™¨ä¸Šçš„æ‰§è¡Œæ•ˆç‡ã€‚ 2.ä½è¿ç®—æ¦‚è§ˆ ![[image-20230313173955848.png]] 3.ä¸è¿ç®—ç¬¦&amp; å®šä¹‰ï¼šå‚åŠ è¿ç®—çš„ä¸¤ä¸ªæ•°æ®ï¼ŒæŒ‰äºŒè¿›åˆ¶ä½è¿›è¡Œâ€ä¸â€è¿ç®—ã€‚ 3.1 è¿ç®—è§„åˆ™ï¼š 0&amp;0=0 0&amp;1=0 1&amp;0=0 1&amp;1=1 æ€»ç»“ï¼šä¸¤ä½åŒæ—¶ä¸º1ï¼Œç»“æœæ‰ä¸º1ï¼Œå¦åˆ™ç»“æœä¸º0ã€‚ ä¾‹å¦‚ï¼š3&amp;5 å³ 0000 0011&amp; 0000 0101 = 0000 0001ï¼Œå› æ­¤ 3&amp;5 çš„å€¼å¾—1ã€‚ æ³¨æ„ï¼šè´Ÿæ•°æŒ‰è¡¥ç å½¢å¼å‚åŠ æŒ‰ä½ä¸è¿ç®—ã€‚ 3.2 ä¸è¿ç®—ç¬¦ç”¨é€” 3.2.1æ¸…é›¶ å¦‚æœæƒ³å°†ä¸€ä¸ªå•å…ƒæ¸…é›¶ï¼Œå³ä½¿å…¶å…¨éƒ¨äºŒè¿›åˆ¶ä½ä¸º0ï¼Œåªè¦ä¸ä¸€ä¸ªå„ä½éƒ½ä¸ºé›¶çš„æ•°å€¼ç›¸ä¸ï¼Œç»“æœä¸ºé›¶ã€‚ 3.2.2å–ä¸€ä¸ªæ•°çš„æŒ‡å®šä½ æ¯”å¦‚å–æ•° X=1010 1110 çš„ä½4ä½ï¼Œåªéœ€è¦å¦æ‰¾ä¸€ä¸ªæ•°Yï¼Œä»¤Yçš„ä½4ä½ä¸º1ï¼Œå…¶ä½™ä½ä¸º0ï¼Œå³Y=0000 1111ï¼Œç„¶åå°†Xä¸Yè¿›è¡ŒæŒ‰ä½ä¸è¿ç®—ï¼ˆX&amp;Y=0000 1110ï¼‰å³å¯å¾—åˆ°Xçš„æŒ‡å®šä½ã€‚ 3.2.3åˆ¤æ–­å¥‡å¶ åªè¦æ ¹æ®æœ€æœªä½æ˜¯0è¿˜æ˜¯1æ¥å†³å®šï¼Œä¸º0å°±æ˜¯å¶æ•°ï¼Œä¸º1å°±æ˜¯å¥‡æ•°ã€‚å› æ­¤å¯ä»¥ç”¨if ((a \\&amp; 1) == 0)ä»£æ›¿if (a \\% 2 == 0)æ¥åˆ¤æ–­aæ˜¯ä¸æ˜¯å¶æ•°ã€‚ 4 æˆ–è¿ç®—ç¬¦| å®šä¹‰ï¼šå‚åŠ è¿ç®—çš„ä¸¤ä¸ªå¯¹è±¡ï¼ŒæŒ‰äºŒè¿›åˆ¶ä½è¿›è¡Œâ€æˆ–â€è¿ç®—ã€‚ 4.1è¿ç®—è§„åˆ™ï¼š 0 0=0 0 1=1 1 0=1 1 1=1 æ€»ç»“ï¼šå‚åŠ è¿ç®—çš„ä¸¤ä¸ªå¯¹è±¡åªè¦æœ‰ä¸€ä¸ªä¸º1ï¼Œå…¶å€¼ä¸º1ã€‚ ä¾‹å¦‚ï¼š3 5å³ 0000 0011 0000 0101 = 0000 0111ï¼Œå› æ­¤ï¼Œ3 5çš„å€¼å¾—7ã€‚ã€€ æ³¨æ„ï¼šè´Ÿæ•°æŒ‰è¡¥ç å½¢å¼å‚åŠ æŒ‰ä½æˆ–è¿ç®—ã€‚ 4.2æˆ–è¿ç®—çš„ç”¨é€”ï¼š 4.2.1å¸¸ç”¨æ¥å¯¹ä¸€ä¸ªæ•°æ®çš„æŸäº›ä½è®¾ç½®ä¸º1 æ¯”å¦‚å°†æ•° X=1010 1110 çš„ä½4ä½è®¾ç½®ä¸º1ï¼Œåªéœ€è¦å¦æ‰¾ä¸€ä¸ªæ•°Yï¼Œä»¤Yçš„ä½4ä½ä¸º1ï¼Œå…¶ä½™ä½ä¸º0ï¼Œå³Y=0000 1111ï¼Œç„¶åå°†Xä¸Yè¿›è¡ŒæŒ‰ä½æˆ–è¿ç®—ï¼ˆX Y=1010 1111ï¼‰å³å¯å¾—åˆ°ã€‚ 5å¼‚æˆ–è¿ç®—ç¬¦^ å®šä¹‰ï¼šå‚åŠ è¿ç®—çš„ä¸¤ä¸ªæ•°æ®ï¼ŒæŒ‰äºŒè¿›åˆ¶ä½è¿›è¡Œâ€å¼‚æˆ–â€è¿ç®—ã€‚ 5.1 è¿ç®—è§„åˆ™ï¼š 0^0=0 0^1=1 1^0=1 1^1=0 æ€»ç»“ï¼šå‚åŠ è¿ç®—çš„ä¸¤ä¸ªå¯¹è±¡ï¼Œå¦‚æœä¸¤ä¸ªç›¸åº”ä½ç›¸åŒä¸º0ï¼Œç›¸å¼‚ä¸º1ã€‚ å¼‚æˆ–çš„å‡ æ¡æ€§è´¨: 1ã€äº¤æ¢å¾‹ 2ã€ç»“åˆå¾‹ (a^b)^c == a^(b^c) 3ã€å¯¹äºä»»ä½•æ•°xï¼Œéƒ½æœ‰ x^x=0ï¼Œx^0=x 4ã€è‡ªåæ€§: a^b^b=a^0=a; 5.2 å¼‚æˆ–è¿ç®—çš„ç”¨é€”ï¼š 5.2.1ç¿»è½¬æŒ‡å®šä½ æ¯”å¦‚å°†æ•° X=1010 1110 çš„ä½4ä½è¿›è¡Œç¿»è½¬ï¼Œåªéœ€è¦å¦æ‰¾ä¸€ä¸ªæ•°Yï¼Œä»¤Yçš„ä½4ä½ä¸º1ï¼Œå…¶ä½™ä½ä¸º0ï¼Œå³Y=0000 1111ï¼Œç„¶åå°†Xä¸Yè¿›è¡Œå¼‚æˆ–è¿ç®—ï¼ˆX^Y=1010 0001ï¼‰å³å¯å¾—åˆ°ã€‚ 5.2.2ä¸0ç›¸å¼‚æˆ–å€¼ä¸å˜ ä¾‹å¦‚ï¼š1010 1110 ^ 0000 0000 = 1010 1110 5.2.3äº¤æ¢ä¸¤ä¸ªæ•° voidÂ Swap(intÂ &amp;a,Â intÂ &amp;b){ Â  Â Â ifÂ (aÂ !=Â b){ Â  Â  Â  Â  aÂ ^=Â b; Â  Â  Â  Â  bÂ ^=Â a; Â  Â  Â  Â  aÂ ^=Â b; Â  Â Â } } 6å–åè¿ç®—ç¬¦~ å®šä¹‰ï¼šå‚åŠ è¿ç®—çš„ä¸€ä¸ªæ•°æ®ï¼ŒæŒ‰äºŒè¿›åˆ¶è¿›è¡Œâ€å–åâ€è¿ç®—ã€‚ 6.1 è¿ç®—è§„åˆ™ï¼šã€€ ~1=0 ~0=1 æ€»ç»“ï¼šå¯¹ä¸€ä¸ªäºŒè¿›åˆ¶æ•°æŒ‰ä½å–åï¼Œå³å°†0å˜1ï¼Œ1å˜0ã€‚ 6.2 å–åè¿ç®—ç¬¦çš„ç”¨é€”ï¼š 6.2.1ä½¿ä¸€ä¸ªæ•°çš„æœ€ä½ä½ä¸ºé›¶ ä½¿açš„æœ€ä½ä½ä¸º0ï¼Œå¯ä»¥è¡¨ç¤ºä¸ºï¼ša &amp; ~1ã€‚~1çš„å€¼ä¸º 1111 1111 1111 1110ï¼Œå†æŒ‰â€ä¸â€è¿ç®—ï¼Œæœ€ä½ä½ä¸€å®šä¸º0ã€‚å› ä¸ºâ€ ~â€è¿ç®—ç¬¦çš„ä¼˜å…ˆçº§æ¯”ç®—æœ¯è¿ç®—ç¬¦ã€å…³ç³»è¿ç®—ç¬¦ã€é€»è¾‘è¿ç®—ç¬¦å’Œå…¶ä»–è¿ç®—ç¬¦éƒ½é«˜ã€‚ 7.å·¦ç§»è¿ç®—ç¬¦Â« å®šä¹‰ï¼šå°†ä¸€ä¸ªè¿ç®—å¯¹è±¡çš„å„äºŒè¿›åˆ¶ä½å…¨éƒ¨å·¦ç§»è‹¥å¹²ä½ï¼ˆå·¦è¾¹çš„äºŒè¿›åˆ¶ä½ä¸¢å¼ƒï¼Œå³è¾¹è¡¥0ï¼‰ã€‚ è®¾ a=1010 1110ï¼Œa = aÂ«Â 2 å°†açš„äºŒè¿›åˆ¶ä½å·¦ç§»2ä½ã€å³è¡¥0ï¼Œå³å¾—a=1011 1000ã€‚ 7.1 Â«1 å·¦ç§» 1ä½ ç›¸å½“äºä¹˜2 è‹¥å·¦ç§»æ—¶èˆå¼ƒçš„é«˜ä½ä¸åŒ…å«1ï¼Œåˆ™æ¯å·¦ç§»ä¸€ä½ï¼Œç›¸å½“äºè¯¥æ•°ä¹˜ä»¥2ã€‚ 8å³ç§»è¿ç®—ç¬¦Â» å®šä¹‰ï¼šå°†ä¸€ä¸ªæ•°çš„å„äºŒè¿›åˆ¶ä½å…¨éƒ¨å³ç§»è‹¥å¹²ä½ï¼Œæ­£æ•°å·¦è¡¥0ï¼Œè´Ÿæ•°å·¦è¡¥1ï¼Œå³è¾¹ä¸¢å¼ƒã€‚ ä¾‹å¦‚ï¼ša=aÂ»2 å°†açš„äºŒè¿›åˆ¶ä½å³ç§»2ä½ï¼Œå·¦è¡¥0 æˆ–è€… å·¦è¡¥1å¾—çœ‹è¢«ç§»æ•°æ˜¯æ­£è¿˜æ˜¯è´Ÿã€‚ 8.1Â Â»1 å³ç§»ä¸€ä½ç›¸å½“äºé™¤2 æ“ä½œæ•°æ¯å³ç§»ä¸€ä½ï¼Œç›¸å½“äºè¯¥æ•°é™¤ä»¥2ã€‚ 9å¤åˆèµ‹å€¼è¿ç®—ç¬¦ ä½è¿ç®—ç¬¦ä¸èµ‹å€¼è¿ç®—ç¬¦ç»“åˆï¼Œç»„æˆæ–°çš„å¤åˆèµ‹å€¼è¿ç®—ç¬¦ï¼Œå®ƒä»¬æ˜¯ï¼š &amp;= ä¾‹ï¼ša&amp;=b ç›¸å½“äº a=a&amp;b = ä¾‹ï¼ša =b ç›¸å½“äº a=a b &gt;&gt;= ä¾‹ï¼šaÂ»=b ç›¸å½“äº a=aÂ»b Â«= ä¾‹ï¼šaÂ«=b ç›¸å½“äº a=aÂ«Â b ^= ä¾‹ï¼ša^=b ç›¸å½“äº a=a^b è¿ç®—è§„åˆ™ï¼šå’Œå‰é¢è®²çš„å¤åˆèµ‹å€¼è¿ç®—ç¬¦çš„è¿ç®—è§„åˆ™ç›¸ä¼¼ã€‚ ä¸åŒé•¿åº¦çš„æ•°æ®è¿›è¡Œä½è¿ç®—ï¼šå¦‚æœä¸¤ä¸ªä¸åŒé•¿åº¦çš„æ•°æ®è¿›è¡Œä½è¿ç®—æ—¶ï¼Œç³»ç»Ÿä¼šå°†äºŒè€…æŒ‰å³ç«¯å¯¹é½ï¼Œç„¶åè¿›è¡Œä½è¿ç®—ã€‚ ä»¥â€ä¸è¿ç®—â€ä¸ºä¾‹è¯´æ˜å¦‚ä¸‹ï¼šæˆ‘ä»¬çŸ¥é“åœ¨Cè¯­è¨€ä¸­longå‹å 4ä¸ªå­—èŠ‚ï¼Œintå‹å 2ä¸ªå­—èŠ‚ï¼Œå¦‚æœä¸€ä¸ªlongå‹æ•°æ®ä¸ä¸€ä¸ªintå‹æ•°æ®è¿›è¡Œâ€ä¸è¿ç®—â€ï¼Œå³ç«¯å¯¹é½åï¼Œå·¦è¾¹ä¸è¶³çš„ä½ä¾ä¸‹é¢ä¸‰ç§æƒ…å†µè¡¥è¶³ï¼Œ 1ï¼‰å¦‚æœæ•´å‹æ•°æ®ä¸ºæ­£æ•°ï¼Œå·¦è¾¹è¡¥16ä¸ª0ã€‚ 2ï¼‰å¦‚æœæ•´å‹æ•°æ®ä¸ºè´Ÿæ•°ï¼Œå·¦è¾¹è¡¥16ä¸ª1ã€‚ 3ï¼‰å¦‚æœæ•´å½¢æ•°æ®ä¸ºæ— ç¬¦å·æ•°ï¼Œå·¦è¾¹ä¹Ÿè¡¥16ä¸ª0ã€‚ å¦‚ï¼šlong a=123ï¼›int b=1ï¼›è®¡ç®—a&amp; bã€‚ å¦‚ï¼šlong a=123ï¼›int b=-1ï¼›è®¡ç®—a&amp; bã€‚ å¦‚ï¼šlong a=123ï¼›unsigned intb=1ï¼›è®¡ç®—a &amp; bã€‚"
  },"/blog/jekyll/2021-04-27-ffmpeg.html": {
    "title": "ffmpegå‘½ä»¤",
    "keywords": "Jekyll",
    "url": "/blog/jekyll/2021-04-27-ffmpeg.html",
    "body": "01. è§†é¢‘åˆ†å‰² ffmpeg -ss 00:00:00 -i input.mp4 -c copy -t 60 output.mp4 -ss è¡¨ç¤ºè§†é¢‘åˆ†å‰²çš„èµ·å§‹æ—¶é—´ï¼Œ-t è¡¨ç¤ºåˆ†å‰²æ—¶é•¿ï¼ŒåŒæ—¶ä¹Ÿå¯ä»¥ç”¨ 00:01:00è¡¨ç¤º æ³¨æ„-ss è¦æ”¾åœ¨ -i ä¹‹å‰ 02. è§†é¢‘åŒºåŸŸè£å‰ªï¼š ffmpeg -i 3.mkv -filter_complex crop=1024:50:0:550 -y 4.mkv 03. è§†é¢‘é¢„è§ˆ ffplay 3.mkv -vf crop=1024:50:0:550 04. è§†é¢‘æ”¾å¤§,ç¼©å° ffmpeg -i 2.mp4 -vf \"scale=1280:64\" 4.mp4 scale =w:h è¡¨ç¤ºæ”¾å¤§åçš„å¤§å° 05. åˆ—å‡ºæ‰€æœ‰format list all pix format ffmpeg -pix_fmts 06. å›¾ç‰‡è½¬æ¢ ffmpeg -itemp.jpg-s1024x680-pix_fmtyuvj420p9.yuv ffmpeg.exe -i agf-dog-1280x960.jpg -vf scale=1920:1080 agf-dog-1920x1080.jpg 07. è§†é¢‘formatè½¬æ¢ YUV -&gt; RGB ffmpeg -s 360x270 -pix_fmt yuv420p -i 2_test_360x270_50.yuv -pix_fmt rgb24 aaaa.rgb ffmpeg -s 640x480 -pix_fmt nv12 -i 640x480_1.jpg -vf scale=640:480,setsar=1:1 640x480_1_nv12.yuv -hide_banner 08. è§†é¢‘å åŠ  ffmpeg -i input1 -i input2 -filter_complex overlay=x:youtput 09. è§†é¢‘æ—‹è½¬ mp4å‘å·¦æ—‹è½¬90åº¦ ffmpeg -i input.mp4 -metadata:s:v rotate=\"90\" -codec copy outut.mp4 mp4å‘å³æ—‹è½¬90åº¦ ffmpeg -i input.mp4 -metadata:s:v rotate=\"-90\" -codec copy outut.mp4 10. è§†é¢‘é•œåƒ mp4å·¦å³é•œåƒç¿»è½¬ ffmpeg -i input.mp4 -vf \"hflip\" outut.mp4 mp4ä¸Šä¸‹é•œåƒç¿»è½¬ ffmpeg -i input.mp4 -vf \"vflip\" outut.mp4 11. mp4è½¬raw data ffmpeg -i video.mp4 -c:v rawvideo -pix_fmt yuv420p out.yuv ffmpeg -i input.mp4 -vf \"format=nv12\" -c:v rawvideo -an output.nv12 ffmpeg -i input.mp4 -pix_fmt nv21 -f rawvideo output.nv21 12. å›¾ç‰‡æ—‹è½¬ å›¾ç‰‡å‘å³æ—‹è½¬90åº¦ ffmpeg -i input.png -vf rotate='90*PI/180' -y rotate60.png å›¾ç‰‡å‘å³æ—‹è½¬90åº¦ ffmpeg -i input.png -vf rotate='-90*PI/180' -y rotate_90.png å›¾ç‰‡åƒå·¦æ—‹è½¬90åº¦ ffmpeg -i input.png -vf transpose=2 -y transpose2.png å›¾ç‰‡åƒå³æ—‹è½¬90åº¦ ffmpeg -i input.png -vf transpose=1 -y transpose2.png é€†æ—¶é’ˆ(å‘å·¦)æ—‹è½¬90Â°ï¼Œç„¶åå‚ç›´ï¼ˆä¸Šä¸‹ï¼‰ç¿»è½¬ ffmpeg -i input.png -vf transpose=0 -y transpose0.png 13. å›¾ç‰‡é•œåƒ å›¾ç‰‡å·¦å³é•œåƒç¿»è½¬ ffmpeg -i input.png -vf hflip -y hflip.png å›¾ç‰‡ä¸Šä¸‹é•œåƒç¿»è½¬ ffmpeg -i input.png -vf vflip -y vflip.png yuvæ•°æ®å·¦å³é•œåƒç¿»è½¬ ffmpeg -s 1920x1080 -pix_fmt nv12 -i nv12_1.yuv -vf hflip -y hflip_nv12.yuv æ’­æ”¾å·¦å³ç¿»è½¬åçš„yuvæ•°æ® ffplay -video_size 1920x1080 -pixel_format nv12 hflip_nv12.yuv 14. éŸ³é¢‘éŸ³é‡è°ƒèŠ‚å¤§å° éŸ³é‡ç¿»å€ï¼Œå†™åœ¨æ»¤é•œé‡Œ ffmpeg -i input.wav -af volume=2 -y output.wav éŸ³é‡ç¿»å€ï¼Œä¸å†™åœ¨æ»¤é•œä¸­ ffmpeg -i input.wav -vol 2000 -y output.wav 15. è°ƒèŠ‚æ’­æ”¾é€Ÿåº¦ ffmpeg -i test1.mp4 -vf \"setpts=0.25*PTS\" test2.mp4 å››å€æ…¢é€Ÿï¼š ffmpeg -i test1.mp4 -vf \"setpts=4*PTS\" test2.mp4"
  },"/blog/jekyll/2020-10-02-FuncTrace.html": {
    "title": "Function Trace",
    "keywords": "Jekyll",
    "url": "/blog/jekyll/2020-10-02-FuncTrace.html",
    "body": "å‡½æ•°è·Ÿè¸ª __cyg_profile_func_enter å’Œ __cyg_profile_func_exit æ˜¯ç”¨äºå‡½æ•°è°ƒç”¨è¿½è¸ªçš„ç‰¹æ®Šå‡½æ•°ã€‚å½“ä½ ä½¿ç”¨ -finstrument-functionsç¼–è¯‘é€‰é¡¹æ—¶ï¼Œç¼–è¯‘å™¨ä¼šåœ¨æ¯ä¸ªå‡½æ•°çš„å¼€å§‹å’Œç»“æŸå¤„æ’å…¥è¿™ä¸¤ä¸ªå‡½æ•°. è¿™æ ·ï¼Œä½ å¯ä»¥å®ç°å‡½æ•°è°ƒç”¨çš„æ£€æµ‹å’Œåˆ†æã€‚ è¿™é‡Œæ˜¯ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼Œé¦–å…ˆæˆ‘ä»¬æœ‰ä¸€ä¸ªç”¨äºè·Ÿè¸ªå‡½æ•°çš„ func_trace.c æ–‡ä»¶ï¼š #include &lt;stdio.h&gt; static FILE *fp_trace; void __attribute__((constructor)) traceBegin(void) { fp_trace = fopen(\"func_trace.out\", \"w\"); } void __attribute__((destructor)) traceEnd(void) { if (fp_trace != NULL) { fclose(fp_trace); } } void __cyg_profile_func_enter(void *func, void *caller) { if (fp_trace != NULL) { fprintf(fp_trace, \"entry %p %p\\n\", func, caller); } } void __cyg_profile_func_exit(void *func, void *caller) { if (fp_trace != NULL) { fprintf(fp_trace, \"exit %p %p\\n\", func, caller); } } ç„¶åï¼Œæˆ‘ä»¬ç¼–å†™ä¸€ä¸ªç®€å•çš„æµ‹è¯•ä»£ç  main.cï¼š #include &lt;stdio.h&gt; int foo(void) { return 2; } int bar(void) { zoo(); return 1; } void zoo(void) { foo(); } int main(int argc, char **argv) { bar(); } æ¥ä¸‹æ¥ï¼Œå°† main.c ä¸ func_trace.o ä¸€èµ·ç¼–è¯‘ï¼Œå¹¶åŠ ä¸Š -finstrument-functions é€‰é¡¹ï¼š gcc main.c func_trace.o -finstrument-functions è¿è¡Œ ./a.outï¼Œå°±ä¼šäº§ç”Ÿ func_trace.out æ–‡ä»¶ï¼Œå…¶ä¸­è®°å½•äº†å‡½æ•°è°ƒç”¨çš„ä¿¡æ¯ã€‚ä½ å¯ä»¥ä½¿ç”¨ addr2line å‘½ä»¤æ¥æŸ¥çœ‹å‡½æ•°åï¼š addr2line -f -e ./a.out $ADDRESS è¿™æ ·ï¼Œä½ å°±å¯ä»¥å¾—åˆ°å‡½æ•°è°ƒç”¨å…³ç³»ã€‚å¦‚æœæƒ³è¿›ä¸€æ­¥å¤„ç†è¿™äº›è·Ÿè¸ªæ•°æ®ï¼Œå¯ä»¥ä½¿ç”¨å·¥å…·å¦‚ graphviz æ¥åˆ›å»ºå¯è§†åŒ–çš„è°ƒç”¨å…³ç³»å›¾ã€‚ è‡ªåŠ¨åŒ–å•å…ƒæµ‹è¯•"
  },"/blog/jekyll/2020-06-22-misc.html": {
    "title": "Kernel Misc",
    "keywords": "Jekyll",
    "url": "/blog/jekyll/2020-06-22-misc.html",
    "body": "kref kref_init æ˜¯ä¸€ä¸ªç”¨äºåˆå§‹åŒ–å†…æ ¸å¯¹è±¡å¼•ç”¨è®¡æ•°å™¨ï¼ˆkrefsï¼‰çš„å‡½æ•°ã€‚å®ƒå…è®¸ä½ ä¸ºä½ çš„å¯¹è±¡æ·»åŠ å¼•ç”¨è®¡æ•°ï¼Œç¡®ä¿åœ¨å¤šä¸ªåœ°æ–¹ä½¿ç”¨å’Œä¼ é€’å¯¹è±¡æ—¶ï¼Œä»£ç çš„æ­£ç¡®æ€§ã€‚ä»¥ä¸‹æ˜¯å…³äº kref_init çš„ä¸€äº›é‡è¦ä¿¡æ¯ï¼š åˆå§‹åŒ–ï¼š åœ¨åˆ†é…å†…å­˜å¹¶åˆ›å»ºå¯¹è±¡åï¼Œä½ éœ€è¦è°ƒç”¨ kref_init æ¥åˆå§‹åŒ–å¼•ç”¨è®¡æ•°å™¨ã€‚ä¾‹å¦‚ï¼š struct my_data *data; data = kmalloc(sizeof(*data), GFP_KERNEL); if (!data) return -ENOMEM; kref_init(&amp;data-&gt;refcount); è¿™å°†åœ¨ kref ä¸­çš„ refcount è®¾ç½®ä¸º 1ã€‚ ä½¿ç”¨è§„åˆ™ï¼š åœ¨å¯¹æŒ‡é’ˆè¿›è¡Œéä¸´æ—¶æ‹·è´ï¼ˆå°¤å…¶æ˜¯ä¼ é€’ç»™å¦ä¸€ä¸ªæ‰§è¡Œçº¿ç¨‹ï¼‰ä¹‹å‰ï¼Œå¿…é¡»ä½¿ç”¨ kref_get å¢åŠ å¼•ç”¨è®¡æ•°ã€‚ åœ¨å®Œæˆå¯¹æŒ‡é’ˆçš„å¤„ç†åï¼Œå¿…é¡»è°ƒç”¨ kref_putã€‚å¦‚æœè¿™æ˜¯å¯¹æŒ‡é’ˆçš„æœ€åä¸€æ¬¡å¼•ç”¨ï¼Œé‡Šæ”¾ç¨‹åºå°†è¢«è°ƒç”¨ã€‚ ç¤ºä¾‹ï¼š void data_release(struct kref *ref) { struct my_data *data = container_of(ref, struct my_data, refcount); kfree(data); } void more_data_handling(void *cb_data) { struct my_data *data = cb_data; // å¤„ç† data kref_put(&amp;data-&gt;refcount, data_release); } int my_data_handler(void) { int rv = 0; struct my_data *data; data = kmalloc(sizeof(*data), GFP_KERNEL); if (!data) return -ENOMEM; kref_init(&amp;data-&gt;refcount); kref_get(&amp;data-&gt;refcount); // åˆ›å»ºçº¿ç¨‹å¤„ç†æ•°æ® // ... kref_put(&amp;data-&gt;refcount, data_release); return rv; } åœ¨ä¸Šè¿°ç¤ºä¾‹ä¸­ï¼Œä¸¤ä¸ªçº¿ç¨‹å¤„ç†æ•°æ®çš„é¡ºåºå¹¶ä¸é‡è¦ï¼Œkref_put ä¼šåœ¨æ•°æ®ä¸å†è¢«å¼•ç”¨æ—¶é‡Šæ”¾å®ƒã€‚ è¯·æ³¨æ„ï¼Œéµå¾ªè¿™äº›è§„åˆ™å¯ä»¥ç¡®ä¿æ­£ç¡®ç®¡ç†å†…æ ¸å¯¹è±¡çš„å¼•ç”¨è®¡æ•°ï¼Œé¿å…å†…å­˜æ³„æ¼å’Œæ‚¬æŒ‚æŒ‡é’ˆã€‚ IDR(ID Range) IDR æ˜¯ä¸€ç§ç”¨äºç®¡ç†è¿ç»­æ•´æ•°èŒƒå›´çš„æ•°æ®ç»“æ„ï¼Œé€šå¸¸ç”¨äºå†…æ ¸ä¸­éœ€è¦ä¸ºå¯¹è±¡åˆ†é…å”¯ä¸€æ ‡è¯†ç¬¦çš„åœºæ™¯ã€‚ idr_alloc å‡½æ•°ç”¨äºåœ¨ Linux å†…æ ¸ä¸­åˆ†é… IDRï¼ˆID Rangeï¼‰å¯¹è±¡ä¸­çš„æœªä½¿ç”¨çš„ IDã€‚ ä»¥ä¸‹æ˜¯ idr_alloc å‡½æ•°çš„ç”¨æ³•ï¼š é¦–å…ˆï¼Œæ‚¨éœ€è¦åˆå§‹åŒ–ä¸€ä¸ª IDRã€‚å¯¹äºé™æ€åˆ†é…çš„ IDRï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ DEFINE_IDR() å®ï¼›å¯¹äºåŠ¨æ€åˆ†é…çš„ IDRï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ idr_init() å‡½æ•°ã€‚ è°ƒç”¨ idr_alloc() æ¥åˆ†é…ä¸€ä¸ªæœªä½¿ç”¨çš„ IDã€‚ ä½¿ç”¨ idr_find() æŸ¥è¯¢ä¸è¯¥ ID ç›¸å…³çš„æŒ‡é’ˆã€‚ ä½¿ç”¨ idr_remove() é‡Šæ”¾è¯¥ IDã€‚ å¦‚æœéœ€è¦æ›´æ”¹ä¸æŸä¸ª ID ç›¸å…³è”çš„æŒ‡é’ˆï¼Œæ‚¨å¯ä»¥è°ƒç”¨ idr_replace()ã€‚è¿™é€šå¸¸ç”¨äºä¿ç•™ IDï¼Œé€šè¿‡å°† NULL æŒ‡é’ˆä¼ é€’ç»™åˆ†é…å‡½æ•°ï¼Œç„¶åä½¿ç”¨ä¿ç•™çš„ ID åˆå§‹åŒ–å¯¹è±¡ï¼Œæœ€åå°†åˆå§‹åŒ–çš„å¯¹è±¡æ’å…¥ IDRã€‚ åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæ‰€æœ‰ç”¨æˆ·éƒ½æ»¡è¶³äº† UINT_MAX çš„é™åˆ¶ï¼Œå› æ­¤ä»–ä»¬ä½¿ç”¨ idr_alloc_u32()ã€‚ å¦‚æœéœ€è¦æŒ‰é¡ºåºåˆ†é… IDï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ idr_alloc_cyclic()ã€‚è¯·æ³¨æ„ï¼Œå¤„ç†è¾ƒå¤§æ•°é‡çš„ ID æ—¶ï¼ŒIDR çš„æ•ˆç‡ä¼šé™ä½ï¼Œå› æ­¤ä½¿ç”¨è¿™ä¸ªå‡½æ•°ä¼šæœ‰ä¸€äº›ä»£ä»·ã€‚ å½“æ‚¨ä½¿ç”¨å®Œ IDR åï¼Œå¯ä»¥è°ƒç”¨ idr_destroy() æ¥é‡Šæ”¾ IDR å ç”¨çš„å†…å­˜ã€‚è¿™ä¸ä¼šé‡Šæ”¾ IDR æŒ‡å‘çš„å¯¹è±¡ï¼›å¦‚æœæ‚¨æƒ³è¿™æ ·åšï¼Œè¯·ä½¿ç”¨å…¶ä¸­ä¸€ä¸ªè¿­ä»£å™¨æ¥æ‰§è¡Œæ­¤æ“ä½œã€‚ æ‚¨å¯ä»¥ä½¿ç”¨ idr_is_empty() æ¥æŸ¥çœ‹å½“å‰æ˜¯å¦åˆ†é…äº†ä»»ä½• IDã€‚ å¦‚æœåœ¨ä» IDR åˆ†é…ä¸€ä¸ªæ–° ID æ—¶éœ€è¦å¸¦é”ï¼Œæ‚¨å¯èƒ½éœ€è¦ä¼ é€’ä¸€ç»„é™åˆ¶æ€§çš„ GFP æ ‡å¿—ï¼Œä½†è¿™å¯èƒ½å¯¼è‡´ IDR æ— æ³•åˆ†é…å†…å­˜ã€‚ä¸ºäº†è§£å†³è¯¥é—®é¢˜ï¼Œæ‚¨å¯ä»¥åœ¨è·å–é”ä¹‹å‰è°ƒç”¨ idr_preload()ï¼Œç„¶ååœ¨åˆ†é…ä¹‹åè°ƒç”¨ idr_preload_end()ã€‚ #include &lt;linux/idr.h&gt; int main(void) { struct idr my_idr; int id1, id2; void *ptr1, *ptr2; // Initialize the IDR idr_init(&amp;my_idr); // Allocate two unused IDs id1 = idr_alloc(&amp;my_idr, \"sample1\", 0, 0, GFP_KERNEL); id2 = idr_alloc(&amp;my_idr, \"sample2\", 0, 0, GFP_KERNEL); // Associate pointers with the IDs ptr1 = (void *)0xdeadbeef; ptr2 = (void *)0xcafebabe; idr_replace(&amp;my_idr, ptr1, id1); idr_replace(&amp;my_idr, ptr2, id2); // Look up pointers by ID ptr1 = idr_find(&amp;my_idr, id1); ptr2 = idr_find(&amp;my_idr, id2); // Free the IDs idr_remove(&amp;my_idr, id1); idr_remove(&amp;my_idr, id2); // Destroy the IDR idr_destroy(&amp;my_idr); return 0; } éä¸€è‡´æ€§å†…å­˜ å’Œä¸€è‡´æ€§ dma_alloc_noncoherent å®ƒæ˜¯Linuxå†…æ ¸ä¸­çš„ä¸€ä¸ªDMAå†…å­˜åˆ†é…å‡½æ•°ï¼Œç”¨äºåˆ†é…ä¸€æ®µç‰©ç†å†…å­˜ï¼Œä½¿å…¶å¯ä»¥è¢«DMAç¡¬ä»¶è®¿é—®12. è¿™ä¸ªå‡½æ•°çš„ä½œç”¨æ˜¯åœ¨éä¸€è‡´æ€§å†…å­˜ï¼ˆnon-coherent memoryï¼‰ä¸Šåˆ†é…ä¸€å—åŒºåŸŸï¼Œä»¥ä¾¿è®¾å¤‡å¯ä»¥ä½¿ç”¨å®ƒä½œä¸ºDMAçš„æºæˆ–ç›®æ ‡åœ°å€ã€‚è®©æˆ‘è¯¦ç»†è§£é‡Šä¸€ä¸‹è¿™ä¸ªå‡½æ•°çš„ç”¨é€”å’Œå‚æ•°ã€‚ dma_alloc_noncoherentå‡½æ•°çš„åŸå‹å¦‚ä¸‹ï¼š void *dma_alloc_noncoherent(struct device *dev, size_t size, dma_addr_t *dma_handle, gfp_t flag); dev: æŒ‡å‘è®¾å¤‡ç»“æ„çš„æŒ‡é’ˆï¼Œè¡¨ç¤ºè¦ä¸ºå“ªä¸ªè®¾å¤‡åˆ†é…å†…å­˜ã€‚ size: è¦åˆ†é…çš„å†…å­˜å¤§å°ï¼ˆä»¥å­—èŠ‚ä¸ºå•ä½ï¼‰ã€‚ dma_handle: ç”¨äºè¿”å›DMAåœ°å€çš„æŒ‡é’ˆã€‚è¿™ä¸ªåœ°å€å¯ä»¥è½¬æ¢ä¸ºä¸æ€»çº¿å®½åº¦ç›¸åŒçš„æ— ç¬¦å·æ•´æ•°ï¼Œå¹¶ä¼ é€’ç»™è®¾å¤‡ä½œä¸ºåˆ†é…åŒºåŸŸçš„DMAåœ°å€åŸºå€ã€‚ flag: ç”¨äºæŒ‡å®šå†…å­˜åˆ†é…çš„GFP_æ ‡å¿—ï¼ˆç±»ä¼¼äºkmalloc()ä¸­çš„æ ‡å¿—ï¼‰ã€‚ä¾‹å¦‚ï¼Œå¯ä»¥ä½¿ç”¨GFP_KERNELæ¥åˆ†é…æ™®é€šå†…æ ¸å†…å­˜ã€‚ éä¸€è‡´æ€§å†…å­˜æ˜¯ä¸€ç§ç‰¹æ®Šç±»å‹çš„å†…å­˜ï¼Œå†™å…¥å®ƒçš„æ•°æ®å¯ä»¥ç«‹å³è¢«å¤„ç†å™¨æˆ–è®¾å¤‡è¯»å–ï¼Œè€Œæ— éœ€è€ƒè™‘ç¼“å­˜æ•ˆåº”ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒCPUä¸èƒ½ç›´æ¥å¼•ç”¨dma_addr_tï¼Œå› ä¸ºç‰©ç†åœ°å€ç©ºé—´å’ŒDMAåœ°å€ç©ºé—´ä¹‹é—´å¯èƒ½å­˜åœ¨è½¬æ¢ã€‚ ä½¿ç”¨dma_alloc_noncoherentåˆ†é…çš„å†…å­˜åŒºåŸŸä¸ä¿è¯ä¸€è‡´æ€§ï¼Œå› æ­¤åœ¨ä½¿ç”¨ä¹‹å‰ï¼Œå¯èƒ½éœ€è¦æ‰‹åŠ¨åˆ·æ–°å¤„ç†å™¨çš„å†™ç¼“å†²åŒºï¼Œä»¥ç¡®ä¿è®¾å¤‡å¯ä»¥æ­£ç¡®è¯»å–è¯¥å†…å­˜ã€‚ é‡Šæ”¾ç”±dma_alloc_noncoherentåˆ†é…çš„å†…å­˜æ—¶ï¼Œåº”ä½¿ç”¨dma_free_noncoherentå‡½æ•°ï¼š void dma_free_noncoherent(struct device *dev, size_t size, void *cpu_addr, dma_addr_t dma_handle); devã€sizeå’Œdma_handleå‚æ•°å¿…é¡»ä¸ä¼ é€’ç»™dma_alloc_noncoherentçš„ç›¸åŒã€‚ cpu_addræ˜¯ç”±dma_alloc_noncoherentè¿”å›çš„è™šæ‹Ÿåœ°å€ã€‚ è¯·æ³¨æ„ï¼Œä¸å…¶ä»–å†…å­˜åˆ†é…å‡½æ•°ä¸åŒï¼Œè¿™äº›å‡½æ•°åªèƒ½åœ¨å¯ç”¨IRQçš„æƒ…å†µä¸‹è°ƒç”¨ã€‚ å¦‚æœä½ çš„é©±åŠ¨ç¨‹åºéœ€è¦å¤§é‡è¾ƒå°çš„DMAä¸€è‡´æ€§å†…å­˜åŒºåŸŸï¼Œä½ å¯ä»¥ä½¿ç”¨DMAæ± ï¼ˆdma_poolï¼‰æ¥åˆ†é…å’Œç®¡ç†è¿™äº›åŒºåŸŸï¼Œè€Œä¸æ˜¯ä½¿ç”¨dma_alloc_coherent()ã€‚DMAæ± ç±»ä¼¼äºkmem_cacheï¼Œä½†å®ƒä½¿ç”¨dma_alloc_coherent()è€Œä¸æ˜¯__get_free_pages() dma_alloc_wc è¿™ä¸ªå‡½æ•°å…è®¸é©±åŠ¨ç¨‹åºç”³è¯·å¸¦ç¼“å­˜ä¸€è‡´æ€§çš„DMAå†…å­˜ã€‚ç¼“å­˜ä¸€è‡´æ€§æ˜¯æŒ‡ç¡®ä¿CPUå’ŒDMAè®¾å¤‡ä¹‹é—´çš„æ•°æ®ä¸€è‡´æ€§ï¼Œä»¥é¿å…æ•°æ®ä¸ä¸€è‡´çš„é—®é¢˜ã€‚ä½¿ç”¨dma_alloc_wcåˆ†é…çš„å†…å­˜åŒºåŸŸæ—¨åœ¨åœ¨CPUå’ŒDMAè®¾å¤‡ä¹‹é—´ä¿æŒä¸€è‡´ï¼Œä»¥ä¾¿æ•°æ®æ­£ç¡®ä¼ è¾“ã€‚ é‡Šæ”¾ç”±dma_alloc_wcåˆ†é…çš„å†…å­˜æ—¶ï¼Œåº”ä½¿ç”¨dma_free_wcå‡½æ•°ï¼š void dma_free_wc(struct device *dev, size_t size, void *cpu_addr, dma_addr_t dma_handle); devã€sizeå’Œdma_handleå‚æ•°å¿…é¡»ä¸ä¼ é€’ç»™dma_alloc_wcçš„ç›¸åŒã€‚ cpu_addræ˜¯ç”±dma_alloc_wcè¿”å›çš„è™šæ‹Ÿåœ°å€ã€‚ adf å®šæ—¶å™¨ timer_setup å®ƒæ˜¯Linuxå†…æ ¸ä¸­ç”¨äºåˆå§‹åŒ–å®šæ—¶å™¨çš„å‡½æ•°ã€‚å®ƒèƒ½å¤Ÿæ–¹ä¾¿åœ°è®¾ç½®å’Œåˆå§‹åŒ–ä¸€ä¸ªè®¡æ—¶å™¨ï¼Œå¹¶é€šè¿‡è®¾ç½®å‚æ•°æ¥çµæ´»åœ°æ§åˆ¶è®¡æ—¶å™¨çš„è¡Œä¸º1. åˆç†ä½¿ç”¨timer_setupå‡½æ•°å¯ä»¥è®©æˆ‘ä»¬æ›´å¥½åœ°å¤„ç†æ—¶é—´ç›¸å…³çš„ä»»åŠ¡ï¼Œæé«˜æ“ä½œç³»ç»Ÿçš„æ€§èƒ½å’Œå¯é æ€§ã€‚ åœ¨Linuxå†…æ ¸ä¸­ï¼Œå®šæ—¶å™¨é€šå¸¸ä½¿ç”¨timer_listç»“æ„ä½“æ¥è¡¨ç¤ºã€‚ä¸‹é¢æ˜¯timer_listç»“æ„ä½“çš„ä¸€äº›å…³é”®å­—æ®µï¼š entry: å®šæ—¶å™¨åˆ—è¡¨å…ƒç´ ï¼Œç”¨äºå°†å®šæ—¶å™¨æŒ‚è½½åœ¨å†…æ ¸å®šæ—¶å™¨é“¾è¡¨ä¸Šã€‚ expires: å®šæ—¶å™¨å®šæ—¶æ—¶é—´ã€‚ function: å®šæ—¶å™¨å›è°ƒå‡½æ•°ï¼Œå®šæ—¶å™¨æ—¶é—´åˆ°æ—¶æ‰§è¡Œè¯¥å‡½æ•°ã€‚ flags: æ ‡å¿—ä½ï¼Œç”¨äºè®¾ç½®å®šæ—¶å™¨çš„å±æ€§ã€‚ åœ¨æ—§ç‰ˆæœ¬çš„å†…æ ¸ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨init_timerå‡½æ•°æ¥åˆå§‹åŒ–å®šæ—¶å™¨ã€‚è€Œåœ¨æ–°ç‰ˆæœ¬ä¸­ï¼Œè¿™ä¸ªå‡½æ•°å˜æˆäº†timer_setupå‡½æ•°ã€‚ä¸‹é¢æ˜¯timer_setupå‡½æ•°çš„å®šä¹‰ï¼š void timer_setup(struct timer_list *timer, void (*callback)(struct timer_list *), unsigned int flags); ä½¿ç”¨timer_setupå‡½æ•°æ—¶ï¼Œæˆ‘ä»¬éœ€è¦ä¼ å…¥ä»¥ä¸‹å‚æ•°ï¼š timer: è¦åˆå§‹åŒ–çš„å®šæ—¶å™¨ã€‚ callback: å®šæ—¶å™¨çš„å›è°ƒå‡½æ•°ï¼Œæ­¤å‡½æ•°çš„å½¢å‚æ˜¯å½“å‰å®šæ—¶å™¨çš„å˜é‡ã€‚ flags: æ ‡å¿—ä½ï¼Œå¯ä»¥è®¾ç½®å®šæ—¶å™¨çš„å±æ€§ã€‚ #include &lt;linux/kernel.h&gt; #include &lt;linux/module.h&gt; #include &lt;linux/timer.h&gt; MODULE_LICENSE(\"GPL\"); static struct timer_list my_timer; void my_timer_callback(struct timer_list *timer) { printk(KERN_ALERT \"This line is printed after 5 seconds.\\n\"); } static int init_module_with_timer(void) { printk(KERN_ALERT \"Initializing a module with timer.\\n\"); // Setup the timer for initial use timer_setup(&amp;my_timer, my_timer_callback, 0); // Set the timer interval to 5000 milliseconds (5 seconds) mod_timer(&amp;my_timer, jiffies + msecs_to_jiffies(5000)); return 0; } static void exit_module_with_timer(void) { printk(KERN_ALERT \"Goodbye, cruel world!\\n\"); del_timer(&amp;my_timer); } module_init(init_module_with_timer); module_exit(exit_module_with_timer); é«˜ç²¾åº¦å®šæ—¶å™¨ hrtimer_init æ˜¯ Linux å†…æ ¸ä¸­ä¸é«˜ç²¾åº¦å®šæ—¶å™¨ï¼ˆHRTimerï¼‰ç›¸å…³çš„å‡½æ•°ä¹‹ä¸€ã€‚è®©æˆ‘ä¸ºæ‚¨è¯¦ç»†ä»‹ç»ä¸€ä¸‹ï¼Œå¹¶æä¾›ä¸€ä¸ªç¤ºä¾‹ä»£ç ï¼š HRTimer ç®€ä»‹ï¼š HRTimer æ˜¯ Linux å†…æ ¸ä¸­çš„é«˜ç²¾åº¦å®šæ—¶å™¨ï¼Œç”¨äºæä¾›çº³ç§’çº§åˆ«çš„æ—¶é’Ÿç²¾åº¦ã€‚ ä¸ä¼ ç»Ÿçš„å®šæ—¶å™¨ç›¸æ¯”ï¼ŒHRTimer å…è®¸æ›´ç²¾ç¡®åœ°æ§åˆ¶å®šæ—¶äº‹ä»¶ï¼Œé€‚ç”¨äºå¯¹æ—¶é—´è¦æ±‚è¾ƒé«˜çš„åœºæ™¯ï¼Œå¦‚çœ‹é—¨ç‹—ã€USBã€ä»¥å¤ªç½‘ã€å—è®¾å¤‡ã€è™šæ‹Ÿæœºç­‰å­ç³»ç»Ÿã€‚ hrtimer_init å‡½æ•°ï¼š hrtimer_init ç”¨äºåˆå§‹åŒ–ä¸€ä¸ª struct hrtimer å®ä¾‹ã€‚ å‚æ•°ï¼š timerï¼šæŒ‡å‘è¦åˆå§‹åŒ–çš„ HRTimer å®ä¾‹çš„æŒ‡é’ˆã€‚ clock_idï¼šæ—¶é’Ÿçš„ç§ç±»ï¼Œä¾‹å¦‚ CLOCK_MONOTONIC è¡¨ç¤ºè‡ªç³»ç»Ÿå¼€æœºä»¥æ¥çš„å•è°ƒé€’å¢æ—¶é—´ã€‚ modeï¼šå®šæ—¶å™¨çš„æ¨¡å¼ï¼Œå¯ä»¥æ˜¯ç»å¯¹æ—¶é—´ï¼ˆHRTIMER_MODE_ABSï¼‰æˆ–ç›¸å¯¹æ—¶é—´ï¼ˆHRTIMER_MODE_RELï¼‰ã€‚ ç¤ºä¾‹ä»£ç ï¼š ä¸‹é¢æ˜¯ä¸€ä¸ªä½¿ç”¨ HRTimer çš„ç®€å•ç¤ºä¾‹ä»£ç ï¼Œç”¨äºåœ¨å†…æ ¸ä¸­å¯åŠ¨ä¸€ä¸ªç›¸å¯¹æ—¶é—´çš„ HRTimerï¼š #include &lt;linux/hrtimer.h&gt; #include &lt;linux/ktime.h&gt; #include &lt;linux/module.h&gt; MODULE_LICENSE(\"GPL\"); static struct hrtimer my_timer; static ktime_t interval; static enum hrtimer_restart my_timer_callback(struct hrtimer *timer) { // Your timer callback logic here // For demonstration purposes, let's print a message. pr_info(\"HRTimer callback executed!\\n\"); return HRTIMER_RESTART; } static int __init my_module_init(void) { // Initialize the HRTimer interval = ktime_set(1, 0); // Set interval to 1 second hrtimer_init(&amp;my_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL); my_timer.function = my_timer_callback; // Start the timer hrtimer_start(&amp;my_timer, interval, HRTIMER_MODE_REL); pr_info(\"HRTimer module initialized\\n\"); return 0; } static void __exit my_module_exit(void) { // Cleanup: Stop the timer hrtimer_cancel(&amp;my_timer); pr_info(\"HRTimer module removed\\n\"); } module_init(my_module_init); module_exit(my_module_exit); åœ¨ä¸Šè¿°ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬åˆå§‹åŒ–äº†ä¸€ä¸ªç›¸å¯¹æ—¶é—´çš„ HRTimerï¼Œè®¾ç½®äº†å›è°ƒå‡½æ•° my_timer_callbackï¼Œå¹¶å¯åŠ¨äº†å®šæ—¶å™¨ã€‚ å†…æ ¸çº¿ç¨‹ kthread_create_worker() å‡½æ•°æ˜¯Linuxå†…æ ¸ä¸­ç”¨äºåˆ›å»ºå†…æ ¸çº¿ç¨‹çš„ä¸€ä¸ªå‡½æ•°ã€‚é€šè¿‡è®¾ç½®æ ‡å¿—å‚æ•°å’Œæ ¼å¼åŒ–å­—ç¬¦ä¸²ï¼Œå¯ä»¥æŒ‡å®šåˆ›å»ºå†…æ ¸çº¿ç¨‹çš„è¡Œä¸ºå’Œåç§°ã€‚å®ƒåˆ†é…å¹¶åˆå§‹åŒ–äº†ä¸€ä¸ªkthread_workerç»“æ„ä½“ï¼Œå¹¶ä½¿ç”¨å®ƒæ¥åˆ›å»ºå†…æ ¸çº¿ç¨‹. ä»¥ä¸‹æ˜¯kthread_create_workerå‡½æ•°çš„ä¸€äº›å…³é”®å‚æ•°ï¼š cpu: å¦‚æœå¤§äºç­‰äº0ï¼Œå°†åˆ›å»ºç‰¹å®šäºæŸä¸ªCPUçš„å·¥ä½œçº¿ç¨‹ï¼›å¦‚æœä¸æƒ³åˆ›å»ºç‰¹å®šäºCPUçš„å·¥ä½œçº¿ç¨‹ï¼Œå¯ä»¥å°†CPUåŸŸèµ‹å€¼ä¸º-1ã€‚ flags: å¯ä»¥è®¾ç½®ä¸€äº›æ ‡å¿—ä½ï¼Œæ ¹æ®éœ€è¦æ¥æ§åˆ¶å†…æ ¸çº¿ç¨‹çš„è¡Œä¸ºã€‚ namefmt: ä¸€ä¸ªæ ¼å¼åŒ–å­—ç¬¦ä¸²ï¼Œç”¨äºæŒ‡å®šå†…æ ¸çº¿ç¨‹çš„åç§°ã€‚ è¿™ä¸ªå‡½æ•°ä¼šåˆ†é…å†…å­˜å¹¶åˆå§‹åŒ–kthread_workerç»“æ„ï¼Œç„¶åè¿”å›æŒ‡å‘è¯¥ç»“æ„çš„æŒ‡é’ˆã€‚æ‚¨å¯ä»¥æ ¹æ®å…·ä½“éœ€æ±‚ä½¿ç”¨è¿™ä¸ªå‡½æ•°æ¥åˆ›å»ºå’Œç®¡ç†å†…æ ¸çº¿ç¨‹ã€‚ å¦‚æœæ‚¨éœ€è¦ä¸€ä¸ªç¤ºä¾‹ä»£ç ï¼Œä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼Œå±•ç¤ºäº†å¦‚ä½•åœ¨æ¨¡å—åˆå§‹åŒ–æ—¶åˆ›å»ºä¸€ä¸ªå†…æ ¸çº¿ç¨‹ï¼Œä»¥åŠå¦‚ä½•åœ¨å¸è½½æ¨¡å—æ—¶å…³é—­è¯¥å†…æ ¸çº¿ç¨‹ï¼š #include &lt;linux/module.h&gt; #include &lt;linux/kthread.h&gt; #include &lt;linux/delay.h&gt; MODULE_LICENSE(\"GPL\"); static int demo_thr(void *data) { while (!kthread_should_stop()) { msleep_interruptible(2000); printk(KERN_INFO \"Thread is running...\\n\"); } return 0; } static struct task_struct *thr = NULL; static int kthread_demo_init(void) { thr = kthread_run(demo_thr, NULL, \"kthread-demo\"); if (!thr) { printk(KERN_ERR \"Failed to create kthread\\n\"); return -ENOMEM; } return 0; } static void kthread_demo_exit(void) { if (thr) { kthread_stop(thr); thr = NULL; } } module_init(kthread_demo_init); module_exit(kthread_demo_exit); åœ¨è¿™ä¸ªç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨kthread_runå‡½æ•°åˆ›å»ºä¸€ä¸ªåä¸ºkthread-demoçš„å†…æ ¸çº¿ç¨‹ï¼Œå®ƒæ¯éš”2ç§’æ‰“å°ä¸€æ¡ä¿¡æ¯ã€‚åœ¨å¸è½½æ¨¡å—æ—¶ï¼Œæˆ‘ä»¬ä½¿ç”¨kthread_stopæ¥å…³é—­è¯¥å†…æ ¸çº¿ç¨‹ã€‚ å·¥ä½œé˜Ÿåˆ— schedule_work å‡½æ•°æ˜¯Linuxå†…æ ¸ä¸­çš„ä¸€ä¸ªé‡è¦å‡½æ•°ï¼Œç”¨äºå°†ä¸€ä¸ªå·¥ä½œé¡¹ï¼ˆworkï¼‰æ·»åŠ åˆ°å·¥ä½œé˜Ÿåˆ—ï¼ˆworkqueueï¼‰ä¸­ã€‚è¿™ä¸ªå‡½æ•°çš„ä½œç”¨æ˜¯åœ¨åå°æ‰§è¡Œä¸€äº›å»¶è¿Ÿè¾ƒé•¿çš„ä»»åŠ¡ï¼Œè€Œä¸ä¼šé˜»å¡ä¸»çº¿ç¨‹çš„æ‰§è¡Œã€‚ ä»¥ä¸‹æ˜¯å…³äºschedule_workå‡½æ•°çš„ä¸€äº›è¦ç‚¹ï¼š åŠŸèƒ½ï¼šå°†å·¥ä½œé¡¹æ·»åŠ åˆ°é»˜è®¤çš„å·¥ä½œé˜Ÿåˆ—ï¼ˆé€šå¸¸æ˜¯system_wqï¼‰ä¸­ï¼Œä»¥ä¾¿ç¨åæ‰§è¡Œã€‚ è°ƒç”¨æ–¹å¼ï¼šschedule_work(&amp;my_work);ï¼Œå…¶ä¸­my_workæ˜¯ä¸€ä¸ªå·²ç»åˆå§‹åŒ–çš„å·¥ä½œé¡¹ã€‚ å·¥ä½œé˜Ÿåˆ—ï¼šå·¥ä½œé˜Ÿåˆ—æ˜¯ä¸€ç§å¼‚æ­¥æ‰§è¡Œæœºåˆ¶ï¼Œç”¨äºå¤„ç†å»¶è¿Ÿçš„æˆ–éå®æ—¶çš„ä»»åŠ¡ã€‚ å»¶è¿Ÿæ‰§è¡Œï¼šschedule_workä¼šå°†å·¥ä½œé¡¹æ·»åŠ åˆ°å·¥ä½œé˜Ÿåˆ—ä¸­ï¼Œç­‰å¾…ç³»ç»Ÿè°ƒåº¦æ‰§è¡Œã€‚è¿™æ ·ï¼Œä¸»çº¿ç¨‹å¯ä»¥ç»§ç»­æ‰§è¡Œå…¶ä»–ä»»åŠ¡ï¼Œè€Œä¸å¿…ç­‰å¾…å·¥ä½œé¡¹å®Œæˆã€‚ å·¥ä½œé¡¹å›è°ƒå‡½æ•°ï¼šå·¥ä½œé¡¹çš„å®é™…æ‰§è¡Œé€»è¾‘ç”±å›è°ƒå‡½æ•°å®šä¹‰ã€‚å½“å·¥ä½œé¡¹è¢«è°ƒåº¦æ‰§è¡Œæ—¶ï¼Œä¼šè°ƒç”¨è¿™ä¸ªå›è°ƒå‡½æ•°ã€‚ ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„ç¤ºä¾‹ä»£ç ï¼Œå±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨INIT_WORKå’Œschedule_workæ¥åˆ›å»ºå’Œè°ƒåº¦ä¸€ä¸ªå·¥ä½œé¡¹ï¼š #include &lt;linux/init.h&gt; #include &lt;linux/module.h&gt; #include &lt;linux/kernel.h&gt; #include &lt;linux/workqueue.h&gt; MODULE_LICENSE(\"GPL\"); static struct work_struct my_work; // å·¥ä½œé¡¹çš„å›è°ƒå‡½æ•° static void my_work_handler(struct work_struct *work) { printk(KERN_INFO \"My work handler is running...\\n\"); // åœ¨è¿™é‡Œæ‰§è¡Œæ‚¨çš„å·¥ä½œé€»è¾‘ } static int init_my_module(void) { printk(KERN_INFO \"Initializing my kernel module with workqueue...\\n\"); // åˆå§‹åŒ–å·¥ä½œé¡¹ INIT_WORK(&amp;my_work, my_work_handler); // å°†å·¥ä½œé¡¹æ·»åŠ åˆ°å·¥ä½œé˜Ÿåˆ— schedule_work(&amp;my_work); return 0; } static void cleanup_my_module(void) { printk(KERN_INFO \"Cleaning up my kernel module...\\n\"); } module_init(init_my_module); module_exit(cleanup_my_module); åœ¨è¿™ä¸ªç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆå®šä¹‰äº†ä¸€ä¸ªåä¸ºmy_workqueueçš„å·¥ä½œé˜Ÿåˆ—ç»“æ„ä½“ï¼Œä»¥åŠä¸€ä¸ªåä¸ºmy_workçš„å·¥ä½œé¡¹ã€‚ç„¶åï¼Œåœ¨init_my_moduleå‡½æ•°ä¸­ä½¿ç”¨create_singlethread_workqueueæ¥åˆ›å»ºä¸€ä¸ªåä¸ºmy_workqueueçš„å·¥ä½œé˜Ÿåˆ—ã€‚æ¥ç€ï¼Œæˆ‘ä»¬ä½¿ç”¨INIT_WORKæ¥åˆå§‹åŒ–å·¥ä½œé¡¹ï¼Œå¹¶ä½¿ç”¨schedule_workæ¥è°ƒåº¦å®ƒã€‚ alloc_ordered_workqueue ç”¨äºåˆ›å»ºæœ‰åºçš„å·¥ä½œé˜Ÿåˆ—ï¼ˆworkqueueï¼‰ã€‚è®©æˆ‘è¯¦ç»†ä»‹ç»ä¸€ä¸‹ï¼Œå¹¶æä¾›ä¸€ä¸ªç¤ºä¾‹ä»£ç ï¼š alloc_ordered_workqueue ç®€ä»‹ï¼š alloc_ordered_workqueue å‡½æ•°ç”¨äºåˆ†é…ä¸€ä¸ªæœ‰åºçš„å·¥ä½œé˜Ÿåˆ—ã€‚ æœ‰åºå·¥ä½œé˜Ÿåˆ—æ˜¯ä¸€ç§ç‰¹æ®Šç±»å‹çš„å·¥ä½œé˜Ÿåˆ—ï¼Œå®ƒç¡®ä¿å·¥ä½œé¡¹æŒ‰ç…§æäº¤çš„é¡ºåºæ‰§è¡Œã€‚ å‡½æ•°ç­¾åï¼š struct workqueue_struct *alloc_ordered_workqueue(const char *name, unsigned int flags); å‚æ•°è¯´æ˜ï¼š nameï¼šå·¥ä½œé˜Ÿåˆ—çš„åç§°ã€‚ flagsï¼šæ ‡å¿—ä½ï¼Œç”¨äºé…ç½®å·¥ä½œé˜Ÿåˆ—çš„è¡Œä¸ºã€‚ ç¤ºä¾‹ä»£ç ï¼š ä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„ç¤ºä¾‹ä»£ç ï¼Œå±•ç¤ºå¦‚ä½•ä½¿ç”¨ alloc_ordered_workqueue åˆ›å»ºä¸€ä¸ªæœ‰åºçš„å·¥ä½œé˜Ÿåˆ—ï¼š #include &lt;linux/init.h&gt; #include &lt;linux/module.h&gt; #include &lt;linux/workqueue.h&gt; static struct workqueue_struct *my_ordered_wq; static void my_work_handler(struct work_struct *work) { pr_info(\"Work item executed!\\n\"); } static DECLARE_WORK(my_work, my_work_handler); static int __init my_module_init(void) { my_ordered_wq = alloc_ordered_workqueue(\"my_ordered_wq\", 0); if (!my_ordered_wq) { pr_err(\"Failed to create ordered workqueue\\n\"); return -ENOMEM; } queue_work(my_ordered_wq, &amp;my_work); return 0; } static void __exit my_module_exit(void) { destroy_workqueue(my_ordered_wq); } module_init(my_module_init); module_exit(my_module_exit); MODULE_LICENSE(\"GPL\"); MODULE_DESCRIPTION(\"Ordered Workqueue Example\"); åœ¨æ­¤ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªåä¸º â€œmy_ordered_wqâ€ çš„æœ‰åºå·¥ä½œé˜Ÿåˆ—ï¼Œå¹¶å°†ä¸€ä¸ªå·¥ä½œé¡¹ my_work æäº¤åˆ°é˜Ÿåˆ—ä¸­ã€‚å·¥ä½œé¡¹çš„å¤„ç†å‡½æ•° my_work_handler å°†åœ¨æœ‰åºçš„é¡ºåºä¸­æ‰§è¡Œã€‚ create_singlethread_workqueue create_singlethread_workqueue æ˜¯ Linux å†…æ ¸ä¸­çš„ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºåˆ›å»ºä¸€ä¸ªåªåŒ…å«å•ä¸ªå·¥ä½œçº¿ç¨‹çš„å·¥ä½œé˜Ÿåˆ—ï¼ˆworkqueueï¼‰ã€‚è®©æˆ‘è¯¦ç»†ä»‹ç»ä¸€ä¸‹ï¼šğŸ™‚ create_singlethread_workqueue ç®€ä»‹ï¼š create_singlethread_workqueue å‡½æ•°ç”¨äºåˆ›å»ºä¸€ä¸ªåªåŒ…å«ä¸€ä¸ªå·¥ä½œçº¿ç¨‹çš„å·¥ä½œé˜Ÿåˆ—ã€‚ æ— è®ºç³»ç»Ÿä¸­æœ‰å¤šå°‘ä¸ª CPUï¼Œè¿™ä¸ªå·¥ä½œé˜Ÿåˆ—éƒ½åªä¼šæœ‰ä¸€ä¸ªå·¥ä½œçº¿ç¨‹ã€‚ å‡½æ•°ç­¾åï¼š struct workqueue_struct *create_singlethread_workqueue(const char *name); å‚æ•°è¯´æ˜ï¼š nameï¼šå·¥ä½œé˜Ÿåˆ—çš„åç§°ã€‚ å·¥ä½œåŸç†ï¼š create_singlethread_workqueue åˆ›å»ºçš„å·¥ä½œé˜Ÿåˆ—åªæœ‰ä¸€ä¸ªå·¥ä½œçº¿ç¨‹ã€‚ æ‰€æœ‰æäº¤åˆ°è¿™ä¸ªå·¥ä½œé˜Ÿåˆ—çš„å·¥ä½œé¡¹éƒ½ä¼šç”±è¿™ä¸ªå•ä¸€çš„å·¥ä½œçº¿ç¨‹æŒ‰é¡ºåºæ‰§è¡Œã€‚ ç¤ºä¾‹ä»£ç ï¼š ä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„ç¤ºä¾‹ä»£ç ï¼Œå±•ç¤ºå¦‚ä½•ä½¿ç”¨ create_singlethread_workqueue åˆ›å»ºä¸€ä¸ªåªåŒ…å«å•ä¸ªå·¥ä½œçº¿ç¨‹çš„å·¥ä½œé˜Ÿåˆ—ï¼š #include &lt;linux/init.h&gt; #include &lt;linux/module.h&gt; #include &lt;linux/workqueue.h&gt; static struct workqueue_struct *my_singlethread_wq; static void my_work_handler(struct work_struct *work) { pr_info(\"Work item executed!\\n\"); } static DECLARE_WORK(my_work, my_work_handler); static int __init my_module_init(void) { my_singlethread_wq = create_singlethread_workqueue(\"my_singlethread_wq\"); if (!my_singlethread_wq) { pr_err(\"Failed to create singlethread workqueue\\n\"); return -ENOMEM; } queue_work(my_singlethread_wq, &amp;my_work); return 0; } static void __exit my_module_exit(void) { destroy_workqueue(my_singlethread_wq); } module_init(my_module_init); module_exit(my_module_exit); MODULE_LICENSE(\"GPL\"); MODULE_DESCRIPTION(\"Singlethread Workqueue Example\"); åœ¨æ­¤ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªåä¸º â€œmy_singlethread_wqâ€ çš„å·¥ä½œé˜Ÿåˆ—ï¼Œå¹¶å°†ä¸€ä¸ªå·¥ä½œé¡¹ my_work æäº¤åˆ°é˜Ÿåˆ—ä¸­ã€‚è¿™ä¸ªå·¥ä½œé¡¹çš„å¤„ç†å‡½æ•° my_work_handler å°†åœ¨å•ä¸€çš„å·¥ä½œçº¿ç¨‹ä¸­æŒ‰é¡ºåºæ‰§è¡Œã€‚ completion init_completion() æ˜¯Linuxå†…æ ¸ä¸­ç”¨äºå®Œæˆäº‹ä»¶é€šçŸ¥æœºåˆ¶çš„ä¸€ä¸ªå‡½æ•°ï¼Œä¸»è¦ç”¨äºè¿›ç¨‹é—´æˆ–çº¿ç¨‹é—´çš„åŒæ­¥ã€‚è¿™ä¸ªå‡½æ•°åˆå§‹åŒ–ä¸€ä¸ª completion ç»“æ„ä½“ï¼Œè¯¥ç»“æ„ä½“ç”¨äºè¡¨ç¤ºæŸä¸ªäº‹ä»¶æ˜¯å¦å·²ç»å‘ç”Ÿã€‚åœ¨å¤šçº¿ç¨‹æˆ–å¤šè¿›ç¨‹ç¼–ç¨‹ä¸­ï¼Œæœ‰æ—¶éœ€è¦ä¸€ä¸ªçº¿ç¨‹æˆ–è¿›ç¨‹ç­‰å¾…å¦ä¸€ä¸ªçº¿ç¨‹æˆ–è¿›ç¨‹å®ŒæˆæŸä¸ªä»»åŠ¡ã€‚ è®©æˆ‘ä»¬æ¥è¯¦ç»†äº†è§£ä¸€ä¸‹ init_completion() å‡½æ•°çš„åŠŸèƒ½å’Œç”¨æ³•ï¼š åˆå§‹åŒ–completionç»“æ„ä½“ï¼š completion ç»“æ„ä½“ç”¨äºç»´æŠ¤â€œcompleteâ€çŠ¶æ€ï¼Œè¡¨ç¤ºæŸä¸ªä»»åŠ¡æ˜¯å¦å·²å®Œæˆã€‚ ç»“æ„ä½“å®šä¹‰å¦‚ä¸‹ï¼š struct completion { unsigned int done; struct swait_queue_head wait; }; done å­—æ®µè¡¨ç¤ºå®ŒæˆçŠ¶æ€ï¼Œåˆå§‹å€¼ä¸º 0ã€‚ swait_queue_head æ˜¯ä¸€ä¸ªç­‰å¾…é˜Ÿåˆ—å¤´ï¼Œç”¨äºç®¡ç†ç­‰å¾…è¯¥å®Œæˆäº‹ä»¶çš„çº¿ç¨‹ã€‚ init_completion() å‡½æ•°ï¼š åŠ¨æ€å®šä¹‰åŠåˆå§‹åŒ–ä¸€ä¸ªä¿¡å·é‡ï¼š #define init_completion(x) __init_completion(x) static inline void __init_completion(struct completion *x) { x-&gt;done = 0; init_swait_queue_head(&amp;x-&gt;wait); } è¿™ä¸ªå‡½æ•°å®é™…ä¸Šæ˜¯åˆå§‹åŒ–äº† completion ç»“æ„ä½“ä¸­çš„ä¿¡å·é‡ã€‚ ç­‰å¾…å®Œæˆï¼š ç­‰å¾…ä¿¡å·é‡çš„é‡Šæ”¾ï¼š void __sched wait_for_completion(struct completion *x) { wait_for_common(x, MAX_SCHEDULE_TIMEOUT, TASK_UNINTERRUPTIBLE); } å‘ä¿¡ç«¯ï¼š complete() å‡½æ•°ç”¨äºå”¤é†’ç­‰å¾…è¯¥å®Œæˆäº‹ä»¶çš„å•ä¸ªçº¿ç¨‹ï¼š void complete(struct completion *x) { unsigned long flags; raw_spin_lock_irqsave(&amp;x-&gt;wait.lock, flags); if (x-&gt;done != UINT_MAX) x-&gt;done++; swake_up_locked(&amp;x-&gt;wait); raw_spin_unlock_irqrestore(&amp;x-&gt;wait.lock, flags); } åŒæ—¶å”¤é†’æ‰€æœ‰ç­‰å¾…çº¿ç¨‹ï¼š complete_all() å‡½æ•°ç”¨äºå”¤é†’ç­‰å¾…æ­¤ç‰¹å®šå®Œæˆäº‹ä»¶çš„æ‰€æœ‰çº¿ç¨‹ï¼š void complete_all(struct completion *x) { unsigned long flags; lockdep_assert_RT_in_threaded_ctx(); raw_spin_lock_irqsave(&amp;x-&gt;wait.lock, flags); x-&gt;done = UINT_MAX; swake_up_all_locked(&amp;x-&gt;wait); raw_spin_unlock_irqrestore(&amp;x-&gt;wait.lock, flags); } å®Œæ•´ç¤ºä¾‹ #include &lt;linux/module.h&gt; #include &lt;linux/init.h&gt; #include &lt;linux/completion.h&gt; #include &lt;linux/delay.h&gt; #include &lt;linux/kthread.h&gt; MODULE_LICENSE(\"GPL\"); MODULE_AUTHOR(\"kevin\"); static struct completion my_completion; static int my_thread(void *data){ pr_info(\"My thread is waiting for completion...\\n\"); wait_for_completion(&amp;my_completion); pr_info(\"My thread woke up! Event completed.\\n\"); return 0; } static int __init my_init(void){ pr_info(\"Initializing my module...\\n\"); init_completion(&amp;my_completion); // Start a new kernel thread kthread_run(my_thread, NULL, \"my_thread\"); // Simulate some work... msleep(2000); pr_info(\"Completing the event...\\n\"); complete(&amp;my_completion); return 0; } static void __exit my_exit(void){ pr_info(\"Exiting my module...\\n\"); } module_init(my_init); module_exit(my_exit); kobject_uevent_env å®ƒæ˜¯ Linux å†…æ ¸ ä¸­çš„ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºåœ¨ kobject çŠ¶æ€å‘ç”Ÿå˜åŒ–æ—¶å‘é€ uevent åˆ°ç”¨æˆ·ç©ºé—´ã€‚è®©æˆ‘è¯¦ç»†è§£é‡Šä¸€ä¸‹ï¼š kobjectï¼š kobject æ˜¯å†…æ ¸ä¸­çš„ä¸€ä¸ªæŠ½è±¡å¯¹è±¡ï¼Œç”¨äºè¡¨ç¤ºå„ç§å†…æ ¸æ•°æ®ç»“æ„ï¼Œä¾‹å¦‚è®¾å¤‡ã€é©±åŠ¨ç¨‹åºã€æ€»çº¿ç­‰ã€‚ æ¯ä¸ª kobject éƒ½æœ‰ä¸€ä¸ªåç§°ã€å¼•ç”¨è®¡æ•°å’Œå…¶ä»–å±æ€§ã€‚ ueventï¼š uevent æ˜¯ç”¨æˆ·ç©ºé—´äº‹ä»¶çš„ç¼©å†™ï¼Œç”¨äºé€šçŸ¥ç”¨æˆ·ç©ºé—´ç¨‹åºå†…æ ¸ä¸­çš„çŠ¶æ€å˜åŒ–ã€‚ ä¾‹å¦‚ï¼Œå½“è®¾å¤‡æ’å…¥æˆ–ç§»é™¤æ—¶ï¼Œå†…æ ¸ä¼šç”Ÿæˆç›¸åº”çš„ ueventã€‚ kobject_uevent_env å‡½æ•°ï¼š è¿™ä¸ªå‡½æ•°ç”¨äºå‘é€ uevent åˆ°ç”¨æˆ·ç©ºé—´ã€‚ å®ƒæ¥å—ä¸€ä¸ªæŒ‡å‘ kobject çš„æŒ‡é’ˆå’Œä¸€ä¸ªè¡¨ç¤º uevent çš„ç¯å¢ƒå˜é‡æ•°ç»„ã€‚ ç”¨æˆ·ç©ºé—´ç¨‹åºå¯ä»¥ç›‘å¬è¿™äº›äº‹ä»¶å¹¶åšå‡ºç›¸åº”çš„å¤„ç†ã€‚ ä½¿ç”¨ç¤ºä¾‹ï¼š åœ¨è®¾å¤‡é©±åŠ¨ç¨‹åºä¸­ï¼Œå½“è®¾å¤‡çŠ¶æ€å‘ç”Ÿå˜åŒ–æ—¶ï¼Œä¾‹å¦‚è®¾å¤‡æ’å…¥æˆ–ç§»é™¤ï¼Œå¯ä»¥ä½¿ç”¨ kobject_uevent_env å‘é€ç›¸åº”çš„ ueventã€‚ ç”¨æˆ·ç©ºé—´ç¨‹åºæ”¶åˆ°è¿™äº›äº‹ä»¶åï¼Œå¯ä»¥æ ¹æ®éœ€è¦æ‰§è¡Œæ“ä½œã€‚ ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„ç¤ºä¾‹ä»£ç ï¼Œå±•ç¤ºäº†å¦‚ä½•åœ¨å†…æ ¸æ¨¡å—ä¸­ä½¿ç”¨ kobject_uevent_env å‘é€ ueventï¼š #include &lt;linux/module.h&gt; #include &lt;linux/init.h&gt; #include &lt;linux/kobject.h&gt; static struct kobject *my_kobj; static int my_uevent(struct kset *kset, struct kobject *kobj, struct kobj_uevent_env *env) { // Add custom environment variables to the uevent add_uevent_var(env, \"MY_CUSTOM_VAR=hello_world\"); return 0; } static struct kset_uevent_ops my_uevent_ops = { .uevent = my_uevent, }; static int __init my_module_init(void) { my_kobj = kobject_create_and_add(\"my_kobject\", NULL); if (!my_kobj) return -ENOMEM; my_kobj-&gt;kset = kset_create_and_add(\"my_kset\", NULL, NULL); if (!my_kobj-&gt;kset) { kobject_put(my_kobj); return -ENOMEM; } my_kobj-&gt;kset-&gt;uevent_ops = &amp;my_uevent_ops; return 0; } static void __exit my_module_exit(void) { kset_unregister(my_kobj-&gt;kset); kobject_put(my_kobj); } module_init(my_module_init); module_exit(my_module_exit); MODULE_LICENSE(\"GPL\"); åœ¨æ­¤ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªåä¸º my_kobject çš„ kobjectï¼Œå¹¶å°†å…¶æ·»åŠ åˆ°ä¸€ä¸ªåä¸º my_kset çš„ kset ä¸­ã€‚ç„¶åï¼Œæˆ‘ä»¬è®¾ç½®äº†ä¸€ä¸ªè‡ªå®šä¹‰çš„ ueventï¼Œå°†ç¯å¢ƒå˜é‡ MY_CUSTOM_VAR æ·»åŠ åˆ° uevent ä¸­ã€‚ è¯·æ³¨æ„ï¼Œå®é™…åº”ç”¨ä¸­ï¼Œæ‚¨éœ€è¦æ ¹æ®æ‚¨çš„éœ€æ±‚è‡ªå®šä¹‰æ›´å¤šçš„ç¯å¢ƒå˜é‡å’Œå¤„ç†é€»è¾‘ã€‚ benchmark DRM kernel aspects (display and render): IGT GPU Tools (IGT): main DRM test suite, used for CI https://gitlab.freedesktop.org/drm/igt-gpu-tools/ OpenGL aspects: drawElements Quality Program (dEQP): OpenGL/OpenGL ES/Vulkan conformance tests https://android.googlesource.com/platform/external/deqp/ glmark2: OpenGL 2.0 and ES 2.0 benchmark tool https://github.com/glmark2/glmark2/ Patch series continuous integration: EzBench: a collection of tools to benchmark graphics-related patch-series https://github.com/freedesktop/ezbench/ General benchmarking (including graphics): Phoronix Test Suite: automated benchmarking tool https://github.com/phoronix-test-suite/phoronix-test-suite/"
  },"/blog/linux/2018-08-01-DeviceResourceManage.html": {
    "title": "è®¾å¤‡èµ„æºç®¡ç†æ¨¡å—",
    "keywords": "linux",
    "url": "/blog/linux/2018-08-01-DeviceResourceManage.html",
    "body": "1.è§£å†³çš„é—®é¢˜ ç›¸ä¿¡æ¯ä¸€ä¸ªå†™è¿‡Linux driverçš„å·¥ç¨‹å¸ˆï¼Œéƒ½åœ¨probeå‡½æ•°ä¸­é‡åˆ°è¿‡ä¸Šé¢çš„å›°æƒ‘ï¼šåœ¨é¡ºåºç”³è¯·å¤šç§èµ„æºï¼ˆIRQã€Clockã€memoryã€regionsã€ioremapã€dmaã€ç­‰ç­‰ï¼‰çš„è¿‡ç¨‹ä¸­ï¼Œåªè¦ä»»æ„ä¸€ç§èµ„æºç”³è¯·å¤±è´¥ï¼Œå°±è¦å›æ»šé‡Šæ”¾ä¹‹å‰ç”³è¯·çš„æ‰€æœ‰èµ„æºã€‚ äºæ˜¯åœ¨å‡½æ•°çš„æœ€åï¼Œå°±ä¸€å®šä¼šå‡ºç°å¾ˆå¤šçš„gotoæ ‡ç­¾ï¼Œç”¨äºé‡Šæ”¾ä¸åŒçš„èµ„æºï¼ˆå¦‚ä¸Šé¢çš„exit_free_irqã€exit_free_dmaã€ç­‰ç­‰ï¼‰ã€‚ åœ¨ç”³è¯·èµ„æºå‡ºé”™æ—¶ï¼Œå°å¿ƒç¿¼ç¿¼çš„gotoåˆ°æ­£ç¡®çš„æ ‡ç­¾ä¸Šï¼Œä»¥ä¾¿é‡Šæ”¾å·²ç”³è¯·èµ„æºã€‚ è¿™æ ·åœ¨ä»£ç ä¸­ï¼Œæ•´ä¸ªå‡½æ•°è¢«å¤§æ®µçš„ã€é‡å¤çš„å¦‚ä¸‹ä»£ç å……æ–¥ã€‚ if (!condition) { err = xxx; goto xxx; } æ—¢æµªè´¹ç²¾åŠ›å®¹æ˜“å‡ºé”™ï¼Œä¹Ÿä¸ç¾è§‚ã€‚ æœ‰å›°æƒ‘ï¼Œå°±æœ‰æ”¹å–„çš„åŠæ³•ã€‚ æ–¹æ³•å°±æ˜¯Linuxè®¾å¤‡æ¨¡å‹ä¸­çš„device resource managementï¼ˆè®¾å¤‡èµ„æºç®¡ç†ï¼‰ã€‚ 2.è§£å†³çš„æ€è·¯ devresæä¾›äº†ä¸€ç§æœºåˆ¶ï¼Œç”¨èµ„æºèŠ‚ç‚¹çš„å½¢å¼è®°å½•å®ƒç”³è¯·çš„èµ„æºï¼Œå¹¶åœ¨ç³»ç»Ÿä¸­ä¸ºè®¾å¤‡åˆ†é…ä¸€ä¸ªé“¾è¡¨ï¼Œå½“ç”³è¯·æŸä¸ªèµ„æºæ—¶ï¼Œå°±æ„å»ºä¸€ä¸ªèµ„æºèŠ‚ç‚¹ï¼Œç„¶åæŠŠå®ƒåŠ å…¥åˆ°è¿™ä¸ªé“¾è¡¨ä¸­ï¼Œå¯¹åº”çš„é‡Šæ”¾å‡½æ•°ä¹Ÿä¼šè¢«è®°å½•ï¼Œä»¥ä¾¿åœ¨driver detachçš„æ—¶å€™ï¼Œè‡ªåŠ¨é‡Šæ”¾ã€‚ ä¸ºäº†ä½¿ç”¨devresæœºåˆ¶ï¼Œèµ„æºè¦å¯¹å„è‡ªçš„èµ„æºåˆ†é…å‡½æ•°é‡æ–°å°è£…ï¼ŒåŠ å…¥èµ„æºèŠ‚ç‚¹çš„ç”³è¯·ã€æ·»åŠ å’Œé‡Šæ”¾ï¼Œä¸€èˆ¬æ–°å‡½æ•°åæ”¹æˆäº†devm_xxx()çš„å½¢å¼ã€‚driverä½œè€…åªç®¡è°ƒç”¨è¿™äº›devm_xxx()æ¥å£æ¥ç”³è¯·èµ„æºï¼Œä¸ç”¨è€ƒè™‘é‡Šæ”¾ï¼Œè®¾å¤‡æ¨¡å‹ä¼šåœ¨é€‚å½“çš„æ—¶å€™é‡Šæ”¾å®ƒä»¬ã€‚ device resource managementä½äºâ€œdrivers/base/devres.câ€ä¸­ï¼Œå®ƒå®ç°äº†ä¸Šè¿°æœºåˆ¶ã€‚ 3.æä¾›çš„æ¥å£ ä»¥ä¸‹æ˜¯devresæä¾›çš„å‡ ä¸ªåŸºæœ¬æ¥å£ interface Description devres_alloc( ) // åˆ†é…èµ„æºèŠ‚ç‚¹ devres_free( ) // é‡Šæ”¾èµ„æºèŠ‚ç‚¹ devres_add( ) // æ·»åŠ èµ„æºèŠ‚ç‚¹åˆ°é“¾è¡¨ devres_destroy( ) // é‡Šæ”¾èµ„æº devres_release_all() //é‡Šæ”¾æ‰€æœ‰èµ„æº 4.æ¥å£çš„ä½¿ç”¨ å…¶ä»–èµ„æºæ¨¡å—ï¼Œå¯ä»¥é€šè¿‡è°ƒç”¨devresæä¾›çš„æ¥å£ï¼Œåˆ©ç”¨devresæœºåˆ¶å®ç°èµ„æºçš„è‡ªåŠ¨é‡Šæ”¾ã€‚ 4.1 èµ„æºèŠ‚ç‚¹å‡½æ•°çš„åº”ç”¨ä¸¾ä¾‹ ä¸‹é¢çš„ä»£ç æ˜¯åˆ©ç”¨devresæœºåˆ¶å®ç°åˆ†é…ä¸­æ–­èµ„æºå‡½æ•° devm_request_threaded_irq( ), ä¸Šå±‚æ¨¡å—å¯ä»¥è°ƒç”¨å®ƒæ¥åˆ†é…ä¸­æ–­èµ„æºï¼Œåœ¨å‡ºé”™æ—¶ï¼Œä¸å¿…è€ƒè™‘å¯¹è¯¥èµ„æºçš„é‡Šæ”¾ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨é‡Šæ”¾ã€‚ ä¸»è¦æ¶‰åŠåˆ°devres_alloc()ã€devres_free()å’Œdevres_add() 4.2 èµ„æºé‡Šæ”¾å‡½æ•°çš„åº”ç”¨ä¸¾ä¾‹ èµ„æºé‡Šæ”¾å‡½æ•°devres_destroy()çš„ä½¿ç”¨ä¸¾ä¾‹ï¼Œèµ„æºæ¨¡å—å¯ä»¥ç”¨å®ƒæ¥å°è£…èµ„æºé‡Šæ”¾å‡½æ•°ã€‚ 5. å‡½æ•°çš„å†…éƒ¨å®ç° 5.1 devres_alloc() devrs_alloc()å‡½æ•°çš„å®ç°ï¼Œä¸»è¦è°ƒç”¨äº†å†…éƒ¨å‡½æ•°alloc_dr(), å®ƒä¼šåˆ†é…size+sizeof(struct devres)çš„å†…å­˜å¤§å°, struct devresç”¨äºå­˜å‚¨èµ„æºèŠ‚ç‚¹ä¿¡æ¯ï¼Œå¹¶è®°å½•release å‡½æ•°ã€‚ 5.2 devres_add() devres_add()ä¸»è¦å®ç°æŠŠèµ„æºèŠ‚ç‚¹æ·»åŠ åˆ°è®¾å¤‡çš„èµ„æºé“¾è¡¨ä¸­ã€‚ 5.3 devres_destroy() devres_destroy()ä¸»è¦æ¶‰åŠåˆ°ä»¥ä¸‹å‡ ä¸ªå†…éƒ¨å‡½æ•°ï¼š devres_remove() //æŸ¥æ‰¾åˆ°èµ„æºèŠ‚ç‚¹ï¼Œå¹¶ä»é“¾è¡¨ä¸­åˆ é™¤ find_dr() //æ ¹æ®releaseå‡½æ•°æŒ‡é’ˆã€matchå‡½æ•°æŸ¥æ‰¾èµ„æºèŠ‚ç‚¹ devres_free() //é‡Šæ”¾èµ„æºèŠ‚ç‚¹ å¯ä»¥ç»“åˆä¸Šé¢å®ƒçš„ä½¿ç”¨å®ä¾‹æ¥å­¦ä¹ ã€‚ 5.4 devers_release_all() devers_release_all()çš„è°ƒç”¨ä¼šé‡Šæ”¾æ‰€æœ‰èµ„æºã€‚å®ƒçš„è¢«è°ƒç”¨æ—¶æœºæœ‰ä¸¤ä¸ªï¼š really_probe()å¤±è´¥ è®¾å¤‡ä¸é©±åŠ¨åˆ†ç¦»æ—¶, deriver_dettachæ—¶ å°±æ˜¯driver_removeæ—¶ã€‚"
  },"/blog/jekyll/2018-05-20-memory_check.html": {
    "title": "è¿›ç¨‹å†…å­˜æ£€æŸ¥",
    "keywords": "Jekyll",
    "url": "/blog/jekyll/2018-05-20-memory_check.html",
    "body": "1.è¿›ç¨‹å†…å­˜æ˜ å°„æ–‡ä»¶smaps åœ¨å†…æ ¸çš„æ•°æ®ç»“æ„ä¸­ï¼Œè¿›ç¨‹ã€è¿›ç¨‹ä½¿ç”¨å†…å­˜ã€è™šæ‹Ÿå†…å­˜å—å’Œä¸€ä¸ªäºŒè¿›åˆ¶ç¨‹åºæ–‡ä»¶çš„å¯¹åº”å…³ç³»å›¾å¦‚ä¸‹ã€‚ æŸ¥çœ‹/proc/${PID}/smapsï¼Œå¯ä»¥å¾—åˆ°æ¯ä¸€ä¸ªvm_area_nodeçš„è¯¦ç»†ä¿¡æ¯ã€‚ ä¸‹å›¾æ˜¯ä¸€ä¸ªå…·ä½“çš„vm_area_nodeä¿¡æ¯ã€‚ 1.1 ä¸¤ç§æ˜ å°„ ä¸‹é¢ä¸¤ç§æ˜ å°„çš„ä»‹ç»ï¼Œæ˜¯ä¸ºäº†ä¸‹ä¸€èŠ‚è§£é‡Šå„å­—æ®µå«ä¹‰åšå‡†å¤‡ã€‚ æ–‡ä»¶æ˜ å°„ å°±æ˜¯å­˜å‚¨ä»‹è´¨(æ¯”å¦‚ï¼šç£ç›˜)ä¸­çš„æ•°æ®é€šè¿‡æ–‡ä»¶ç³»ç»Ÿæ˜ å°„åˆ°å†…å­˜å†é€šè¿‡æ–‡ä»¶æ˜ å°„æ˜ å°„åˆ°è™šæ‹Ÿç©ºé—´ï¼Œè¿™æ ·ï¼Œç”¨æˆ·å°±å¯ä»¥åœ¨ç”¨æˆ·ç©ºé—´é€šè¿‡ open, read, write ç­‰å‡½æ•°åŒºæ“ä½œæ–‡ä»¶å†…å®¹ã€‚ä»£ç ä¸­å‡½æ•°open(), read(), write(), close(), mmap(fdï¼Œâ€¦)â€¦ æ“ä½œçš„è™šæ‹Ÿåœ°å€éƒ½å±äºæ–‡ä»¶æ˜ å°„ã€‚ åŒ¿åæ˜ å°„ å°±æ˜¯ç”¨æˆ·ç©ºé—´è¦æ±‚å†…æ ¸åˆ†é…ä¸€å®šçš„ç‰©ç†å†…å­˜æ¥å­˜å‚¨æ•°æ®ï¼Œè¿™éƒ¨åˆ†å†…å­˜ä¸å±äºä»»ä½•æ–‡ä»¶ã€‚å†…æ ¸å°±ä½¿ç”¨åŒ¿åæ˜ å°„å°†å†…å­˜ä¸­çš„æŸæ®µç‰©ç†åœ°å€ä¸ç”¨æˆ·ç©ºé—´ä¸€ä¸€æ˜ å°„ï¼Œè¿™æ ·ç”¨æˆ·å°±å¯ç”¨ç›´æ¥æ“ä½œè™šæ‹Ÿåœ°å€æ¥èŒƒå›´è¿™æ®µç‰©ç†å†…å­˜ã€‚æ¯”å¦‚ä½¿ç”¨malloc(), mmap(NULLï¼Œâ€¦)ç”³è¯·å†…å­˜ã€‚ 1.2 å„å­—æ®µå«ä¹‰ ç¬¬ä¸€è¡Œ 08048000-080bc000: è¯¥è™šæ‹Ÿå†…å­˜æ®µçš„å¼€å§‹å’Œç»“æŸä½ç½® r-xp:å†…å­˜æ®µçš„æƒé™ï¼Œåˆ†åˆ«æ˜¯å¯è¯»ã€å¯å†™ã€å¯è¿è¡Œã€ç§æœ‰æˆ–å…±äº«ï¼Œæœ€åä¸€ä½pä»£è¡¨ç§æœ‰ï¼Œsä»£è¡¨å…±äº«(å¦‚å…±äº«çš„å†…å­˜ï¼Œ shm). å¦‚æœæœ‰â€wâ€ï¼Œè¡¨ç¤ºæ˜¯åº“çš„æ•°æ®åŒº. 00000000: è™šæ‹Ÿå†…å­˜æ®µèµ·å§‹åœ°å€åœ¨å¯¹åº”çš„æ˜ å°„æ–‡ä»¶ä¸­ä»¥é¡µä¸ºå•ä½çš„åç§»é‡ï¼Œ å¯¹åŒ¿åæ˜ å°„ï¼Œå®ƒç­‰äº0æˆ–è€…vm_start/PAGE_SIZE 03:02: æ–‡ä»¶çš„ä¸»è®¾å¤‡å·å’Œæ¬¡è®¾å¤‡å·ã€‚ å¯¹æœ‰åæ˜ å°„æ¥è¯´ï¼Œæ˜¯æ˜ å°„çš„æ–‡ä»¶æ‰€åœ¨è®¾å¤‡çš„è®¾å¤‡å· å¯¹åŒ¿åæ˜ å°„æ¥è¯´ï¼Œå› ä¸ºæ²¡æœ‰æ–‡ä»¶åœ¨ç£ç›˜ä¸Šï¼Œæ‰€ä»¥æ²¡æœ‰è®¾å¤‡å·ï¼Œå§‹ç»ˆä¸º00:00ã€‚ 13130: è¢«æ˜ å°„åˆ°è™šæ‹Ÿå†…å­˜çš„æ–‡ä»¶çš„ç´¢å¼•èŠ‚ç‚¹å·,é€šè¿‡è¯¥èŠ‚ç‚¹å¯ä»¥æ‰¾åˆ°å¯¹åº”çš„æ–‡ä»¶ï¼Œ å¯¹åŒ¿åæ˜ å°„æ¥è¯´ï¼Œå› ä¸ºæ²¡æœ‰æ–‡ä»¶åœ¨ç£ç›˜ä¸Šï¼Œæ‰€ä»¥ä¸º0 /bin/bash: è¢«æ˜ å°„åˆ°è™šæ‹Ÿå†…å­˜çš„æ–‡ä»¶åç§°ã€‚åé¢å¸¦(deleted)çš„æ˜¯å†…å­˜æ•°æ®ï¼Œå¯ä»¥è¢«é”€æ¯ã€‚ å¯¹æœ‰åæ˜ å°„æ¥è¯´ï¼Œæ˜¯æ˜ å°„çš„æ–‡ä»¶åã€‚ å¯¹åŒ¿åæ˜ å°„æ¥è¯´ï¼Œæ˜¯æ­¤æ®µè™šæ‹Ÿå†…å­˜åœ¨è¿›ç¨‹ä¸­çš„è§’è‰²ã€‚[stack]è¡¨ç¤ºåœ¨è¿›ç¨‹ä¸­ä½œä¸ºæ ˆä½¿ç”¨ï¼Œ[heap]è¡¨ç¤ºå †ã€‚å…¶ä½™æƒ…å†µæ¯”å¦‚mmap(NULL, â€¦.)åˆ™æ— æ˜¾ç¤ºã€‚ Size è™šæ‹Ÿå†…å­˜ç©ºé—´å¤§å°ã€‚ä½†æ˜¯è¿™ä¸ªå†…å­˜å€¼ä¸ä¸€å®šæ˜¯ç‰©ç†å†…å­˜å®é™…åˆ†é…çš„å¤§å°ï¼Œå› ä¸ºåœ¨ç”¨æˆ·æ€ä¸Šï¼Œè™šæ‹Ÿå†…å­˜æ€»æ˜¯å»¶è¿Ÿåˆ†é…çš„ã€‚è¿™ä¸ªå€¼è®¡ç®—ä¹Ÿéå¸¸ç®€å•ï¼Œå°±æ˜¯è¯¥VMAçš„å¼€ å§‹ä½ç½®å‡ç»“æŸä½ç½®ã€‚ å»¶è¿Ÿåˆ†é…:å°±æ˜¯å½“è¿›ç¨‹ç”³è¯·å†…å­˜çš„æ—¶å€™ï¼ŒLinuxä¼šç»™ä»–å…ˆåˆ†é…é¡µï¼Œä½†æ˜¯å¹¶ä¸ä¼šåŒºå»ºç«‹é¡µä¸é¡µæ¡†çš„æ˜ å°„å…³ç³»ï¼Œä¹Ÿå°±æ˜¯å¹¶ä¸ä¼šåˆ†é…ç‰©ç†å†…å­˜ï¼Œè€Œå½“çœŸæ­£ä½¿ç”¨çš„æ—¶å€™ï¼Œå°±ä¼šäº§ç”Ÿä¸€ä¸ªç¼ºé¡µå¼‚å¸¸ï¼Œç¡¬ä»¶è·³è½¬page faultå¤„ç†ç¨‹åºæ‰§è¡Œï¼Œåœ¨å…¶ä¸­åˆ†é…ç‰©ç†å†…å­˜ï¼Œç„¶åä¿®æ”¹é¡µè¡¨(åˆ›å»ºé¡µè¡¨é¡¹)ã€‚å¼‚å¸¸å¤„ç†å®Œæ¯•ï¼Œè¿”å›ç¨‹åºç”¨æˆ·æ€ï¼Œç»§ç»­æ‰§è¡Œã€‚ Rss resident set size å®é™…åˆ†é…çš„å†…å­˜ï¼Œè¿™éƒ¨åˆ†ç‰©ç†å†…å­˜å·²ç»åˆ†é…ï¼Œä¸éœ€è¦ç¼ºé¡µä¸­æ–­å°±å¯ä»¥ä½¿ç”¨çš„ã€‚ä½†å¯èƒ½æ˜¯å’Œå…¶ä»–è¿›ç¨‹å…±äº«çš„ã€‚ è¿™é‡Œæœ‰ä¸€ä¸ªå…¬å¼è®¡ç®—Rssï¼š Rss=Shared_Clean+Shared_Dirty+Private_Clean+Private_Dirty Shared_Clean Shared_Dirty Private_Clean Private_Dirty share/privateï¼šè¡¨ç¤ºè¯¥é¡µé¢æ˜¯å…±äº«è¿˜æ˜¯ç§æœ‰ã€‚ dirty/cleanï¼š è¡¨ç¤ºè¯¥é¡µé¢æ˜¯å¦è¢«ä¿®æ”¹è¿‡ï¼Œå¦‚æœä¿®æ”¹è¿‡ï¼ˆdirtyï¼‰ï¼Œåœ¨é¡µé¢è¢«æ·˜æ±°çš„æ—¶å€™ï¼Œå°±ä¼šæŠŠè¯¥è„é¡µé¢å›å†™åˆ°äº¤æ¢åˆ†åŒº(æ¢å‡ºï¼Œswap out)ã€‚æœ‰ ä¸€ä¸ªæ ‡å¿—ä½ç”¨äºè¡¨ç¤ºé¡µé¢æ˜¯å¦dirtyã€‚ share/private_dirty/clean è®¡ç®—é€»è¾‘ï¼š æŸ¥çœ‹è¯¥pageçš„å¼•ç”¨æ•°ï¼Œå¦‚æœå¼•ç”¨&gt;1ï¼Œåˆ™å½’ä¸ºsharedï¼Œå¦‚æœæ˜¯1ï¼Œåˆ™å½’ä¸ºprivateï¼Œå†æŸ¥çœ‹è¯¥pageçš„flagï¼Œæ˜¯å¦æ ‡è®°ä¸º_PAGE_DIRTYï¼Œå¦‚æœä¸æ˜¯ï¼Œåˆ™è®¤ä¸ºå¹²å‡€çš„ Pss proportional set size å¹³æ‘Šè®¡ç®—åçš„å®é™…ç‰©ç†ä½¿ç”¨å†…å­˜(æœ‰äº›å†…å­˜ä¼šå’Œå…¶ä»–è¿›ç¨‹å…±äº«ï¼Œä¾‹å¦‚mmapè¿›æ¥çš„)ã€‚å®é™…ä¸ŠåŒ…å«ä¸Šé¢private_clean+private_dirtyï¼Œå’ŒæŒ‰æ¯”ä¾‹å‡åˆ†çš„shared_cleanã€shared_dirtyã€‚ ä¸¾ä¸ªè®¡ç®—Pssçš„ä¾‹å­ï¼š å¦‚æœè¿›ç¨‹Aæœ‰xä¸ªprivate_cleané¡µé¢ï¼Œæœ‰yä¸ªprivate_dirtyé¡µé¢ï¼Œæœ‰zä¸ªshared_cleanä»…å’Œè¿›ç¨‹Bå…±äº«ï¼Œæœ‰hä¸ªshared_dirtyé¡µé¢å’Œè¿›ç¨‹Bã€Cå…±äº«ã€‚é‚£ä¹ˆè¿›ç¨‹Açš„Pssä¸ºï¼šx + y + z/2 + h/3 Referenced å½“å‰é¡µé¢è¢«æ ‡è®°ä¸ºå·²å¼•ç”¨æˆ–è€…åŒ…å«åŒ¿åæ˜ å°„ï¼ˆThe amount of memory currently marked as referenced or a mapping associated with a file may contain anonymous pagesï¼‰ã€‚åœ¨Linuxå†…å­˜ç®¡ç†çš„é¡µé¢æ›¿æ¢ç®—æ³•ä¸­ï¼Œå½“æŸä¸ªé¡µé¢è¢«è®¿é—®åï¼ŒReferencedæ ‡å¿—è¢«è®¾ç½®ï¼Œå¦‚æœè¯¥æ ‡å¿—è®¾ç½®äº†ï¼Œå°±ä¸èƒ½å°†è¯¥é¡µç§»å‡ºã€‚ Anonymous åŒ¿åæ˜ å°„çš„ç‰©ç†å†…å­˜ï¼Œè¿™éƒ¨åˆ†å†…å­˜ä¸æ˜¯æ¥è‡ªäºæ–‡ä»¶ã€‚ VmFlags vm_areaçš„å„ç§å±æ€§ï¼Œå…·ä½“å¦‚ä¸‹ï¼š 1.3 ä¸åŒå˜é‡çš„ä½ç½® ä¸€ä¸ªåº“æ˜ å°„åˆ°å†…å­˜ï¼Œ ä¸€èˆ¬åˆ†ä¸ºä»£ç æ®µã€æ•°æ®æ®µå’Œåªè¯»æ•°æ®æ®µ r- --p: soä¸­çš„å­—ç¬¦ä¸²å¸¸æ•° rw--p: soä¸­çš„å…¨å±€å˜é‡ï¼Œé™æ€å˜é‡ r- -xp: soçš„ä»£ç æ®µï¼Œå¸¸é‡ - ---p: è¡¨ç¤ºè¯¥ VMA æ˜¯ç§æœ‰çš„ï¼Œä¸å¯æ‰§è¡Œï¼Œä¸”ä¸å¯è¯»å†™. è¿™é€šå¸¸ç”¨äºä¿æŠ¤æ•æ„Ÿæ•°æ®æˆ–ä»£ç ï¼Œé˜²æ­¢å…¶è¢«ä¿®æ”¹æˆ–æ‰§è¡Œ ä¸‹é¢è¿™æ®µä»£ç å±•ç¤ºäº†ä¸åŒå˜é‡çš„å­˜å‚¨ä½ç½®ï¼š 2.free å‘½ä»¤ free å‘½ä»¤ç”¨äºæ˜¾ç¤ºç³»ç»Ÿçš„å†…å­˜çŠ¶æ€ï¼ŒåŒ…æ‹¬ç‰©ç†å†…å­˜ã€äº¤æ¢å†…å­˜ï¼ˆswapï¼‰å’Œå†…æ ¸ç¼“å†²åŒºå†…å­˜ã€‚è¯¦ç»†è¾“å‡ºå¦‚ä¸‹ï¼š Mem è¡Œï¼ˆç¬¬äºŒè¡Œï¼‰æ˜¾ç¤ºäº†å†…å­˜çš„ä½¿ç”¨æƒ…å†µã€‚ Swapè¡Œï¼ˆç¬¬ä¸‰è¡Œï¼‰æ˜¾ç¤ºäº†äº¤æ¢ç©ºé—´çš„ä½¿ç”¨æƒ…å†µã€‚ total: è¡¨ç¤ºç³»ç»Ÿæ€»çš„å¯ç”¨ç‰©ç†å†…å­˜å’Œäº¤æ¢ç©ºé—´å¤§å°ã€‚ used : è¡¨ç¤ºå·²ç»è¢«ä½¿ç”¨çš„ç‰©ç†å†…å­˜å’Œäº¤æ¢ç©ºé—´ã€‚ free : è¡¨ç¤ºè¿˜æœ‰å¤šå°‘ç‰©ç†å†…å­˜å’Œäº¤æ¢ç©ºé—´å¯ç”¨ä½¿ç”¨ã€‚ shared: æ˜¾ç¤ºè¢«å…±äº«ä½¿ç”¨çš„ç‰©ç†å†…å­˜å¤§å°ã€‚ buff/cache: æ˜¾ç¤ºè¢« buffer å’Œ cache ä½¿ç”¨çš„ç‰©ç†å†…å­˜å¤§å°ã€‚ available: æ˜¾ç¤ºè¿˜å¯ä»¥è¢«åº”ç”¨ç¨‹åºä½¿ç”¨çš„ç‰©ç†å†…å­˜å¤§å°ã€‚ 2.1 bufferä¸cache buffer: ç¼“å†²åŒº CPU åœ¨è¿›è¡Œä¸€ç³»åˆ—æ“ä½œæ—¶ï¼Œå…ˆåœ¨å†…å­˜çš„ä¸€å—åŒºåŸŸè¿›è¡Œï¼Œä¸€ç³»åˆ—æ“ä½œå®Œæˆåï¼Œå†ä¸€æ¬¡æ€§æŠŠè¯¥å†…å­˜åŒºåŸŸæäº¤ç»™å¤–éƒ¨è®¾å¤‡ï¼Œæ¥å¯¹è¿™ä¸ªåŒºåŸŸæ“ä½œã€‚ æ¯”å¦‚å†™ä¸€å †æ•°æ®ç»™ç¡¬ç›˜ï¼Œå°±å…ˆå†™åˆ°å†…å­˜çš„ä¸€å—åŒºåŸŸï¼Œå†™å¥½åä¸€æ¬¡å†™å›åˆ°ç¡¬ç›˜ã€‚åˆæ¯”å¦‚è¯»æ•°æ®ï¼Œå…ˆåœ¨å†…å­˜åˆ’å‡ºä¸€å—åŒºåŸŸï¼Œè®©ç¡¬ç›˜æ§åˆ¶å™¨å†™æ•°æ®åˆ°è¿™å—åŒºåŸŸï¼Œå†™å¥½åï¼ŒCPU ç›´æ¥è®¿é—®è¯¥åŒºåŸŸå¾—åˆ°æ•°æ®ã€‚è¿™ä¸ªå†…å­˜åŒºåŸŸå°±å«buffer ç¼“å†²åŒºæ˜¯å†…å­˜æˆ–å­˜å‚¨çš„ä¸€éƒ¨åˆ†ï¼Œç”¨äºåœ¨ç­‰å¾…ä»è¾“å…¥è®¾å¤‡ä¼ è¾“åˆ°è¾“å‡ºè®¾å¤‡æ—¶å­˜æ”¾é¡¹ç›®ã€‚ æ“ä½œç³»ç»Ÿé€šå¸¸åœ¨æ‰“å°æ–‡æ¡£æ—¶ä½¿ç”¨ç¼“å†²åŒºã€‚è¿™ä¸ªè¿‡ç¨‹ç§°ä¸ºæ’é˜Ÿï¼ˆspoolingï¼‰ï¼Œå®ƒå°†è¦æ‰“å°çš„æ–‡æ¡£å‘é€åˆ°ç¼“å†²åŒºï¼Œè€Œä¸æ˜¯ç«‹å³å‘é€åˆ°æ‰“å°æœºã€‚å¦‚æœæ‰“å°æœºæ²¡æœ‰è‡ªå·±çš„å†…éƒ¨å­˜å‚¨å™¨ï¼Œæˆ–è€…å†…å­˜å·²æ»¡ï¼Œæ“ä½œç³»ç»Ÿçš„ç¼“å†²åŒºä¼šä¿å­˜ç­‰å¾…æ‰“å°çš„ä¿¡æ¯ï¼ŒåŒæ—¶æ‰“å°æœºä»¥è‡ªå·±çš„é€Ÿåº¦ä»ç¼“å†²åŒºæ‰“å°ã€‚ é€šè¿‡å°†æ–‡æ¡£æ’é˜Ÿåˆ°ç¼“å†²åŒºï¼Œå¤„ç†å™¨å¯ä»¥ç»§ç»­è§£é‡Šå’Œæ‰§è¡ŒæŒ‡ä»¤ï¼ŒåŒæ—¶æ‰“å°æœºè¿›è¡Œæ‰“å°ã€‚è¿™ä½¿ç”¨æˆ·å¯ä»¥åœ¨æ‰“å°æœºæ‰“å°æ—¶ç»§ç»­åœ¨è®¡ç®—æœºä¸Šè¿›è¡Œå…¶ä»–ä»»åŠ¡ã€‚å¤šä¸ªæ‰“å°ä½œä¸šåœ¨ç¼“å†²åŒºä¸­æ’é˜Ÿï¼ˆå‘éŸ³ä¸ºâ€œQâ€ï¼‰ã€‚ä¸€ä¸ªåä¸ºæ‰“å°æ’é˜Ÿç¨‹åºï¼ˆprint spoolerï¼‰çš„ç¨‹åºæ‹¦æˆªæ“ä½œç³»ç»Ÿä¸­è¦æ‰“å°çš„æ–‡æ¡£ï¼Œå¹¶å°†å…¶æ”¾å…¥é˜Ÿåˆ—ä¸­ cacheï¼šç¼“å­˜ CPU è¦è®¿é—®ä¸€å—æ•°æ®æ—¶ï¼Œé¦–å…ˆè®¿é—®å†…å­˜çš„æŸä¸ªåŒºåŸŸï¼Œçœ‹æ˜¯å¦æœ‰è¯¥æ•°æ®çš„ç¼“å­˜ï¼Œæœ‰åˆ™ç›´æ¥è®¿é—®ï¼Œæ²¡æœ‰åˆ™è®¿é—®å®ƒçš„æ¥æºåœ°ã€‚ CPU åˆ©ç”¨å†…å­˜æˆ–é«˜é€Ÿç¼“å­˜å¯¹æ•°æ®çš„å†å¤‡ä»½ï¼Œä¸ºä»¥åçš„å†æ¬¡è®¿é—®æä¾›æ–¹ä¾¿ ç¼“å­˜å¦‚ä»Šçš„å¤§å¤šæ•°è®¡ç®—æœºé€šè¿‡ç¼“å­˜ï¼ˆå‘éŸ³ä¸ºâ€œcashâ€ï¼‰æ¥æé«˜å¤„ç†é€Ÿåº¦ã€‚ ç¼“å­˜æœ‰ä¸¤ç§ä¸»è¦ç±»å‹ï¼šå†…å­˜ç¼“å­˜å’Œç£ç›˜ç¼“å­˜ã€‚è®©æˆ‘ä»¬è¯¦ç»†äº†è§£ä¸€ä¸‹å†…å­˜ç¼“å­˜ã€‚ L1 ç¼“å­˜ï¼š L1 ç¼“å­˜ç›´æ¥å†…ç½®åœ¨å¤„ç†å™¨èŠ¯ç‰‡ä¸­ã€‚ å®ƒé€šå¸¸å®¹é‡å¾ˆå°ï¼ŒèŒƒå›´ä» 8 KB åˆ° 128 KBã€‚ L1 ç¼“å­˜å­˜å‚¨ç»å¸¸ä½¿ç”¨çš„æŒ‡ä»¤å’Œæ•°æ®ï¼Œä»¥ä¾¿å¿«é€Ÿè®¿é—®ã€‚ L2 ç¼“å­˜ï¼š L2 ç¼“å­˜æ¯” L1 ç¼“å­˜ç¨æ…¢ï¼Œä½†å®¹é‡æ›´å¤§ã€‚ å®ƒçš„å¤§å°èŒƒå›´ä» 64 KB åˆ° 16 MBã€‚ ä¸€äº›ç°ä»£å¤„ç†å™¨åŒ…æ‹¬é«˜çº§ä¼ è¾“ç¼“å­˜ï¼Œè¿™æ˜¯ä¸€ç§ç›´æ¥å†…ç½®åœ¨å¤„ç†å™¨èŠ¯ç‰‡ä¸Šçš„ L2 ç¼“å­˜ç±»å‹ã€‚ ä½¿ç”¨é«˜çº§ä¼ è¾“ç¼“å­˜çš„å¤„ç†å™¨çš„æ€§èƒ½æ¯”ä¸ä½¿ç”¨å®ƒçš„å¤„ç†å™¨è¦å¿«å¾—å¤šã€‚ ç°ä»Šçš„ä¸ªäººè®¡ç®—æœºé€šå¸¸å…·æœ‰ 512 KB åˆ° 12 MB çš„é«˜çº§ä¼ è¾“ç¼“å­˜ã€‚ ç¼“å­˜é€šè¿‡å­˜å‚¨ç»å¸¸ä½¿ç”¨çš„æŒ‡ä»¤å’Œæ•°æ®æ¥æ˜¾è‘—åŠ å¿«å¤„ç†æ—¶é—´ã€‚ å½“å¤„ç†å™¨éœ€è¦ä¸€æ¡æŒ‡ä»¤æˆ–æ•°æ®æ—¶ï¼Œå®ƒæŒ‰ç…§ä»¥ä¸‹é¡ºåºæœç´¢å†…å­˜ï¼šL1 ç¼“å­˜ï¼Œç„¶åæ˜¯ L2 ç¼“å­˜ï¼Œç„¶åæ˜¯ RAMã€‚ å¦‚æœæ‰€éœ€ä¿¡æ¯åœ¨å†…å­˜ä¸­æ‰¾ä¸åˆ°ï¼Œå¤„ç†å™¨å¿…é¡»æœç´¢é€Ÿåº¦è¾ƒæ…¢çš„å­˜å‚¨ä»‹è´¨ï¼Œä¾‹å¦‚ç¡¬ç›˜æˆ–å…‰ç›˜ã€‚ 2.2. æ‰‹åŠ¨é‡Šæ”¾ç¼“å­˜ é¦–å…ˆï¼Œä½¿ç”¨syncå‘½ä»¤å°†æœªå†™å…¥ç£ç›˜çš„æ•°æ®åŒæ­¥åˆ°ç£ç›˜ï¼Œä»¥ç¡®ä¿æ–‡ä»¶ç³»ç»Ÿçš„å®Œæ•´æ€§ã€‚ ç„¶åï¼Œé€šè¿‡è®¾ç½®/proc/sys/vm/drop_cachesæ¥é‡Šæ”¾å†…å­˜ç¼“å­˜ï¼š echo 1 &gt; /proc/sys/vm/drop_cachesï¼šé‡Šæ”¾é¡µç¼“å­˜ã€‚ echo 2 &gt; /proc/sys/vm/drop_cachesï¼šé‡Šæ”¾ dentries å’Œ inodesã€‚ echo 3 &gt; /proc/sys/vm/drop_cachesï¼šé‡Šæ”¾æ‰€æœ‰ç¼“å­˜ã€‚ 3.mtrace mtrace æ˜¯ Linux ç³»ç»Ÿå†…æ ¸è‡ªå¸¦çš„ä¸€ä¸ªå†…å­˜è¿½è¸ªå‡½æ•°ã€‚å®ƒä¼šåœ¨æ¯ä¸ªå†…å­˜ç”³è¯·å‡½æ•°ï¼ˆmallocã€reallocã€callocï¼‰çš„ä½ç½®è®°å½•ä¸‹ä¿¡æ¯ï¼Œå¹¶åœ¨æ¯ä¸ªå†…å­˜é‡Šæ”¾çš„ä½ç½®è®°å½•ä¸‹ free çš„å†…å­˜ä¿¡æ¯ã€‚å…¶ä¸­åŒ…å«æœ‰å†…å­˜ç”³è¯·çš„åœ°å€ã€å†…å­˜ç”³è¯·çš„å¤§å°ã€é‡Šæ”¾å†…å­˜çš„åœ°å€ã€é‡Šæ”¾å†…å­˜çš„å¤§å°ã€‚ å…·ä½“æ¥è¯´ï¼Œmtrace å‡½æ•°çš„ä½œç”¨å¦‚ä¸‹ï¼š å®‰è£…é’©å­å‡½æ•°ï¼Œç”¨äºè·Ÿè¸ªå†…å­˜åˆ†é…å’Œé‡Šæ”¾ã€‚ è®°å½•æœ‰å…³å†…å­˜åˆ†é…å’Œé‡Šæ”¾çš„è·Ÿè¸ªä¿¡æ¯ã€‚ å¯ä»¥ç”¨äºå‘ç°ç¨‹åºä¸­çš„å†…å­˜æ³„æ¼å’Œè¯•å›¾é‡Šæ”¾æœªåˆ†é…å†…å­˜çš„æƒ…å†µã€‚ ä½¿ç”¨æ–¹å¼ï¼š åœ¨ä»£ç ä¸­åŒ…å« &lt;mcheck.h&gt; å¤´æ–‡ä»¶ã€‚ åœ¨ç¨‹åºå¯åŠ¨æ—¶è°ƒç”¨ mtrace() å‡½æ•°ï¼Œå¼€å¯å†…å­˜åˆ†é…å’Œé‡Šæ”¾è·Ÿè¸ªã€‚ ç¨‹åºç»“æŸæ—¶ï¼Œå¯ä»¥è°ƒç”¨ muntrace() å‡½æ•°å…³é—­å†…å­˜åˆ†é…å’Œé‡Šæ”¾è·Ÿè¸ªã€‚ è¿è¡Œmtraceè„šæœ¬ï¼Œåˆ†æè·Ÿè¸ªæ—¥å¿—ï¼Œç”ŸæˆæŠ¥å‘Šã€‚ è¯·æ³¨æ„ï¼Œmtrace çš„è·Ÿè¸ªè¾“å‡ºé€šå¸¸æ˜¯æ–‡æœ¬å½¢å¼ï¼Œä¸ä¸€å®šæ˜“äºäººç±»é˜…è¯»ã€‚GNU C åº“æä¾›äº†ä¸€ä¸ª Perl è„šæœ¬ mtraceï¼Œç”¨äºè§£æè·Ÿè¸ªæ—¥å¿—å¹¶ç”Ÿæˆäººç±»å¯è¯»çš„è¾“å‡ºã€‚ä¸ºäº†è·å¾—æœ€ä½³æ•ˆæœï¼Œå»ºè®®ç¼–è¯‘æ—¶å¯ç”¨è°ƒè¯•ï¼Œä»¥ä¾¿åœ¨å¯æ‰§è¡Œæ–‡ä»¶ä¸­è®°å½•è¡Œå·ä¿¡æ¯ã€‚ä¸è¿‡ï¼Œmtrace çš„è·Ÿè¸ªä¼šå¸¦æ¥æ€§èƒ½æŸè€—.å¦‚æœ MALLOC_TRACE æ²¡æœ‰æŒ‡å‘æœ‰æ•ˆä¸”å¯å†™çš„è·¯å¾„ï¼Œ åˆ™mtraceä¸ä¼šè®°å½•ä¿¡æ¯ã€‚ 4.straceä¸ltrace ltrace ç”¨äºè·Ÿè¸ªç¨‹åºçš„åº“å‡½æ•°è°ƒç”¨ï¼Œè€Œ strace åˆ™ç”¨äºè·Ÿè¸ªç³»ç»Ÿè°ƒç”¨ã€‚ å®ƒä»¬éƒ½åŸºäº ptrace ç³»ç»Ÿè°ƒç”¨ï¼Œä½†è·Ÿè¸ªåº“å‡½æ•°å’Œè·Ÿè¸ªç³»ç»Ÿè°ƒç”¨ä¹‹é—´å­˜åœ¨å·®å¼‚ã€‚ é€šè¿‡å®ƒä»¬ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å¯¹åº”ç”¨çš„å†…å­˜ç”³è¯·ã€é‡Šæ”¾è¿›è¡Œè·Ÿè¸ªã€‚ ltrace çš„å·¥ä½œåŸç†ï¼š ptrace é™„åŠ åˆ°æ­£åœ¨è¿è¡Œçš„ç¨‹åºã€‚ å®šä½ç¨‹åºçš„ PLTã€‚ ä½¿ç”¨ PTRACE_POKETEXT è®¾ç½®è½¯ä»¶æ–­ç‚¹ï¼ˆint $3 æŒ‡ä»¤ï¼‰è¦†ç›–åº“å‡½æ•°çš„ PLT ä¸­çš„æ±‡ç¼– trampolineã€‚ æ¢å¤ç¨‹åºæ‰§è¡Œã€‚ strace åº”è¯¥ä¹Ÿæ˜¯ç›¸ç±»ä¼¼çš„å·¥ä½œåŸç† 4.1 strace strace æ˜¯ä¸€ä¸ªå¼ºå¤§çš„ Linux å‘½ä»¤ï¼Œç”¨äºè¯Šæ–­ã€è°ƒè¯•å’Œç»Ÿè®¡ã€‚å®ƒå…è®¸æ‚¨è·Ÿè¸ªæ­£åœ¨è¿è¡Œçš„ç¨‹åºçš„ç³»ç»Ÿè°ƒç”¨å’Œæ¥æ”¶çš„ä¿¡å·ã€‚ä¸‹é¢æ˜¯ä¸€äº›å…³äº strace çš„å‚æ•°ä½¿ç”¨æ–¹æ³•ã€‚ -cï¼šç»Ÿè®¡æ¯ä¸ªç³»ç»Ÿè°ƒç”¨çš„æ‰§è¡Œæ—¶é—´ã€æ¬¡æ•°å’Œé”™è¯¯æ¬¡æ•°ã€‚ ç¤ºä¾‹ï¼šæ‰“å°æ‰§è¡Œ uptime æ—¶ç³»ç»Ÿè°ƒç”¨çš„æ—¶é—´ã€æ¬¡æ•°å’Œé”™è¯¯æ¬¡æ•°ï¼š strace -c uptime -fï¼šè·Ÿè¸ªå­è¿›ç¨‹ï¼Œè¿™äº›å­è¿›ç¨‹æ˜¯ç”±å½“å‰è·Ÿè¸ªçš„è¿›ç¨‹åˆ›å»ºçš„ã€‚ -iï¼šåœ¨ç³»ç»Ÿè°ƒç”¨æ—¶æ‰“å°æŒ‡ä»¤æŒ‡é’ˆã€‚ -tï¼šè·Ÿè¸ªçš„æ¯ä¸€è¡Œéƒ½ä»¥æ—¶é—´ä¸ºå‰ç¼€ã€‚ -ttï¼šå¦‚æœç»™å‡ºä¸¤æ¬¡ï¼Œåˆ™æ‰“å°æ—¶é—´å°†åŒ…æ‹¬å¾®ç§’ã€‚ -tttï¼šå¦‚æœç»™å®šä¸‰æ¬¡ï¼Œåˆ™æ‰“å°æ—¶é—´å°†åŒ…æ‹¬å¾®ç§’ï¼Œå¹¶ä¸”å‰å¯¼éƒ¨åˆ†å°†æ‰“å°ä¸ºè‡ªå¯åŠ¨ä»¥æ¥çš„ç§’æ•°ã€‚ -Tï¼šæ˜¾ç¤ºèŠ±è´¹åœ¨ç³»ç»Ÿè°ƒç”¨ä¸Šçš„æ—¶é—´ã€‚ é™å®šè¡¨è¾¾å¼ï¼š -e trace=setï¼šä»…è·Ÿè¸ªæŒ‡å®šçš„ç³»ç»Ÿè°ƒç”¨é›†ã€‚ä¾‹å¦‚ï¼Œtrace=open,close,read,write è¡¨ç¤ºä»…è·Ÿè¸ªè¿™å››ä¸ªç³»ç»Ÿè°ƒç”¨ã€‚ -e trace=fileï¼šè·Ÿè¸ªæ‰€æœ‰ä»¥æ–‡ä»¶åä½œä¸ºå‚æ•°çš„ç³»ç»Ÿè°ƒç”¨ã€‚ç¤ºä¾‹ï¼šæ‰“å°æ‰§è¡Œ ls æ—¶ä¸æ–‡ä»¶æœ‰å…³çš„ç³»ç»Ÿè°ƒç”¨ï¼š strace -e trace=file ls -e trace=processï¼šè·Ÿè¸ªæ¶‰åŠè¿›ç¨‹ç®¡ç†çš„æ‰€æœ‰ç³»ç»Ÿè°ƒç”¨ã€‚ -e trace=networkï¼šè·Ÿè¸ªæ‰€æœ‰ä¸ç½‘ç»œç›¸å…³çš„ç³»ç»Ÿè°ƒç”¨ã€‚ -e trace=signalï¼šè·Ÿè¸ªæ‰€æœ‰ä¸ä¿¡å·ç›¸å…³çš„ç³»ç»Ÿè°ƒç”¨ã€‚ -e trace=ipcï¼šè·Ÿè¸ªæ‰€æœ‰ä¸ IPC ç›¸å…³çš„ç³»ç»Ÿè°ƒç”¨ã€‚ -e trace=memoryï¼šè·Ÿè¸ªæ‰€æœ‰ä¸ momory ç›¸å…³çš„ç³»ç»Ÿè°ƒç”¨ã€‚ å…¶ä»–å‚æ•°ï¼š -o æ–‡ä»¶åï¼šå°†è·Ÿè¸ªè¾“å‡ºå†™å…¥æ–‡ä»¶è€Œä¸æ˜¯ stderrã€‚ -p pidï¼šä½¿ç”¨è¿›ç¨‹ ID pid é™„åŠ åˆ°è¯¥è¿›ç¨‹å¹¶å¼€å§‹è·Ÿè¸ª ä¸‹é¢æ˜¯è¿è¡Œ strace ls çš„è¾“å‡º 4.2 ltrace ltrace æ˜¯ä¸€ä¸ªç”¨äºè·Ÿè¸ªç¨‹åºåº“è°ƒç”¨çš„ Linux å·¥å…·ã€‚å®ƒå¯ä»¥æ‹¦æˆªå¹¶è®°å½•è¢«æ‰§è¡Œè¿›ç¨‹è°ƒç”¨çš„åŠ¨æ€åº“å‡½æ•°ï¼Œä»¥åŠè¯¥è¿›ç¨‹æ¥æ”¶åˆ°çš„ä¿¡å·ã€‚æ­¤å¤–ï¼Œltrace è¿˜å¯ä»¥æ‹¦æˆªå¹¶æ‰“å°ç¨‹åºæ‰§è¡Œçš„ç³»ç»Ÿè°ƒç”¨ã€‚ å¸¸ç”¨å‚æ•°å’Œç¤ºä¾‹ï¼š -cï¼šç»Ÿè®¡æ¯ä¸ªç³»ç»Ÿè°ƒç”¨çš„æ‰§è¡Œæ—¶é—´ã€æ¬¡æ•°å’Œé”™è¯¯æ¬¡æ•°ã€‚ ç¤ºä¾‹ï¼šæ‰“å°æ‰§è¡Œ uptime æ—¶ç³»ç»Ÿè°ƒç”¨çš„æ—¶é—´ã€æ¬¡æ•°å’Œé”™è¯¯æ¬¡æ•°ï¼š ltrace -c uptime -fï¼šè·Ÿè¸ªå­è¿›ç¨‹ï¼Œè¿™äº›å­è¿›ç¨‹æ˜¯ç”±å½“å‰è·Ÿè¸ªçš„è¿›ç¨‹åˆ›å»ºçš„ã€‚ -iï¼šåœ¨ç³»ç»Ÿè°ƒç”¨æ—¶æ‰“å°æŒ‡ä»¤æŒ‡é’ˆã€‚ -tï¼šè·Ÿè¸ªçš„æ¯ä¸€è¡Œéƒ½ä»¥æ—¶é—´ä¸ºå‰ç¼€ã€‚ -ttï¼šå¦‚æœç»™å‡ºä¸¤æ¬¡ï¼Œåˆ™æ‰“å°æ—¶é—´å°†åŒ…æ‹¬å¾®ç§’ã€‚ -tttï¼šå¦‚æœç»™å®šä¸‰æ¬¡ï¼Œåˆ™æ‰“å°æ—¶é—´å°†åŒ…æ‹¬å¾®ç§’ï¼Œå¹¶ä¸”å‰å¯¼éƒ¨åˆ†å°†æ‰“å°ä¸ºè‡ªå¯åŠ¨ä»¥æ¥çš„ç§’æ•°ã€‚ -Tï¼šæ˜¾ç¤ºèŠ±è´¹åœ¨ç³»ç»Ÿè°ƒç”¨ä¸Šçš„æ—¶é—´ã€‚ é™å®šè¡¨è¾¾å¼ï¼š -e trace=setï¼šä»…è·Ÿè¸ªæŒ‡å®šçš„ç³»ç»Ÿè°ƒç”¨é›†ã€‚ä¾‹å¦‚ï¼Œtrace=open,close,read,write è¡¨ç¤ºä»…è·Ÿè¸ªè¿™å››ä¸ªç³»ç»Ÿè°ƒç”¨ã€‚ -e trace=fileï¼šè·Ÿè¸ªæ‰€æœ‰ä»¥æ–‡ä»¶åä½œä¸ºå‚æ•°çš„ç³»ç»Ÿè°ƒç”¨ã€‚ç¤ºä¾‹ï¼šæ‰“å°æ‰§è¡Œ ls æ—¶ä¸æ–‡ä»¶æœ‰å…³çš„ç³»ç»Ÿè°ƒç”¨ï¼š ltrace -e trace=file ls -e trace=processï¼šè·Ÿè¸ªæ¶‰åŠè¿›ç¨‹ç®¡ç†çš„æ‰€æœ‰ç³»ç»Ÿè°ƒç”¨ã€‚ -e trace=networkï¼šè·Ÿè¸ªæ‰€æœ‰ä¸ç½‘ç»œç›¸å…³çš„ç³»ç»Ÿè°ƒç”¨ã€‚ -e trace=signalï¼šè·Ÿè¸ªæ‰€æœ‰ä¸ä¿¡å·ç›¸å…³çš„ç³»ç»Ÿè°ƒç”¨ã€‚ -e trace=ipcï¼šè·Ÿè¸ªæ‰€æœ‰ä¸ IPC ç›¸å…³çš„ç³»ç»Ÿè°ƒç”¨ã€‚ å…¶ä»–å‚æ•°ï¼š -o æ–‡ä»¶åï¼šå°†è·Ÿè¸ªè¾“å‡ºå†™å…¥æ–‡ä»¶è€Œä¸æ˜¯ stderrã€‚ -p pidï¼šä½¿ç”¨è¿›ç¨‹ ID pid é™„åŠ åˆ°è¯¥è¿›ç¨‹å¹¶å¼€å§‹è·Ÿè¸ªã€‚ ä¸‹é¢æ˜¯è¿è¡Œ ltrace ls çš„è¾“å‡º"
  },"/blog/graphic/2018-03-21-YUV.html": {
    "title": "YUVç¼–ç ",
    "keywords": "graphic",
    "url": "/blog/graphic/2018-03-21-YUV.html",
    "body": "1.ç®€ä»‹ YUVæ•°æ®ç”±Yã€Uã€Vä¸‰ä¸ªåˆ†é‡ç»„æˆï¼Œç°åœ¨é€šå¸¸è¯´çš„YUVæŒ‡çš„æ˜¯YCbCrã€‚ Yï¼šè¡¨ç¤ºäº®åº¦ï¼ˆLuminanceã€Lumaï¼‰ï¼Œå 8bitï¼ˆ1å­—èŠ‚ï¼‰ Cbã€Crï¼šè¡¨ç¤ºè‰²åº¦ï¼ˆChrominanceã€Chromaï¼‰ Cbï¼ˆUï¼‰ï¼šè“è‰²è‰²åº¦åˆ†é‡ï¼Œå 8bitï¼ˆ1å­—èŠ‚ï¼‰ Crï¼ˆVï¼‰ï¼šçº¢è‰²è‰²åº¦åˆ†é‡ï¼Œå 8bitï¼ˆ1å­—èŠ‚ï¼‰ 2.é‡‡æ ·æ–¹å¼(444, 422, 420çš„åŒºåˆ«) æŠŠYã€Uã€Væ•°æ®è½¬å˜ä¸ºRã€Gã€Bæ—¶ç”¨åˆ° 2.1 é‡‡æ ·æ–¹å¼ é‡‡æ ·æ–¹å¼é€šå¸¸ç”¨A:B:Cçš„å½¢å¼æ¥è¡¨ç¤ºï¼Œæ¯”å¦‚4:4:4ã€4:2:2ã€4:2:0ç­‰ Aï¼šå‡å®šåœ¨ä¸€å—A*2ä¸ªåƒç´ çš„æ¦‚å¿µåŒºåŸŸï¼Œä¸€èˆ¬éƒ½æ˜¯4. Bï¼šç¬¬1è¡Œçš„è‰²åº¦(UV)é‡‡æ ·æ•°ç›®ã€‚ Cï¼šç¬¬2è¡Œçš„è‰²åº¦(UV)é‡‡æ ·æ•°ç›® æ‰€ä»¥è¿™é‡Œçš„B,CæŒ‡çš„åˆ†åˆ«æ˜¯åœ¨ç¬¬ä¸€è¡Œï¼Œç¬¬äºŒè¡ŒUVé‡‡æ ·çš„æ•°ç›®ã€‚ Cçš„å€¼ä¸€èˆ¬è¦ä¹ˆç­‰äºBï¼Œè¦ä¹ˆç­‰äº0 ç¤ºæ„å›¾1ï¼š ç¤ºæ„å›¾2 ä¸Šå›¾ä¸­ï¼Œä¸ç®¡æ˜¯å“ªç§é‡‡æ ·æ ¼å¼ï¼ŒYåˆ†é‡éƒ½æ˜¯å…¨æ°´å¹³ã€å…¨å‚ç›´åˆ†è¾¨ç‡é‡‡æ ·çš„ï¼Œæ¯ä¸€ä¸ªåƒç´ éƒ½æœ‰è‡ªå·±ç‹¬ç«‹çš„Yåˆ†é‡ 2.2 å ç”¨å­—èŠ‚æ•° ç”±ä¸Šå¯ä»¥æ¨ç®—å‡ºä¸åŒé‡‡æ ·æ–¹å¼ä¸‹æ¯ä¸ªåƒç´ éœ€è¦çš„å¹³å‡å­—èŠ‚æ•°ã€‚ 4:4:4 ä¸€ä¸ªåƒç´ YUVå„å ä¸€ä¸ªå­—èŠ‚ï¼Œæ€»å…±3ä¸ªå­—èŠ‚ 24bit 4:2:2 8ä¸ªåƒç´  ï¼š 8ä¸ªY + 2ä¸ªU +2ä¸ªV +2ä¸ªU +2ä¸ªV = 16å­—èŠ‚ æ¯ä¸ªåƒç´ ï¼š16å­—èŠ‚/8 = 2ä¸ªå­—èŠ‚ 16bit 4:2:0 8ä¸ªåƒç´  ï¼š 8ä¸ªY + 2ä¸ªU +2ä¸ªV = 12å­—èŠ‚ æ¯ä¸ªåƒç´ ï¼š12å­—èŠ‚/8 = 1.5ä¸ªå­—èŠ‚ 12bit 3.å­˜å‚¨æ–¹å¼(Planar, Semi-Planarå’ŒPackedçš„åŒºåˆ«) å­˜å‚¨æ ¼å¼ï¼Œè¡¨ç¤ºçš„æ˜¯Yã€Uã€Væ•°æ®æ˜¯å¦‚ä½•æ’åˆ—å’Œå­˜å‚¨çš„ã€‚ è¯»å–æˆ–å†™å…¥Yã€Uã€Væ•°æ®æ—¶ç”¨åˆ°. 3.1 åˆ†ç±» YUVçš„å­˜å‚¨æ ¼å¼å¯ä»¥åˆ†ä¸º3å¤§ç±»ï¼š åç§° ç‰¹ç‚¹ Planar(å¹³é¢) Yã€Uã€Våˆ†é‡åˆ†å¼€å•ç‹¬å­˜å‚¨,åç§°é€šå¸¸ä»¥å­—æ¯pç»“å°¾, 3ä¸ªplanar Semi-Planarï¼ˆåŠå¹³é¢ï¼‰ Yåˆ†é‡å•ç‹¬å­˜å‚¨ï¼ŒUã€Våˆ†é‡äº¤é”™å­˜å‚¨, åç§°é€šå¸¸ä»¥å­—æ¯spç»“å°¾, 1ä¸ªplanar Packedï¼ˆç´§å‡‘ï¼‰ æˆ–è€…å«Interleaved(äº¤é”™), Yã€Uã€Våˆ†é‡äº¤é”™å­˜å‚¨, 1ä¸ªplanar 3.2 444 I444 å’ŒYV24 ä¸»è¦æ˜¯UVæ¬¡åºçš„ä¸åŒ semi-planar NV24 å’ŒNV42 ä¸»è¦æ˜¯UVäº¤æ›¿æ¬¡åºçš„ä¸åŒ 3.3 422 Planar I422 YV16 åŒºåˆ«ï¼šVU æ¬¡åº Semi-Planar NV16 NV61 åŒºåˆ«ï¼šVU æ¬¡åº Packed UYVY YUYV YVYU åŒºåˆ«ï¼šVU æ¬¡åº 3.4 420 Planar I420 YV12 é‡‡æ ·æ–¹å¼420 I420ï¼Œåƒç´ ç¤ºæ„å›¾ Semi-Planar NV12 NV21 é‡‡æ ·æ–¹å¼420ï¼Œå„ç§å­˜å‚¨æ–¹å¼ï¼Œ åƒç´ ç¤ºæ„å›¾ 4.å€ŸåŠ©ffmpegæ ¼å¼è½¬æ¢ PNG -&gt; YUV ffmpeg -i in.png -s 512x512 -pix_fmt yuv420p out.yuv YUV -&gt; PNG ffmpeg -s 512x512 -pix_fmt yuv420p -i in.yuv out.jpg YUV æ–‡ä»¶åªæ˜¯å­˜å‚¨æ•°æ®çš„æ–‡ä»¶ï¼Œæ²¡æœ‰å¤§å°ä¿¡æ¯ï¼Œæ‰€ä»¥è½¬æ¢æ—¶ä¸€å®šè¦ç»™å‡ºå®ƒçš„å°ºå¯¸ PNG æ–‡ä»¶å«æœ‰å°ºå¯¸ä¿¡æ¯ï¼Œæ‰€ä»¥è½¬YUVæ—¶å¯ä»¥ä¸æŒ‡å®šå¤§å°ï¼Œé»˜è®¤åŸå¤§å° 5.å€ŸåŠ©ffplayæ˜¾ç¤ºYUV å¯ä»¥é€šè¿‡ffplayæ˜¾ç¤ºYUVæ•°æ®ã€‚ YUVä¸­ç›´æ¥å­˜å‚¨çš„æ˜¯æ‰€æœ‰åƒç´ çš„é¢œè‰²ä¿¡æ¯ï¼ˆå¯ä»¥ç†è§£ä¸ºæ˜¯å›¾åƒçš„ä¸€ç§åŸå§‹æ•°æ®ï¼‰ å¿…é¡»å¾—è®¾ç½®YUVçš„å°ºå¯¸ï¼ˆ-sï¼‰ã€åƒç´ æ ¼å¼ï¼ˆ-pix_fmtï¼‰æ‰èƒ½æ­£å¸¸æ˜¾ç¤º ffplay -s 512x512 -pix_fmt yuv420p in.yuv # åœ¨ffplayä¸­ # -så·²ç»è¿‡æœŸï¼Œå»ºè®®æ”¹ä¸ºï¼š-video_size # -pix_fmtå·²ç»è¿‡æœŸï¼Œå»ºè®®æ”¹ä¸ºï¼š-pixel_format ffplay -video_size 512x512 -pixel_format yuv420p in.yuv 6.GLSLå®ç°YUVè½¬RGBA 6.1 åŸºæœ¬è®¡ç®—å…¬å¼ æ ¹æ®çš„æ ‡å‡†ä¸åŒï¼Œæœ‰ä¸åŒçš„è®¡ç®—å…¬å¼ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªå¯ä»¥åœ¨shaderä¸­ä½¿ç”¨çš„è®¡ç®—æ–¹æ³•ã€‚ åªè¦å…ˆå¾—åˆ°Y,U,Vï¼Œ å°±å¯ä»¥æŒ‰ä¸‹é¢æ–¹æ³•è½¬æ¢RGB \" yuv.y = yuv.y - 0.5; \\n\" \" yuv.z = yuv.z - 0.5; \\n\" \" \\n\" \" rgb.r = yuv.x + 1.402 * yuv.z; \\n\" \" rgb.g = yuv.x - 0.34413 * yuv.y - 0.71414 * yuv.z; \\n\" \" rgb.b = yuv.x + 1.772 * yuv.y; \\n\" YUVåˆ°RGBAçš„è½¬æ¢å…¶å®å°±ä¸¤ä¸ªè¦ç‚¹ æ„å»ºåˆé€‚çš„çº¹ç† åœ¨shaderä¸­æå‰YUV 6.2 YUV444P-&gt;ARGB 6.2.1 æ„å»ºçº¹ç† static GLuint build_texture_4_yuv444p(int width, int height, void *data){ GLuint texture; glGenTextures(1, &amp;texture); glBindTexture(GL_TEXTURE_2D, texture); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexImage2D(GL_TEXTURE_2D, 0, GL_RED, width, height, 0, GL_RED, GL_UNSIGNED_BYTE, data); glBindTexture(GL_TEXTURE_2D, 0); return texture; } 6.2.2 åœ¨shaderä¸­æå–YUV static const char* yuv444_2_rgba_frag_src = \"uniform sampler2D Sampler; \\n\" \"varying highp vec2 TexCoord; \\n\" \"void main (void) \\n\" \"{ \\n\" \" highp vec3 yuv; \\n\" \" highp vec3 rgb; \\n\" \" yuv.x = texture2D(Sampler, TexCoord).r; \\n\" \" yuv.y = texture2D(Sampler, vec2(TexCoord.x, TexCoord.y+0.3333333)).r;\\n\" \" yuv.z = texture2D(Sampler, vec2(TexCoord.x, TexCoord.y+0.6666667)).r;\\n\" \" \\n\" \" yuv.y = yuv.y - 0.5; \\n\" \" yuv.z = yuv.z - 0.5; \\n\" // çŸ©é˜µè®¡ç®—æ–¹æ³• \" rgb = mat3( \\n\" \"1, 1, 1, \\n\" \"0, -.34413, 1.772, \\n\" \"1.402, -.71414, 0 \\n\" \" ) * yuv; \\n\" \" \\n\" \" gl_FragColor = vec4(rgb, 1.0); \\n\" \"} \\n\"; 6.3 NV24-&gt;ARGB 6.3.1 æ„å»ºçº¹ç† è¿™é‡Œéœ€è¦æ„å»ºä¸¤ä¸ªçº¹ç†ï¼Œä¸€ä¸ªæ˜¯Yçš„çº¹ç†ï¼Œ ä¸€ä¸ªæ˜¯UVçš„çº¹ç† static GLuint build_texture_4_nv24_y(int width, int height, void *y_data){ GLuint texture; glGenTextures(1, &amp;texture); glBindTexture(GL_TEXTURE_2D, texture); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexImage2D(GL_TEXTURE_2D, 0, GL_LUMINANCE, width, height, 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, y_data); glBindTexture(GL_TEXTURE_2D, 0); return texture; } static GLuint build_texture_4_nv24_uv(int width, int height, void *uv_data){ GLuint texture; glGenTextures(1, &amp;texture); glBindTexture(GL_TEXTURE_2D, texture); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexImage2D(GL_TEXTURE_2D, 0, GL_LUMINANCE_ALPHA, width, height, 0, GL_LUMINANCE_ALPHA, GL_UNSIGNED_BYTE, uv_data); glBindTexture(GL_TEXTURE_2D, 0); return texture; } 6.3.2 åœ¨shaderä¸­æå–YUV static const char* nv24_2_rgba_frag_src = \"uniform sampler2D Sampler_y; \\n\" \"uniform sampler2D Sampler_uv; \\n\" \"varying highp vec2 TexCoord; \\n\" \"void main (void) \\n\" \"{ \\n\" \" highp vec3 yuv; \\n\" \" highp vec3 rgb; \\n\" \" \\n\" \" yuv.x = texture2D(Sampler_y, TexCoord).r; \\n\" \" yuv.y = texture2D(Sampler_uv, TexCoord).r; \\n\" \" yuv.z = texture2D(Sampler_uv, TexCoord).a; \\n\" \" \\n\" \" yuv.y = yuv.y - 0.5; \\n\" \" yuv.z = yuv.z - 0.5; \\n\" \" \\n\" \" rgb.r = yuv.x + 1.402 * yuv.z; \\n\" \" rgb.g = yuv.x - 0.34413 * yuv.y - 0.71414 * yuv.z; \\n\" \" rgb.b = yuv.x + 1.772 * yuv.y; \\n\" \" \\n\" \" gl_FragColor = vec4(rgb, 1.0); \\n\" \"} \\n\"; 6.4 NV16-&gt;ARGB 6.4.1 æ„å»ºçº¹ç† è¿™é‡Œéœ€è¦æ„å»ºä¸¤ä¸ªçº¹ç†ï¼Œä¸€ä¸ªæ˜¯Yçš„çº¹ç†ï¼Œ ä¸€ä¸ªæ˜¯UVçš„çº¹ç† static GLuint build_texture_4_nv16_y(int width, int height, void *data){ GLuint texture; glGenTextures(1, &amp;texture); glBindTexture(GL_TEXTURE_2D, texture); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexImage2D(GL_TEXTURE_2D, 0, GL_LUMINANCE, width, height, 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, data); glBindTexture(GL_TEXTURE_2D, 0); return texture; } æ³¨æ„glTexImage2D()çš„ç¬¬å››å‚æ•°å€¼å‘ç”Ÿäº†å˜åŒ– static GLuint build_texture_4_nv16_uv(int width, int height, void *data){ GLuint texture; glGenTextures(1, &amp;texture); glBindTexture(GL_TEXTURE_2D, texture); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexImage2D(GL_TEXTURE_2D, 0, GL_LUMINANCE_ALPHA, width/2, height, 0, GL_LUMINANCE_ALPHA, GL_UNSIGNED_BYTE, data); glBindTexture(GL_TEXTURE_2D, 0); return texture; } 6.4.2 åœ¨shaderä¸­æå–YUV ä¸NV24æ–¹æ³•ç›¸åŒ 6.5 NV12-&gt;ARGB 6.5.1 æ„å»ºçº¹ç† è¿™é‡Œéœ€è¦æ„å»ºä¸¤ä¸ªçº¹ç†ï¼Œä¸€ä¸ªæ˜¯Yçš„çº¹ç†ï¼Œ ä¸€ä¸ªæ˜¯UVçš„çº¹ç† static GLuint build_texture_4_nv12_y(int width, int height, void *data){ GLuint texture; glGenTextures(1, &amp;texture); glBindTexture(GL_TEXTURE_2D, texture); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexImage2D(GL_TEXTURE_2D, 0, GL_LUMINANCE, width, height, 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, data); glBindTexture(GL_TEXTURE_2D, 0); return texture; } æ³¨æ„glTexImage2D()çš„ç¬¬å››,äº”å‚æ•°å€¼å‘ç”Ÿäº†å˜åŒ– static GLuint build_texture_4_nv12_uv(int width, int height, void *data){ GLuint texture; glGenTextures(1, &amp;texture); glBindTexture(GL_TEXTURE_2D, texture); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); CHK_GL_ERR(); glTexImage2D(GL_TEXTURE_2D, 0, GL_LUMINANCE_ALPHA, width/2, height/2, 0, GL_LUMINANCE_ALPHA, GL_UNSIGNED_BYTE, data); CHK_GL_ERR(); glBindTexture(GL_TEXTURE_2D, 0); return texture; } 6.5.2 åœ¨shaderä¸­æå–YUV ä¸NV24æ–¹æ³•ç›¸åŒ 6.6 ç›´æ¥æå–YUVæ•°æ® static const char* yuv420_frag_src = \"#version 300 es \\n\" \"#extension GL_OES_EGL_image_external_essl3 : enable \\n\" \"#extension GL_EXT_YUV_target : enable \\n\" \"precision mediump float; \\n\" \"uniform __samplerExternal2DY2YEXT uTexSampler; \\n\" \"in vec2 varTexCoord; \\n\" \"out vec4 rgb; \\n\" \"void main() \\n\" \"{ \\n\" \" vec4 yuv = texture(uTexSampler, varTexCoord); \\n\" \" yuv.y = yuv.y - 0.5; \\n\" \" yuv.z = yuv.z - 0.5; \\n\" \" \\n\" \" rgb.r = yuv.x + 1.402 * yuv.z; \\n\" \" rgb.g = yuv.x - 0.34413 * yuv.y - 0.71414 * yuv.z; \\n\" \" rgb.b = yuv.x + 1.772 * yuv.y; \\n\" \" rgb.a = 1.0; \\n\" \"} \\n\";"
  },"/blog/jekyll/2013-03-02-cobalt.html": {
    "title": "Cobalt",
    "keywords": "Jekyll",
    "url": "/blog/jekyll/2013-03-02-cobalt.html",
    "body": "Starboard åœ¨ Cobalt çš„ä¸Šä¸‹æ–‡ä¸­ï¼ŒStarboard æ˜¯ä¸€ä¸ªé‡è¦çš„æ¦‚å¿µã€‚è®©æˆ‘ä¸ºä½ è§£é‡Šä¸€ä¸‹ï¼š Starboard æ˜¯ä»€ä¹ˆï¼Ÿ Starboard æ˜¯ Cobalt çš„ä¸€ä¸ªå…³é”®ç»„ä»¶ï¼Œç”¨äºæŠ½è±¡æ“ä½œç³»ç»ŸåŠŸèƒ½å’Œå¹³å°ç‰¹æ€§ï¼Œä½¿å…¶èƒ½å¤Ÿåœ¨ä¸åŒå¹³å°ä¸Šè¿è¡Œã€‚ å®ƒæ˜¯ä¸€ä¸ªç”¨äºç§»æ¤çš„æŠ½è±¡å±‚ï¼ŒåŒ…å«äº†ä¸€ç³»åˆ—ç”¨äºå¤„ç†ä¸åŒæ“ä½œç³»ç»Ÿå’Œå¹³å°ç‰¹æ€§çš„å®ç°ç‰‡æ®µã€‚ Starboard çš„ç›®æ ‡æ˜¯å°† Cobalt ä¸åº•å±‚æ“ä½œç³»ç»Ÿå’Œç¡¬ä»¶éš”ç¦»å¼€æ¥ï¼Œä½¿ Cobalt èƒ½å¤Ÿåœ¨ä¸åŒè®¾å¤‡ä¸Šæ— ç¼è¿è¡Œã€‚ å¦‚ä½•ä½¿ç”¨ Starboardï¼Ÿ åœ¨ Cobalt çš„æºä»£ç ä¸­ï¼Œä½ ä¼šçœ‹åˆ° Starboard çš„ç›¸å…³ç›®å½•å’Œæ–‡ä»¶ï¼Œè¿™äº›æ–‡ä»¶åŒ…å«äº†ç‰¹å®šå¹³å°çš„å®ç°ç»†èŠ‚ã€‚ Starboard å°†å¹³å°ç‰¹å®šçš„åŠŸèƒ½å°è£…åœ¨è¿™äº›æ–‡ä»¶ä¸­ï¼Œä»¥ä¾¿ Cobalt å¯ä»¥åœ¨ä¸åŒå¹³å°ä¸Šè¿è¡Œã€‚ Starboard çš„è®¾è®¡ç›®æ ‡æ˜¯åªåŒ…å« Cobalt å®é™…ä½¿ç”¨çš„å¹³å°ç‰¹å®šåŠŸèƒ½ï¼Œè€Œä¸åŒ…å«ä¸å¿…è¦çš„éƒ¨åˆ†ã€‚ æ€»ä¹‹ï¼ŒStarboard æ˜¯ Cobalt çš„ä¸€ä¸ªå…³é”®ç»„ä»¶ï¼Œç”¨äºå¤„ç†æ“ä½œç³»ç»Ÿå’Œå¹³å°å·®å¼‚ï¼Œä½¿ Cobalt èƒ½å¤Ÿåœ¨ä¸åŒè®¾å¤‡ä¸Šè¿è¡Œã€‚ 360 Video åœ¨Youtube video 360ä¸­æ¶‰åŠåˆ°çš„å‡ ä¸ªå‡½æ•°åŠæµç¨‹ï¼š A Video Frame, å®ƒå°†è¢«æ¸²æŸ“åˆ°ä¸€ä¸ªçƒé¢ä¸Šã€‚ Skia Skia æ˜¯ä¸€ä¸ªå¼€æºçš„ 2D å›¾å½¢åº“ï¼Œå®ƒæä¾›äº†é€šç”¨çš„ APIï¼Œå¯ä»¥åœ¨å„ç§ç¡¬ä»¶å’Œè½¯ä»¶å¹³å°ä¸Šä½¿ç”¨ã€‚å®ƒä½œä¸º Google Chrome å’Œ ChromeOSã€Androidã€Flutter ç­‰äº§å“çš„å›¾å½¢å¼•æ“123ã€‚ Skia æ˜¯ç”¨ C++ ç¼–å†™çš„å®Œæ•´çš„ 2D å›¾å½¢åº“ï¼Œç”¨äºç»˜åˆ¶æ–‡æœ¬ã€å‡ ä½•å›¾å½¢å’Œå›¾åƒã€‚ å®ƒæŠ½è±¡äº†å¹³å°ç‰¹å®šçš„å›¾å½¢ APIï¼ˆè¿™äº› API åœ¨ä¸åŒå¹³å°ä¹‹é—´æœ‰æ‰€ä¸åŒï¼‰ã€‚ æœ€åˆç”± Skia Inc. å¼€å‘ï¼Œåæ¥äº 2005 å¹´è¢« Google æ”¶è´­ï¼Œå¹¶äº 2008 å¹´ä»¥ New BSD è‡ªç”±è½¯ä»¶è®¸å¯è¯ çš„å½¢å¼å‘å¸ƒä¸ºå¼€æºè½¯ä»¶3ã€‚ egl opengl cobalt ä¸­egl opengl APIçš„è·Ÿè¸ª cobalt/renderer/egl_and_gles.h cobalt/renderer/rasterizer/egl/graphics_state.cc cobaltä¸­wayland SbWindowPrivate::SbWindowPrivate(wl_compositor* compositor, wl_shell* shell, const SbWindowOptions* options, float pixel_ratio) { width = kWindowWidth; height = kWindowHeight; video_pixel_ratio = pixel_ratio; if (options &amp;&amp; options-&gt;size.width &gt; 0 &amp;&amp; options-&gt;size.height &gt; 0) { width = options-&gt;size.width; height = options-&gt;size.height; } surface = wl_compositor_create_surface(compositor); shell_surface = wl_shell_get_shell_surface(shell, surface); wl_shell_surface_add_listener(shell_surface, &amp;shell_surface_listener, this); wl_shell_surface_set_title(shell_surface, \"cobalt\"); struct wl_region* region; region = wl_compositor_create_region(compositor); wl_region_add(region, 0, 0, width, height); wl_surface_set_opaque_region(surface, region); wl_region_destroy(region); egl_window = wl_egl_window_create(surface, width, height); WindowRaise(); }"
  },"/blog/jekyll/2003-08-20-OpenGL_misc.html": {
    "title": "OpenGL",
    "keywords": "Jekyll",
    "url": "/blog/jekyll/2003-08-20-OpenGL_misc.html",
    "body": "glInvalidateFramebuffer vs glClear glInvalidateFramebuffer å’Œ glClear æ˜¯OpenGLä¸­ä¸¤ä¸ªä¸åŒçš„å‡½æ•°ï¼Œå®ƒä»¬çš„ä½œç”¨å’Œç”¨æ³•æœ‰æ‰€ä¸åŒï¼š glInvalidateFramebufferï¼š åŠŸèƒ½ï¼šglInvalidateFramebuffer ç”¨äºæ˜¾å¼åœ°æ ‡è®°å¸§ç¼“å†²åŒºçš„æŸäº›éƒ¨åˆ†ä¸ºæ— æ•ˆã€‚è¿™æ ·ï¼ŒGPUå°±çŸ¥é“è¿™äº›éƒ¨åˆ†çš„å†…å®¹ä¸å†éœ€è¦ï¼Œå¯ä»¥é¿å…ä¸å¿…è¦çš„æ•°æ®äº¤æ¢ã€‚ åº”ç”¨åœºæ™¯ï¼šé€šå¸¸åœ¨ä½¿ç”¨å¸§ç¼“å†²åŒºå¯¹è±¡ï¼ˆFBOï¼‰æ—¶ï¼Œå½“æˆ‘ä»¬åˆ‡æ¢åˆ°ä¸åŒçš„FBOæˆ–è€…ä¸å†éœ€è¦æŸäº›é¢œè‰²ã€æ·±åº¦æˆ–æ¨¡æ¿ç¼“å†²åŒºçš„å†…å®¹æ—¶ï¼Œå¯ä»¥è°ƒç”¨è¯¥å‡½æ•°ã€‚ æ€§èƒ½å½±å“ï¼šå°½ç®¡åœ¨RenderDocç­‰å·¥å…·ä¸­å¯èƒ½æ˜¾ç¤ºglInvalidateFramebufferçš„è€—æ—¶è¾ƒé«˜ï¼Œä½†å®é™…ä¸Šï¼Œåªæœ‰å°‘æ•°å‡ æ¬¡è°ƒç”¨ä¸ä¼šå¯¹æ¸²æŸ“æ€§èƒ½äº§ç”Ÿå½±å“ã€‚ glClearï¼š åŠŸèƒ½ï¼šglClear ç”¨äºæ¸…é™¤å½“å‰å¸§ç¼“å†²åŒºçš„å†…å®¹ï¼ŒåŒ…æ‹¬é¢œè‰²ç¼“å†²åŒºã€æ·±åº¦ç¼“å†²åŒºå’Œæ¨¡æ¿ç¼“å†²åŒºã€‚ åº”ç”¨åœºæ™¯ï¼šåœ¨æ¯ä¸€å¸§å¼€å§‹æ—¶ï¼Œæˆ‘ä»¬é€šå¸¸ä¼šè°ƒç”¨glClearæ¥å‡†å¤‡å¸§ç¼“å†²åŒºï¼Œä»¥ä¾¿è¿›è¡Œæ–°çš„ç»˜åˆ¶ã€‚ æ€§èƒ½å½±å“ï¼šglClearçš„æ€§èƒ½å¼€é”€é€šå¸¸è¾ƒå°ï¼Œä½†åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå¦‚æœé¢‘ç¹è°ƒç”¨ï¼Œå¯èƒ½ä¼šå½±å“æ€§èƒ½ã€‚ æ€»ç»“ï¼š glInvalidateFramebuffer ç”¨äºæ ‡è®°å¸§ç¼“å†²åŒºçš„éƒ¨åˆ†å†…å®¹ä¸ºæ— æ•ˆï¼Œä»¥å‡å°‘ä¸å¿…è¦çš„æ•°æ®äº¤æ¢ã€‚ glClear ç”¨äºæ¸…é™¤æ•´ä¸ªå¸§ç¼“å†²åŒºçš„å†…å®¹ï¼Œä»¥å‡†å¤‡è¿›è¡Œæ–°çš„ç»˜åˆ¶ã€‚ åœ¨ä½¿ç”¨RenderDocç­‰å·¥å…·æ—¶ï¼Œå¯ä»¥å¿½ç•¥glInvalidateFramebufferçš„è€—æ—¶ï¼Œä½†éœ€è¦å…³æ³¨ç‰‡ä¸Šé«˜é€Ÿç¼“å­˜å›å†™å†…å­˜çš„æ¶ˆè€— ã€‚ glDiscardFramebufferEXT void glDiscardFramebufferEXT(enum target, sizei numAttachments, const enum *attachments); è¿™ä¸ªæ‰©å±•æä¾›äº†ä¸€ä¸ªæ–°çš„å‘½ä»¤ï¼ŒglDiscardFramebufferEXTï¼Œå®ƒä¼šä½¿å¾—æŒ‡å®šå¸§ç¼“å†²é™„ä»¶çš„å†…å®¹å˜ä¸ºæœªå®šä¹‰çŠ¶æ€ã€‚åœ¨æœªæ¥çš„æ“ä½œä¿®æ”¹å†…å®¹ä¹‹å‰ï¼Œè¿™äº›æŒ‡å®šç¼“å†²åŒºçš„å†…å®¹æ˜¯æœªå®šä¹‰çš„ï¼Œåªæœ‰è¢«ä¿®æ”¹çš„åŒºåŸŸä¿è¯åŒ…å«æœ‰æ•ˆå†…å®¹ã€‚æœ‰æ•ˆåœ°ä½¿ç”¨æ­¤å‘½ä»¤å¯ä»¥ä¸ºå®ç°æä¾›æ–°çš„ä¼˜åŒ–æœºä¼šã€‚ ä¸€äº› OpenGL ES å®ç°ä¼šå°†å¸§ç¼“å†²å›¾åƒç¼“å­˜åˆ°ä¸€ä¸ªå°çš„å¿«é€Ÿå†…å­˜æ± ä¸­ã€‚åœ¨æ¸²æŸ“ä¹‹å‰ï¼Œè¿™äº›å®ç°å¿…é¡»å°†é€»è¾‘ç¼“å†²åŒºï¼ˆå¦‚é¢œè‰²ã€æ·±åº¦ã€æ¨¡æ¿ç­‰ï¼‰çš„ç°æœ‰å†…å®¹åŠ è½½åˆ°è¯¥å†…å­˜ä¸­ã€‚æ¸²æŸ“åï¼Œè¿™äº›ç¼“å†²åŒºä¸­çš„ä¸€éƒ¨åˆ†æˆ–å…¨éƒ¨ä¹Ÿä¼šè¢«å­˜å‚¨å›å¤–éƒ¨å†…å­˜ï¼Œä»¥ä¾¿å°†æ¥å†æ¬¡ä½¿ç”¨å…¶å†…å®¹ã€‚åœ¨è®¸å¤šåº”ç”¨ç¨‹åºä¸­ï¼Œé€»è¾‘ç¼“å†²åŒºåœ¨æ¸²æŸ“å¼€å§‹æ—¶è¢«æ¸…é™¤ã€‚å¦‚æœæ˜¯è¿™æ ·ï¼ŒåŠ è½½æˆ–å­˜å‚¨è¿™äº›ç¼“å†²åŒºçš„å·¥ä½œå°±æ˜¯æµªè´¹çš„ã€‚ å³ä½¿æ²¡æœ‰è¿™ä¸ªæ‰©å±•ï¼Œå¦‚æœæ¸²æŸ“çš„ä¸€å¸§ä»å…¨å±æ¸…é™¤å¼€å§‹ï¼ŒOpenGL ES å®ç°ä¹Ÿå¯ä»¥ä¼˜åŒ–æ‰åœ¨æ¸²æŸ“å¸§ä¹‹å‰åŠ è½½å¸§ç¼“å†²åŒºå†…å®¹çš„æ­¥éª¤ã€‚æœ‰äº†è¿™ä¸ªæ‰©å±•ï¼Œåº”ç”¨ç¨‹åºå¯ä»¥ä½¿ç”¨ DiscardFramebufferEXT æ¥è¡¨ç¤ºå¸§ç¼“å†²åŒºçš„å†…å®¹å°†ä¸å†éœ€è¦ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼ŒOpenGL ES å®ç°ä¹Ÿå¯ä»¥ä¼˜åŒ–æ‰åœ¨æ¸²æŸ“å¸§åå­˜å‚¨å¸§ç¼“å†²åŒºå†…å®¹çš„æ­¥éª¤ã€‚ glDiscardFramebufferEXTçš„å·¥ä½œæ˜¯å‘ŠçŸ¥é©±åŠ¨ç¨‹åºä½ ä¸å…³å¿ƒframebufferçš„å†…å®¹ã€‚ä»€ä¹ˆé©±åŠ¨ç¨‹åº(æˆ–GPU)å†³å®šç”¨å®ƒåšä»€ä¹ˆ - è¿™ä¸å–å†³äºä½ ã€‚é©±åŠ¨ç¨‹åºå¯ä»¥å°†æ‰€æœ‰å†…å®¹é‡ç½®ä¸º0ï¼Œæˆ–è€…å®ƒå¯ä»¥ä¿æŒåŸæ ·ï¼Œæˆ–è€…å½“æ‚¨ä¸‹æ¬¡è°ƒç”¨glClearæ—¶å®ƒå°†ä½¿ç”¨æ­¤ä¿¡æ¯å¹¶ä¸”å°†æ›´æœ‰æ•ˆåœ°æ‰§è¡Œå®ƒ(ä¾‹å¦‚é€šè¿‡ä¸ºå†…å®¹åˆ†é…æ–°å†…å­˜ï¼Œè€Œä¸æ˜¯æ‰§è¡Œmemsetä¸0å€¼)ã€‚ä¸è¦æ‹…å¿ƒå®ƒä¼šåšä»€ä¹ˆ Texture objä¸RBOçš„åŒºåˆ« FBO(Frame Buffer Object)å³å¸§ç¼“å†²åŒºå¯¹è±¡ï¼Œæ˜¯ä¸€ä¸ªå¯æ·»åŠ ç¼“å†²åŒºçš„å®¹å™¨ï¼Œå¯ä»¥ä¸ºå…¶æ·»åŠ çº¹ç†æˆ–æ¸²æŸ“ç¼“å†²åŒºå¯¹è±¡ï¼ˆRBO),å®ƒä»¬çš„åŒºåˆ«å¦‚ä¸‹å›¾ shader åˆå§‹åŒ– å˜é‡ uniformå˜é‡ uniformå˜é‡æ˜¯å¤–éƒ¨applicationç¨‹åºä¼ é€’ç»™ï¼ˆvertexå’Œfragmentï¼‰shaderçš„å˜é‡ã€‚å› æ­¤å®ƒæ˜¯applicationé€šè¿‡å‡½æ•°glUniform**ï¼ˆï¼‰å‡½æ•°èµ‹å€¼çš„ã€‚åœ¨ï¼ˆvertexå’Œfragmentï¼‰shaderç¨‹åºå†…éƒ¨ï¼Œuniformå˜é‡å°±åƒæ˜¯Cè¯­è¨€é‡Œé¢çš„å¸¸é‡ï¼ˆconst ï¼‰ï¼Œå®ƒä¸èƒ½è¢«shaderç¨‹åºä¿®æ”¹ã€‚ attributeå˜é‡ attributeå˜é‡æ˜¯åªèƒ½åœ¨vertex shaderä¸­ä½¿ç”¨çš„å˜é‡ã€‚å®ƒä¸èƒ½åœ¨fragment shaderä¸­å£°æ˜attributeå˜é‡ï¼Œä¹Ÿä¸èƒ½è¢«fragment shaderä¸­ä½¿ç”¨ã€‚ä¸€èˆ¬ç”¨attributeå˜é‡æ¥è¡¨ç¤ºä¸€äº›é¡¶ç‚¹çš„æ•°æ®ï¼Œå¦‚ï¼šé¡¶ç‚¹åæ ‡ï¼Œæ³•çº¿ï¼Œçº¹ç†åæ ‡ï¼Œé¡¶ç‚¹é¢œè‰²ç­‰ã€‚åœ¨applicationä¸­ï¼Œä¸€èˆ¬ç”¨å‡½æ•°glBindAttribLocationï¼ˆï¼‰æ¥ç»‘å®šæ¯ä¸ªattributeå˜é‡çš„ä½ç½®ï¼Œç„¶åç”¨å‡½æ•°glVertexAttribPointerï¼ˆï¼‰ä¸ºæ¯ä¸ªattributeå˜é‡èµ‹å€¼ã€‚ varyingå˜é‡ varyingå˜é‡æ˜¯vertexå’Œfragment shaderä¹‹é—´åšæ•°æ®ä¼ é€’ç”¨çš„ã€‚ä¸€èˆ¬vertex shaderä¿®æ”¹varyingå˜é‡çš„å€¼ï¼Œç„¶åfragment shaderä½¿ç”¨è¯¥varyingå˜é‡çš„å€¼ã€‚å› æ­¤varyingå˜é‡åœ¨vertexå’Œfragment shaderäºŒè€…ä¹‹é—´çš„å£°æ˜å¿…é¡»æ˜¯ä¸€è‡´çš„ã€‚applicationä¸èƒ½ä½¿ç”¨æ­¤å˜é‡ã€‚ èµ„æºé‡Šæ”¾ dmabufèµ„æºé‡Šæ”¾ä¸»è¦è€ƒè™‘textureï¼ŒeglImage å’Œdmabufï¼Œ FBOä¸éœ€è¦è€ƒè™‘ã€‚ textureã€ eglImageå’Œ dmabufæ˜¯ä¸€ä½“çš„ï¼Œé‡Šæ”¾æ—¶éœ€è¦è°ƒç”¨glDeleteTexturesï¼Œ eglDestroyImageKHRï¼Œ close(dmabuf)ï¼Œ ä¸‰ä¸ªéƒ½å®Œæˆå dmabufæ‰çœŸæ­£é‡Šæ”¾ã€‚ å¦‚æœtextureé™„åŠ åˆ°ä¸€ä¸ªFBOä¸Šï¼ŒglDeleteTextrues()åä¼šä½¿å¾—è¯¥FBOçš„é™„åŠ çº¹ç†ä¸º0. å¦‚æœå‰é¢å·²ç»attach ä¸€ä¸ªçº¹ç†åˆ°FBOï¼Œ åœ¨attach æ–°çº¹ç†åˆ°å¦ä¸€ä¸ªFBOæ—¶ï¼Œè¦å…ˆæŠŠå‰ä¸€ä¸ªFBOçš„çº¹ç†è®¾ç½®ä¸º0, å¦åˆ™é‡Šæ”¾ä¸æ‰ã€‚ int main(int argc, char const *argv[]){ init_dev(); egl_Init(); dmabuf_fd = allocate_dmabuf(1920*1080*4); textureid = create_texture_for_dmabuf(dmabuf_fd, 1920, 1080, &amp;eglImg); glGenFramebuffers(1, &amp;FBO2); glBindFramebuffer(GL_FRAMEBUFFER, FBO2); glBindTexture(GL_TEXTURE_EXTERNAL_OES, textureid); glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_EXTERNAL_OES, textureid, 0); if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) { assert(0); } // å¾—åˆ°å½“å‰é™„åŠ çº¹ç†IDä¸º 1 glGetFramebufferAttachmentParameteriv(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME, &amp;text); free_dmabuf(dmabuf_fd); glDeleteTextures(1, &amp;textureid); eglDestroyImageKHR(g_EGLDisplay, eglImg); // å®Œæˆå /sys/kernel/debug/dmabuf/bufferinfo ä¸­dmabufå·²ç»é‡Šæ”¾ // å¾—åˆ°å½“å‰é™„åŠ çº¹ç†IDä¸º 0 glGetFramebufferAttachmentParameteriv(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME, &amp;text); glDeleteFramebuffers(1, &amp;FBO2); eglDestroyContext(g_EGLDisplay, g_EGLContext); return 0; int main(int argc, char const *argv[]){ init_dev(); egl_Init(); dmabuf_fd1 = allocate_dmabuf(1920*1080*4); textureid1 = create_texture_for_dmabuf(dmabuf_fd1, 1920, 1080, &amp;eglImg1); dmabuf_fd2 = allocate_dmabuf(1920*1080*4); textureid2 = create_texture_for_dmabuf(dmabuf_fd2, 1920, 1080, &amp;eglImg2); glGenFramebuffers(1, &amp;FBO1); glBindFramebuffer(GL_FRAMEBUFFER, FBO1); glBindTexture(GL_TEXTURE_EXTERNAL_OES, textureid1); glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_EXTERNAL_OES, textureid1, 0); if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) { assert(0); } // æ³¨æ„è¦è®¾ç½®FBO çš„çº¹ç†ä¸º0ï¼Œ å¦åˆ™åé¢ä¸èƒ½çœŸæ­£é‡Šæ”¾ glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_EXTERNAL_OES, 0, 0); glGenFramebuffers(1, &amp;FBO2); glBindFramebuffer(GL_FRAMEBUFFER, FBO2); glBindTexture(GL_TEXTURE_EXTERNAL_OES, textureid2); glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_EXTERNAL_OES, textureid2, 0); if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) { assert(0); } free_dmabuf(dmabuf_fd1); glDeleteTextures(1, &amp;textureid1); eglDestroyImageKHR(g_EGLDisplay, eglImg1); free_dmabuf(dmabuf_fd2); glDeleteTextures(1, &amp;textureid2); eglDestroyImageKHR(g_EGLDisplay, eglImg2); // å®Œæˆå /sys/kernel/debug/dmabuf/bufferinfo ä¸­dmabufå·²ç»é‡Šæ”¾ glDeleteFramebuffers(1, &amp;FBO1); glDeleteFramebuffers(1, &amp;FBO2); eglDestroyContext(g_EGLDisplay, g_EGLContext); return 0; çº¹ç†è¿‡æ»¤ ä¸€ä¸ªçº¹ç†é€šå¸¸æ˜¯ç”±å¾ˆå¤šçš„åƒç´ ç‚¹ç»„æˆçš„ï¼Œé‚£ä¹ˆé€šè¿‡çº¹ç†åæ ‡å¦‚ä½•å¾—åˆ°å¯¹åº”ç‚¹åº”è¯¥çš„é¢œè‰²ï¼Œè¿™å°±æ˜¯çº¹ç†é‡‡æ ·æ–¹å¼æˆ–çº¹ç†è¿‡æ»¤ã€‚ ä¸‹é¢æ˜¯ä¸¤ç§é‡è¦çš„çº¹ç†é‡‡æ ·(çº¹ç†è¿‡æ»¤)ï¼š GL_NEAREST:é‚»è¿‘è¿‡æ»¤ï¼Œè¿™ä¸ªæ˜¯é»˜è®¤çº¹ç†è¿‡æ»¤æ–¹å¼ï¼ŒOpenGLä¼šé€‰æ‹©ä¸­å¿ƒç‚¹æœ€æ¥è¿‘çº¹ç†åæ ‡çš„é‚£ä¸ªåƒç´ . è¿™ç§æ–¹å¼æ”¾å¤§æœ‰é¢—ç²’æ„Ÿ GL_LINEARï¼šçº¿æ€§è¿‡æ»¤ï¼Œå®ƒä¼šåŸºäºçº¹ç†åæ ‡é™„è¿‘çš„çº¹ç†åƒç´ ï¼Œè®¡ç®—å‡ºä¸€ä¸ªæ’å€¼ï¼Œè¿‘ä¼¼å‡ºè¿™äº›çº¹ç†åƒç´ ä¹‹é—´çš„é¢œè‰²ï¼Œä¸€ä¸ªçº¹ç†åƒç´ çš„ä¸­å¿ƒè·ç¦»çº¹ç†åæ ‡è¶Šè¿‘ï¼Œé‚£ä¹ˆè¿™ä¸ªçº¹ç†åƒç´ çš„é¢œè‰²å¯¹æœ€ç»ˆçš„æ ·æœ¬é¢œè‰²çš„è´¡çŒ®è¶Šå¤§ï¼Œ æ”¾å¤§åè¾ƒå¹³æ»‘ã€‚ äºŒè€…æ”¾å¤§åçš„æ•ˆæœæ¯”è¾ƒ å½“çº¹ç†è¢«æ”¾å¤§æˆ–ç¼©å°è´´åˆ°ä¸€ä¸ªå¹³é¢æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥è®¾ç½®ä¸åŒçš„çº¹ç†é‡‡æ ·(çº¹ç†è¿‡æ»¤)æ–¹å¼ï¼Œè¾¾åˆ°ä¸åŒçš„æ•ˆæœã€‚å®ƒæ‰€æ¶‰åŠåˆ°çš„OpenGL å‡½æ•°å¦‚ä¸‹ï¼š glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); // ç¼©å° glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // æ”¾å¤§ çº¹ç†ç¯ç»• çº¹ç†åæ ‡çš„èŒƒå›´é€šå¸¸æ˜¯ä»(0, 0)åˆ°(1, 1)ï¼Œé‚£å¦‚æœæˆ‘ä»¬æŠŠçº¹ç†åæ ‡è®¾ç½®åœ¨èŒƒå›´ä¹‹å¤–ä¼šå‘ç”Ÿä»€ä¹ˆï¼ŸOpenGLé»˜è®¤çš„è¡Œä¸ºæ˜¯é‡å¤è¿™ä¸ªçº¹ç†å›¾åƒã€‚ ç¯ç»•æ–¹å¼ æè¿° GL_REPEAT å¯¹çº¹ç†çš„é»˜è®¤è¡Œä¸ºã€‚é‡å¤çº¹ç†å›¾åƒã€‚ GL_MIRRORED_REPEAT å’ŒGL_REPEATä¸€æ ·ï¼Œä½†æ¯æ¬¡é‡å¤å›¾ç‰‡æ˜¯é•œåƒæ”¾ç½®çš„ã€‚ GL_CLAMP_TO_EDGE çº¹ç†åæ ‡ä¼šè¢«çº¦æŸåœ¨0åˆ°1ä¹‹é—´ï¼Œè¶…å‡ºçš„éƒ¨åˆ†ä¼šé‡å¤çº¹ç†åæ ‡çš„è¾¹ç¼˜ï¼Œäº§ç”Ÿä¸€ç§è¾¹ç¼˜è¢«æ‹‰ä¼¸çš„æ•ˆæœã€‚ GL_CLAMP_TO_BORDER è¶…å‡ºçš„åæ ‡ä¸ºç”¨æˆ·æŒ‡å®šçš„è¾¹ç¼˜é¢œè‰² ç›¸å…³å‡½æ•° glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT); å¦‚æœæˆ‘ä»¬é€‰æ‹©GL_CLAMP_TO_BORDERé€‰é¡¹ï¼Œæˆ‘ä»¬è¿˜éœ€è¦æŒ‡å®šä¸€ä¸ªè¾¹ç¼˜çš„é¢œè‰²ã€‚è¿™éœ€è¦ä½¿ç”¨glTexParameterå‡½æ•°çš„fvåç¼€å½¢å¼ï¼Œç”¨GL_TEXTURE_BORDER_COLORä½œä¸ºå®ƒçš„é€‰é¡¹ï¼Œå¹¶ä¸”ä¼ é€’ä¸€ä¸ªfloatæ•°ç»„ä½œä¸ºè¾¹ç¼˜çš„é¢œè‰²å€¼ï¼š float borderColor[] = { 1.0f, 1.0f, 0.0f, 1.0f }; glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor); glMapBufferRange glMapBufferRange æ˜¯ä¸€ä¸ª OpenGL å‡½æ•°ï¼Œç”¨äºå°†æŒ‡å®šç¼“å†²å¯¹è±¡çš„ä¸€éƒ¨åˆ†æ•°æ®æ˜ å°„åˆ°å®¢æˆ·ç«¯çš„åœ°å€ç©ºé—´ä¸­,å¯ä»¥å‡å°‘ä¸€æ¬¡CPU å†…å­˜æ•°æ®çš„è¯»å†™ã€‚ ä»¥ä¸‹æ˜¯å…³äº glMapBufferRange çš„è¯¦ç»†è¯´æ˜ï¼š ä½œç”¨ï¼š glMapBufferRange å…è®¸ä½ ç›´æ¥è®¿é—®ç¼“å†²å¯¹è±¡çš„æ•°æ®ï¼Œä»¥ä¾¿åœ¨å®¢æˆ·ç«¯ä»£ç ä¸­è¿›è¡Œè¯»å–æˆ–å†™å…¥æ“ä½œã€‚ é€šè¿‡æ˜ å°„ç¼“å†²åŒºçš„ä¸€éƒ¨åˆ†ï¼Œä½ å¯ä»¥æœ‰æ•ˆåœ°æ“ä½œå…¶ä¸­çš„æ•°æ®ã€‚ å‚æ•°ï¼š targetï¼šç›®æ ‡ç¼“å†²å¯¹è±¡ç±»å‹ï¼Œé€šå¸¸ä¸º GL_ARRAY_BUFFER æˆ– GL_ELEMENT_ARRAY_BUFFERã€‚ offsetï¼šè¦æ˜ å°„çš„æ•°æ®åœ¨ç¼“å†²å¯¹è±¡ä¸­çš„åç§»é‡ã€‚ lengthï¼šè¦æ˜ å°„çš„æ•°æ®çš„é•¿åº¦ã€‚ accessï¼šè®¿é—®æƒé™ï¼Œå¯ä»¥æ˜¯ GL_READ_ONLYã€GL_WRITE_ONLY æˆ– GL_READ_WRITEã€‚ è¿”å›å€¼ï¼šæ˜ å°„åçš„æŒ‡é’ˆï¼Œç”¨äºè®¿é—®ç¼“å†²åŒºæ•°æ®ã€‚ ä½¿ç”¨åœºæ™¯ï¼š åœ¨é¡¶ç‚¹ç¼“å†²å¯¹è±¡ï¼ˆVBOï¼‰ä¸­ï¼Œä½ å¯ä»¥ä½¿ç”¨ glMapBufferRange æ¥æ›´æ–°é¡¶ç‚¹æ•°æ®ã€‚ åœ¨åƒç´ ç¼“å†²å¯¹è±¡ï¼ˆPBOï¼‰ä¸­ï¼Œä½ å¯ä»¥ä½¿ç”¨å®ƒæ¥å¤„ç†åƒç´ æ•°æ®ã€‚ æ€»ä¹‹ï¼ŒglMapBufferRange å…è®¸ä½ æ˜ å°„ç¼“å†²å¯¹è±¡çš„ä¸€éƒ¨åˆ†æ•°æ®ï¼Œä»¥ä¾¿åœ¨å®¢æˆ·ç«¯ä»£ç ä¸­ç›´æ¥è®¿é—®å’Œæ“ä½œã€‚ #include &lt;GL/glew.h&gt; #include &lt;GLFW/glfw3.h&gt; #include &lt;iostream&gt; int main() { // Initialize GLFW and create a window if (!glfwInit()) { std::cerr &lt;&lt; \"Failed to initialize GLFW\" &lt;&lt; std::endl; return -1; } GLFWwindow* window = glfwCreateWindow(800, 600, \"OpenGL Sample\", nullptr, nullptr); if (!window) { std::cerr &lt;&lt; \"Failed to create GLFW window\" &lt;&lt; std::endl; glfwTerminate(); return -1; } glfwMakeContextCurrent(window); // Initialize GLEW if (glewInit() != GLEW_OK) { std::cerr &lt;&lt; \"Failed to initialize GLEW\" &lt;&lt; std::endl; return -1; } // Create a buffer object (VBO) GLuint vbo; glGenBuffers(1, &amp;vbo); glBindBuffer(GL_ARRAY_BUFFER, vbo); // Allocate storage for the buffer glBufferData(GL_ARRAY_BUFFER, 1024, nullptr, GL_DYNAMIC_DRAW); // Map a portion of the buffer GLintptr offset = 0; GLsizeiptr size = 512; GLvoid* mappedData = glMapBufferRange(GL_ARRAY_BUFFER, offset, size, GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_BUFFER_BIT); if (mappedData) { // Modify the data in the mapped region // ... // Unmap the buffer glUnmapBuffer(GL_ARRAY_BUFFER); } else { std::cerr &lt;&lt; \"Failed to map buffer\" &lt;&lt; std::endl; } // Main loop while (!glfwWindowShouldClose(window)) { // Render your scene using the modified buffer data // ... glfwSwapBuffers(window); glfwPollEvents(); } // Cleanup glDeleteBuffers(1, &amp;vbo); glfwDestroyWindow(window); glfwTerminate(); return 0; } static void DumpTexture(GLuint TextureId, GLuint x0, GLuint y0, GLuint x1, GLuint y1){ int fbo0; glGetIntegerv( GL_FRAMEBUFFER_BINDING, &amp;fbo0); GLuint fbo; glGenFramebuffers(1, &amp;fbo); glBindFramebuffer(GL_FRAMEBUFFER, fbo); glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, TextureId, 0); if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) { printf(\"glCheckFramebufferStatus() failed\\n\"); return; } GLuint size = (x1-x0)* (y1-y0)*4; GLuint pbo_down; glGenBuffers(1, &amp;pbo_down); glBindBuffer(GL_PIXEL_PACK_BUFFER, pbo_down); glBufferData(GL_PIXEL_PACK_BUFFER, size, NULL, GL_STREAM_READ); glReadPixels(x0,y0, x1, y1, GL_RGBA, GL_UNSIGNED_BYTE, 0); GLubyte *src = (GLubyte*)glMapBufferRange(GL_PIXEL_PACK_BUFFER,0, size, GL_MAP_READ_BIT); GLubyte *buffer = malloc(size); memcpy(buffer, src, size); glUnmapBuffer(GL_PIXEL_PACK_BUFFER); glBindBuffer(GL_PIXEL_PACK_BUFFER, 0); stbi_write_png(\"/tmp/texture_img.png\", (int)(x1-x0), (int)(y1-y0), 4, buffer, (int)((x1-x0)*4)); glBindFramebuffer(GL_FRAMEBUFFER, fbo0); } freetype ä¸‹å›¾æ˜¯freetypeè°ƒç”¨çš„åŸºæœ¬æ¡†æ¶ã€‚ å‚çœ‹ä¸Šå›¾ï¼Œåœ¨ç»˜åˆ¶å­—ç¬¦æ—¶ä»¥baselineä¸ºæ°´å¹³åŸºå‡†ï¼Œåˆ™æ‰€æœ‰çš„å­—ç¬¦å°±ä¼šå¯¹é½ã€‚"
  },"/blog/jekyll/2002-08-10-Wayland-Misc.html": {
    "title": "Wayland Misc",
    "keywords": "Jekyll",
    "url": "/blog/jekyll/2002-08-10-Wayland-Misc.html",
    "body": "Expat Expat æ˜¯ä¸€ä¸ªç”¨ C ç¼–å†™çš„æµå¼ XML è§£æåº“ã€‚å®ƒåœ¨å¤„ç†æ–‡ä»¶å¤§å°è¶…å‡ºå†…å­˜é™åˆ¶ä¸”æ€§èƒ½å’Œçµæ´»æ€§è‡³å…³é‡è¦çš„æƒ…å†µä¸‹è¡¨ç°å‡ºè‰²ã€‚è®¸å¤šåº”ç”¨ç¨‹åºã€åº“å’Œç¡¬ä»¶éƒ½ä½¿ç”¨äº† Expatï¼Œå¹¶ä¸”è¿˜æœ‰ä¸€äº›ç»‘å®šå’Œç¬¬ä¸‰æ–¹å°è£…ã€‚ ä»¥ä¸‹æ˜¯å…³äº Expat çš„ä¸€äº›é‡è¦ä¿¡æ¯ï¼š ä»€ä¹ˆæ˜¯ Expatï¼Ÿ Expat æ˜¯ä¸€ä¸ªæµå¼è§£æå™¨ï¼Œåº”ç”¨ç¨‹åºåœ¨å¼€å§‹è§£æä¹‹å‰å‘è§£æå™¨æ³¨å†Œå¤„ç†ç¨‹åºï¼Œä»¥å¤„ç† XML æ–‡æ¡£ä¸­å‘ç°çš„ç›¸å…³ç»“æ„ï¼ˆä¾‹å¦‚å¼€å§‹æ ‡ç­¾ç­‰ï¼‰ã€‚ ä¸»è¦ç‰¹ç‚¹ï¼š æµå¼è§£æï¼šExpat æ˜¯æµå¼è§£æå™¨ï¼Œå®ƒåœ¨è§£æä¹‹å‰æ³¨å†Œå¤„ç†ç¨‹åºï¼Œç„¶ååœ¨æ–‡æ¡£ä¸­å‘ç°ç›¸å…³ç»“æ„æ—¶è°ƒç”¨è¿™äº›å¤„ç†ç¨‹åºã€‚ é€‚ç”¨äºå¤§æ–‡ä»¶ï¼šExpat é€‚ç”¨äºé‚£äº›æ–‡ä»¶å¤ªå¤§è€Œæ— æ³•æ”¾å…¥å†…å­˜çš„æƒ…å†µã€‚ æ€§èƒ½ä¼˜è¶Šï¼šExpat åœ¨è§£æé€Ÿåº¦å’Œçµæ´»æ€§æ–¹é¢è¡¨ç°å‡ºè‰²ã€‚ å¹¿æ³›ä½¿ç”¨ï¼šè®¸å¤šåº”ç”¨ç¨‹åºã€åº“å’Œç¡¬ä»¶éƒ½ä½¿ç”¨äº† Expatã€‚ ç»‘å®šå’Œå°è£…ï¼šExpat è¿˜æœ‰ä¸€äº›ç»‘å®šå’Œç¬¬ä¸‰æ–¹å°è£…ï¼Œä½¿å…¶æ›´æ˜“äºåœ¨ä¸åŒç¯å¢ƒä¸­ä½¿ç”¨ã€‚ è¯·æŸ¥çœ‹ è¿™ç¯‡ä»‹ç»æ€§æ–‡ç«  ç¤ºä¾‹ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;expat.h&gt; // å›è°ƒå‡½æ•°ï¼šå¤„ç†å¼€å§‹æ ‡ç­¾ void startElement(void *userData, const char *name, const char **atts) { printf(\"Start element: %s\\n\", name); } // å›è°ƒå‡½æ•°ï¼šå¤„ç†ç»“æŸæ ‡ç­¾ void endElement(void *userData, const char *name) { printf(\"End element: %s\\n\", name); } int main() { // åˆ›å»ºè§£æå™¨ XML_Parser parser = XML_ParserCreate(NULL); if (!parser) { fprintf(stderr, \"Error creating XML parser.\\n\"); return 1; } // è®¾ç½®å›è°ƒå‡½æ•° XML_SetElementHandler(parser, startElement, endElement); // XML æ•°æ®ï¼ˆç¤ºä¾‹ï¼‰ const char *xmlData = \"&lt;root&gt;&lt;item&gt;Apple&lt;/item&gt;&lt;item&gt;Banana&lt;/item&gt;&lt;/root&gt;\"; // è§£æ XML æ•°æ® if (XML_Parse(parser, xmlData, strlen(xmlData), 1) == XML_STATUS_ERROR) { fprintf(stderr, \"Error parsing XML data.\\n\"); XML_ParserFree(parser); return 1; } // é‡Šæ”¾è§£æå™¨ XML_ParserFree(parser); return 0; } libffi libffi æ˜¯ä¸€ä¸ªç”¨ C ç¼–å†™çš„å¯ç§»æ¤çš„å¤–éƒ¨å‡½æ•°æ¥å£åº“ã€‚å®ƒä¸ºä¸åŒçš„è°ƒç”¨çº¦å®šæä¾›äº†ä¸€ä¸ªé«˜çº§åˆ«çš„ç¼–ç¨‹æ¥å£ï¼Œå…è®¸ç¨‹åºå‘˜åœ¨è¿è¡Œæ—¶è°ƒç”¨ä»»ä½•ç”±è°ƒç”¨æ¥å£æè¿°æŒ‡å®šçš„å‡½æ•°ã€‚FFI ä»£è¡¨å¤–éƒ¨å‡½æ•°æ¥å£ï¼Œæ˜¯å…è®¸åœ¨ä¸€ç§è¯­è¨€ä¸­ç¼–å†™çš„ä»£ç è°ƒç”¨å¦ä¸€ç§è¯­è¨€ä¸­ç¼–å†™çš„ä»£ç çš„æ¥å£ã€‚libffi å®é™…ä¸Šåªæä¾›äº†å®Œæ•´ç‰¹æ€§çš„å¤–éƒ¨å‡½æ•°æ¥å£çš„æœ€åº•å±‚ã€ä¸æœºå™¨ç›¸å…³çš„éƒ¨åˆ†ã€‚åœ¨libffiä¹‹ä¸Šå¿…é¡»å­˜åœ¨ä¸€ä¸ªå¤„ç†ä¸¤ç§è¯­è¨€ä¹‹é—´ä¼ é€’çš„å€¼çš„ç±»å‹è½¬æ¢å±‚ã€‚ ä»¥ä¸‹æ˜¯å…³äº libffi çš„ä¸€äº›é‡è¦ä¿¡æ¯ï¼š ä»€ä¹ˆæ˜¯ libffiï¼Ÿ ç¼–è¯‘å™¨ä¸ºé«˜çº§è¯­è¨€ç”Ÿæˆéµå¾ªæŸäº›çº¦å®šçš„ä»£ç ã€‚å…¶ä¸­ä¹‹ä¸€æ˜¯â€œè°ƒç”¨çº¦å®šâ€ã€‚â€œè°ƒç”¨çº¦å®šâ€å®é™…ä¸Šæ˜¯ç¼–è¯‘å™¨å¯¹å‡½æ•°å‚æ•°åœ¨è¿›å…¥å‡½æ•°æ—¶çš„ä½ç½®çš„ä¸€ç»„å‡è®¾ã€‚â€œè°ƒç”¨çº¦å®šâ€è¿˜æŒ‡å®šäº†å‡½æ•°çš„è¿”å›å€¼åœ¨å“ªé‡Œæ‰¾åˆ°ã€‚æœ‰äº›ç¨‹åºåœ¨ç¼–è¯‘æ—¶å¯èƒ½ä¸çŸ¥é“è¦ä¼ é€’ç»™å‡½æ•°çš„å‚æ•°ã€‚ä¾‹å¦‚ï¼Œè§£é‡Šå™¨å¯èƒ½åœ¨è¿è¡Œæ—¶å‘ŠçŸ¥è°ƒç”¨ç»™å®šå‡½æ•°æ‰€ä½¿ç”¨çš„å‚æ•°çš„æ•°é‡å’Œç±»å‹ã€‚libffi å¯ä»¥åœ¨è¿™äº›ç¨‹åºä¸­ä½¿ç”¨ï¼Œä»¥æä¾›ä»è§£é‡Šå™¨ç¨‹åºåˆ°ç¼–è¯‘ä»£ç çš„æ¡¥æ¢ã€‚libffi åº“ä¸ºå„ç§è°ƒç”¨çº¦å®šæä¾›äº†ä¸€ä¸ªå¯ç§»æ¤çš„é«˜çº§åˆ«ç¼–ç¨‹æ¥å£ï¼Œå…è®¸ç¨‹åºå‘˜åœ¨è¿è¡Œæ—¶è°ƒç”¨ä»»ä½•ç”±è°ƒç”¨æ¥å£æè¿°æŒ‡å®šçš„å‡½æ•°ã€‚FFI ä»£è¡¨å¤–éƒ¨å‡½æ•°æ¥å£ã€‚å¤–éƒ¨å‡½æ•°æ¥å£æ˜¯å…è®¸åœ¨ä¸€ç§è¯­è¨€ä¸­ç¼–å†™çš„ä»£ç è°ƒç”¨å¦ä¸€ç§è¯­è¨€ä¸­ç¼–å†™çš„ä»£ç çš„æ¥å£ã€‚libffi å®é™…ä¸Šåªæä¾›äº†å®Œæ•´ç‰¹æ€§çš„å¤–éƒ¨å‡½æ•°æ¥å£çš„æœ€åº•å±‚ã€ä¸æœºå™¨ç›¸å…³çš„éƒ¨åˆ†ã€‚åœ¨libffiä¹‹ä¸Šå¿…é¡»å­˜åœ¨ä¸€ä¸ªå¤„ç†ä¸¤ç§è¯­è¨€ä¹‹é—´ä¼ é€’çš„å€¼çš„ç±»å‹è½¬æ¢å±‚ã€‚ æ”¯æŒçš„å¹³å°ï¼šlibffi å·²ç»ç§»æ¤åˆ°è®¸å¤šä¸åŒçš„å¹³å°ã€‚å‘å¸ƒæ—¶ï¼Œå·²ç»æµ‹è¯•äº†ä»¥ä¸‹åŸºæœ¬é…ç½®ï¼š æ¶æ„ï¼šAArch64ï¼ˆARM64ï¼‰ã€Alphaã€ARCã€ARMã€AVR32ã€Blackfin ç­‰ã€‚ æ“ä½œç³»ç»Ÿï¼šLinuxã€iOSã€Windows ç­‰ã€‚ ç¼–è¯‘å™¨ï¼šClangã€GCCã€MSVC ç­‰ã€‚ å¦‚æƒ³äº†è§£æ›´å¤šå…³äº libffi çš„ç»†èŠ‚ï¼Œå¯ä»¥æŸ¥çœ‹ libffi å®˜æ–¹ç½‘é¡µã€‚ ç¤ºä¾‹ : åœ¨è¿™ä¸ªç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨äº† libffi æ¥è°ƒç”¨æ ‡å‡†åº“å‡½æ•° putsï¼Œå¹¶ä¼ é€’äº†ä¸åŒçš„å­—ç¬¦ä¸²ä½œä¸ºå‚æ•°ã€‚è¿™ä¸ªç¤ºä¾‹å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨ libffi åŠ¨æ€åœ°è°ƒç”¨å¤–éƒ¨å‡½æ•°ã€‚ #include &lt;stdio.h&gt; #include &lt;ffi.h&gt; int main() { ffi_cif cif; ffi_type *args[1]; void *values[1]; char *s; ffi_arg rc; // åˆå§‹åŒ–å‚æ•°ä¿¡æ¯å‘é‡ args[0] = &amp;ffi_type_pointer; values[0] = &amp;s; // åˆå§‹åŒ– cif if (ffi_prep_cif(&amp;cif, FFI_DEFAULT_ABI, 1, &amp;ffi_type_sint, args) == FFI_OK) { s = \"Hello World!\"; ffi_call(&amp;cif, (void (*)(void))puts, &amp;rc, values); // rc ç°åœ¨ä¿å­˜äº†å¯¹ puts çš„è°ƒç”¨ç»“æœ // æ›´æ”¹ s çš„å€¼åï¼Œå¯ä»¥å†æ¬¡è°ƒç”¨ puts() s = \"This is cool!\"; ffi_call(&amp;cif, (void (*)(void))puts, &amp;rc, values); } return 0; }"
  },"/blog/jekyll/2002-06-11-Weston.html": {
    "title": "Weston Misc",
    "keywords": "Jekyll",
    "url": "/blog/jekyll/2002-06-11-Weston.html",
    "body": "1. å¯åŠ¨Weston 1.1 å®ç°å†…å®¹ è§£æcmdline åˆå§‹åŒ–logç³»ç»Ÿ åˆ›å»ºwl_displayå¯¹è±¡ï¼Œå¹¶ä¾¦å¬clientæ¥å…¥ åˆ›å»ºweston_compositorå¯¹è±¡ï¼Œä»è€Œåˆ›å»ºglobal resource compositor å’Œ shmï¼Œ ä»¥å‰å…¶ä»–èµ„æº load backendï¼Œ é»˜è®¤ä¸ºdrm_backend, åœ¨drm_backendåˆå§‹åŒ–çš„è¿‡ç¨‹ä¸­ä¼šload gl_renderer load shell, é»˜è®¤ä¸ºdesktop-shell.so è°ƒç”¨wl_display_run( ) å¾ªç¯ç­‰å¾…eventçš„å‘ç”Ÿ 1.2 ä¼ªä»£ç  int wet_main(int argc, char *argv[], const struct weston_testsuite_data *test_data){ // åˆå§‹åŒ– layoutput_list wl_list_init(&amp;wet.layoutput_list); ... // parse command line ... // init log system ... // è°ƒç”¨waylandæä¾›çš„å‡½æ•°wl_display_create() // åˆ›å»º wl_display å¯¹è±¡ display = wl_display_create(); ... // åˆ›å»º weston_compositor å¯¹è±¡ // --&gt; åˆ›å»º global resource compositor and shm ä»¥åŠå…¶ä»–resource weston_compositor_create( ); // è¯»å–config for compositor ... // load backendï¼Œé€šç”¨çš„ä¸ºload_drm_backend( ) // æœ€ç»ˆè°ƒç”¨ å¯¹åº”backendå®ç°çš„weston_backend_init( ) // åœ¨backend åˆå§‹åŒ–çš„è¿‡ç¨‹ä¸­ä¼šè£…è½½ gl_renderer load_backend(compositor, backend) ... // åˆ›å»ºsocketï¼Œ ä¾¦å¬clientçš„è¿æ¥è¯·æ±‚ weston_create_listening_socket(display, socket_name) ... // load shell, é»˜è®¤ä¸º desktop-shell.so wet_load_shell(compositor, shell, ...) ... // loop, å¾ªç¯ç­‰å¾…eventçš„å‘ç”Ÿ wl_display_run(display) ... // é€€å‡ºæµç¨‹ï¼Œèµ„æºçš„é‡Šæ”¾ } 1.3 backend, renderer, shellçš„ä½œç”¨ ç»“æ„å›¾ backend { destroy() repaint_begin() //compositeä¹‹å‰è°ƒç”¨ repaint_cancel() // ä¸­é€”å–æ¶ˆ repaint_flush() // composite å®Œæˆåè°ƒç”¨ï¼Œ å¯ç”¨äºå®ç°æäº¤åˆ°display create_output() // åˆ›å»ºweston_output device_changed() can_scanout_dmabuf() }Weston_backend, Compositor-&gt;backend renderer: rendereræ¥å£ä¾›backendå†…éƒ¨ä½¿ç”¨ï¼Œå¤–éƒ¨é€šè¿‡è°ƒç”¨backendæ¥å£è§¦å‘ { display_create() output_window_create() output_pbuffer_create() output_destroy() output_set_border() create_fence_fd() } gl_renderer_interface 2. Client åŠ¨ä½œ 2.1 Clientçš„æ¥å…¥å’Œglobalèµ„æºä»£ç†çš„åˆ›å»º æµç¨‹ è¿æ¥display è·å¾—registryï¼Œæ³¨å†Œlistenerï¼Œç”¨äºå¤„ç†westonèµ„æºå˜åŒ–æ—¶çš„callback æ ¹æ®èµ„æºå˜åŒ–çš„callbackï¼Œ åˆ›å»ºå„ç±»èµ„æºçš„proxy è¿›å…¥loopï¼Œä¸æ–­è°ƒç”¨wl_display_dispatch( )ï¼Œä½¿å¾—waylandå†…éƒ¨å¾ªç¯å¤„ç†å„ç±»event ä¼ªä»£ç  static void global_resource_found(void* data, struct wl_registry* registry, uint32_t name, const char* interface, uint32_t version) { // é€šè¿‡å­—ç¬¦ä¸²interface åˆ¤æ–­æ˜¯ä»€ä¹ˆresourceï¼Œ // é€šè¿‡wl_registry_bind() åˆ›å»ºå¯¹åº”çš„ resource proxy if (strcmp(interface, \"wl_compositor\") == 0) { // æ„å»ºäº† compositor çš„ proxy compositor = wl_registry_bind(registry, name, &amp;wl_compositor_interface, 4)); }else if (strcmp(interface, \"wl_shm\") == 0) { // æ„å»ºäº† shm çš„proxy shm = wl_registry_bind(registry, name, &amp;wl_shm_interface, 1); } ... } // å½“westonçš„global resoureå‘ç”Ÿå˜åŒ–æ—¶ï¼Œé€šè¿‡å¦‚ä¸‹å›è°ƒå‡½æ•°é€šçŸ¥åˆ°client wl_registry_listener registry_listener = { // å‘ç°æ–°global resourceçš„å›è°ƒå‡½æ•° global_resource_found, // global resource removeçš„å›è°ƒå‡½æ•° global_resource_remove } int main(int argc, char** argv) { // 1. è°ƒç”¨waylandæä¾›çš„ wl_display_connect( ), è¿æ¥åˆ°weston( wayland server) // å¯¹åº”åˆ°westonå¯åŠ¨ä¸­çš„weston_create_listening_socket() display = wl_display_connect(NULL); ... // 2. è·å– wl_registry, å¹¶ä¾¦å¬å®ƒçš„callback registry= wl_display_get_registry(display); wl_registry_add_listener(registry, &amp;registry_listener, display); ... // 3. å¾ªç¯ç­‰å¾…ï¼Œ // è°ƒç”¨wl_display_dispatch( )ï¼Œç”±waylandå¤„ç†westonå‘æ¥çš„event while(ret != -1){ ret = wl_display_dispatch( ); } } 2.2 å†…éƒ¨weston - client é€šè®¯æœºåˆ¶ request: Client â€“&gt; Server event : Server â€“&gt; Client æœ¯è¯­ä¸Šï¼ŒWayland ä¸­æŠŠ Client å‘ç»™ Server çš„è·¨è¿›ç¨‹å‡½æ•°è°ƒç”¨ç§°ä¸º requestï¼Œåæ–¹å‘çš„è·¨è¿›ç¨‹å‡½æ•°è°ƒç”¨ç§°ä¸º eventã€‚ æœ¬è´¨ä¸Šï¼Œå®ƒä»¬å¤„ç†çš„æ–¹å¼æ˜¯ç±»ä¼¼çš„ã€‚ è¦è®©ä¸¤ä¸ªè¿›ç¨‹é€šè¿‡ socket è¿›è¡Œå‡½æ•°è°ƒç”¨ï¼Œé¦–å…ˆéœ€è¦å°†è°ƒç”¨æŠ½è±¡æˆæ•°æ®æµçš„å½¢å¼ã€‚è¿™ä¸ªæ•°æ®æµåº”è¯¥åŒ…å«å‡½æ•°åã€å‚æ•°ç­‰ä¿¡æ¯ã€‚ IPC å‡½æ•°çš„æ¥å£å®šä¹‰æ˜¯åº”è¯¥åŒæ—¶åŒ…å«åœ¨ Client å’Œ Server ç«¯çš„åº“ä¸­çš„ï¼Œå…¶ä¸­åŒ…å«äº†æ¥å£å¯¹è±¡æ‰€æ”¯æŒçš„ request å’Œ event çš„å‡½æ•°ç­¾åã€‚å› æ­¤è¿™éƒ¨åˆ†ä¸ç”¨ä¼ è¾“ï¼Œåªè¦ä¼ è¾“ç›®æ ‡å¯¹è±¡ idï¼Œæ–¹æ³• id å’Œå‚æ•°åˆ—è¡¨è¿™äº›ä¿¡æ¯å°±å¯ä»¥äº†ã€‚ è¿™äº›ä¿¡æ¯ä¼šé€šè¿‡ wl_closure_marshal()å†™å…¥ wl_closure ç»“æ„ï¼Œå†ç”± serialize_closure()å˜æˆæ•°æ®æµã€‚ ç­‰åˆ°äº†ç›®æ ‡è¿›ç¨‹åï¼Œ ä¼šä»æ•°æ®æµé€šè¿‡ wl_connection_demarshal()è½¬å› wl_closureã€‚ IPC å›¾ç¤º object IPC æœºåˆ¶ è¿™ä¸ªè¿‡ç¨‹ç±»ä¼¼äº Android ä¸­çš„ Parcel æœºåˆ¶ã€‚é‚£ä¹ˆ é—®é¢˜æ¥äº†ï¼Œå‚æ•°ä¸­çš„æ•´å½¢ï¼Œå­—ç¬¦ä¸²ä»€ä¹ˆçš„éƒ½å¥½æï¼Œæ‹·è´å°±è¡Œã€‚ä½†å¦‚æœå‚æ•°ä¸­åŒ…å«å¯¹è±¡ï¼Œæˆ‘ä»¬ä¸èƒ½æŠŠæ•´ä¸ªå¯¹è±¡ æ‹·è´è¿‡å»ï¼Œä¹Ÿä¸èƒ½ä¼ å¼•ç”¨è¿‡å»ã€‚é‚£ä¹ˆéœ€è¦ä¸€ç§æœºåˆ¶æ¥ä½œåŒä¸€å¯¹è±¡åœ¨ Server å’Œ Client ç«¯çš„æ˜ å°„ï¼Œè¿™æ˜¯é€šè¿‡ wl_map å®ç°çš„ã€‚ wl_map åœ¨ Client å’Œ Server ç«¯å„æœ‰ä¸€ä¸ªï¼Œå®ƒä»¬åˆ†åˆ«å­˜äº† wl_proxy å’Œ wl_resource çš„æ•°ç»„ï¼Œä¸”æ˜¯ ä¸€ä¸€å¯¹åº”çš„ã€‚è¿™äº›å¯¹è±¡åœ¨è¿™ä¸ªæ•°ç»„ä¸­çš„ç´¢å¼•ä½œä¸ºå®ƒä»¬çš„ idã€‚è¿™æ ·ï¼Œå‚æ•°ä¸­çš„å¯¹è±¡åªè¦ä¼  idï¼Œè¿™ä¸ª id è¢«ä¼ åˆ°ç›® çš„åœ°åä¼šé€šè¿‡æŸ¥æ‰¾è¿™ä¸ª wl_map è¡¨æ¥å¾—åˆ°æœ¬åœ°ç›¸åº”çš„å¯¹è±¡ã€‚åœ¨åŠŸèƒ½ä¸Šç±»ä¼¼äº Android ä¸­çš„ BpXXX å’Œ BnXXXã€‚ wl_proxy å’Œ wl_resource éƒ½åŒ…å« wl_object å¯¹è±¡ã€‚è¿™ä¸ª wl_object å’Œé¢å‘å¯¹è±¡è¯­è¨€é‡Œçš„å¯¹è±¡æ¦‚å¿µç±»ä¼¼ï¼Œå®ƒæœ‰ interface æˆå‘˜æè¿°äº†è¿™ä¸ªå¯¹è±¡æ‰€å®ç°çš„æ¥å£ï¼Œimplementation æ˜¯è¿™äº›æ¥å£çš„å®ç°å‡½æ•°çš„å‡½æ•°æŒ‡é’ˆæ•°ç»„ï¼Œid å°±æ˜¯ åœ¨ wl_map ç»“æ„é‡Œæ•°ç»„ä¸­çš„ç´¢å¼•ã€‚ å‰é¢æ‰€è¯´çš„ Client ç»‘å®š Server ç«¯èµ„æºçš„è¿‡ç¨‹å°±æ˜¯åœ¨ Client ç«¯åˆ›å»º wl_proxyï¼Œ åœ¨ Server ç«¯åˆ›å»º wl_resourceã€‚ç„¶å Client å°±å¯ä»¥é€šè¿‡ wl_proxy è°ƒç”¨ Server ç«¯å¯¹åº” wl_resource çš„ requestï¼Œ Server ç«¯å°±å¯ä»¥é€šè¿‡ wl_resource è°ƒç”¨ Client ç«¯å¯¹åº” wl_proxy çš„ eventã€‚ è¿™ä¸ªæ˜ å°„è¿‡ç¨‹å¦‚ä¸‹å›¾æ‰€ç¤º(ä»¥ wl_registry ä¸ºä¾‹) 2.3 Client åˆ›å»ºå„ç±»èµ„æºproxy // wl_surface wl_surface = wl_compositor_create_surface(compositor) // wl_buffer wl_shm_pool = wl_shm_create_pool( ) wl_buffer = wl_shm_pool_create_buffer( ) // attach buffer to surface wl_surface_attach(wl_surface, wl_buffer) /* ä»¥ä¸‹ä¸çª—å£çš„ç®¡ç†\\æ˜¾ç¤ºç›¸å…³ */ // xdg_surface // xdg_wm_base å®ƒä¹Ÿæ˜¯ä¸€ä¸ªglobal resouceï¼Œå¯¹åº”åˆ° desktop-shell xdg_surface = xdg_wm_base_get_xdg_surface(xdg_wm_base, wl_surface) // xdg_toplevel xdg_toplevel = xdg_surface_get_toplevel(xdg_toplevel) // wl_keyboard // wl_seat æ˜¯ä¸€ä¸ªglobal resource // é€šè¿‡wl_keyboard åˆ›å»ºä¸€ä¸ªlistenerå°±å¯æ¥æ”¶æŒ‰é”® wl_keyboard = wl_seat_get_keyboard(wl_seat) wl_keyboard_add_listener(wl_keyboard, keyboard_listener) // wl_pointer é¼ æ ‡æŒ‡é’ˆ // é€šè¿‡wl_pointer åˆ›å»ºä¸€ä¸ªlistenerå¯ä»¥æ¥æ”¶é¼ æ ‡çš„ç§»åŠ¨ä¿¡æ¯ wl_pointre = wl_seat_get_pointer(wl_weat) wl_pointer_add_listener(wl_pointer, pointer_listener) ... ... 2.4 Client æ¸²æŸ“ ä¼ªä»£ç  simple-egl.c /*-------------------- egl åˆå§‹åŒ–å·¥ä½œ ------------------------*/ // egl lib åº”è¯¥è¦æ”¯æŒwaylandã€‚ // è¿™æ ·åœ¨è°ƒç”¨ä¸€äº›eglæ¥å£æ—¶ï¼Œåœ¨å…¶å†…éƒ¨ä¼šè°ƒç”¨waylandæ¥å£ä¸Wayland serveräº¤æ¢ä¿¡æ¯ // å¦‚å‡½æ•°ï¼šeglGetDisplay( ) , eglCreateWindowSurface( )ï¼Œ eglSwapBuffers ç­‰ // 1. è·å–egl_display egl_display = weston_platform_get_egl_display(EGL_PLATFORM_WAYLAND_KHR, wl_display, ...) or egl_display = eglGetDisplay(wl_display) // 2. åˆå§‹åŒ– egl eglInitialize(egl_display) // 3. é€šç”¨elg é…ç½® eglGetConfigs() eglChooseConfig( ) eglCreateContext( ) /* ----------------------gl å‡†å¤‡å·¥ä½œ------------------------------*/ // 1.åˆ›å»º shader glCreateShader( ) // 2.åˆ›å»º Program glCreateProgram( ) // 3. attach shader to program glAttachShader( ) // 4. Link program glLinkProgram( ) // 5. ä½¿ç”¨program glUseProgram( ) /*-------------------------wl_surface å…³è”egl_surface----------------*/ wl_egl_window-&gt;surface = wl_surface; wl_egl_window-&gt;width = width; wl_egl_window-&gt;height = height; eglCreateWindowSurface(egl_display, ... , wl_egl_window) /*------------------------------------------------------------------*/ gl ç»˜åˆ¶å›¾å½¢ /*-------------------------------------------------------------------*/ // å†…éƒ¨å®ç°åº”è¯¥è°ƒç”¨waylandæ¥å£æ¥swap buffer eglSwapBuffers(egl_display, egl_surface) ... 2.5. Client æäº¤æ¸²æŸ“å¥½çš„surface wl_surface_commit( ) 3. å„ä¸ªSurfaceçš„åˆæˆä¸å‘ˆç°å‘ˆç°Â· 3.1 æµç¨‹ compositoréå†æ¯ä¸ªweston_output å‘èµ·repaintã€‚weston_output_schedule_repaint( ) é€šçŸ¥weston_outputå…·ä½“å®ç°â€“backend_output, å¼€å§‹repaintçš„å‰æœŸå‡†å¤‡å·¥ä½œ, å¯¹åº”å‡½æ•°start_repaint_loop( )ï¼Œ drmå®ç°æš‚æ— å†…å®¹ backend_outputé€šçŸ¥compositorå¯ä»¥å¼€å§‹output repaint compositor è°ƒç”¨weston_outputç›¸å…³backendçš„repaint_begin( )ï¼Œdrm_backend åˆ›å»ºäº†pending_state compoistor è°ƒç”¨weston_output_repaint(), å¼€å§‹repaintã€‚ è°ƒç”¨weston_compositor_build_view_list( ) æ„å»ºview_list, å¾—åˆ°outputçš„ä¸€ä¸ªpaint_node_z_order_list è°ƒç”¨drm_backend assign_planes( ) è®¾ç½®è¾“å‡ºplane è°ƒç”¨drm_backend drm_output_repaint( ), æœ€ç»ˆæŒ‡å‘gl_renderer_repaint_output( ) ä¾æ®paint_node_z_order_list, OpenGLä¾æ¬¡å»ºç«‹shaderï¼Œtextureç­‰è¿›è¡Œæ¸²æŸ“ å…¨éƒ¨å®Œæˆåï¼Œæäº¤å‘ˆç° sequenceDiagram participant C as Compositor participant O as Weston_output participant B as Backend loop éå†weston_output_list C -&gt;&gt; O: è¦å¼€å§‹repaint_loop &lt;br /&gt;call backend_output start_repaint_loop( ) C -&gt;&gt; B: repaint_begin( ) Note right of B: åˆ›å»º pending_state C -&gt;&gt; O: é€šçŸ¥output repaint O -&gt;&gt; C: æ„å»ºview_list, build_view_list( ) Note left of C:æ„å»ºpaint_node_z_order_list C -&gt;&gt; B: assign_planes( ),è®¾ç½®è¾“å‡ºplane C -&gt;&gt; B: drm_output_repaint( ) Note right of B: è°ƒç”¨OpenGL API &lt;br/&gt;ç»“åˆpaint_node_z_order_list&lt;br/&gt;è¿›è¡Œæ¸²æŸ“ end"
  },"/blog/graphic/2002-05-15-Wayland&Weston.html": {
    "title": "Wayland&amp;Weston",
    "keywords": "graphic",
    "url": "/blog/graphic/2002-05-15-Wayland&Weston.html",
    "body": "1.ç¼–è¯‘ é¢„è®¾ç¯å¢ƒ $export WLD=â€œ~/xxxxxxxxxâ€ //å®šä¹‰ä¸€ä¸ªwaylandç›®å½•ï¼Œç¼–è¯‘ç”Ÿæˆåˆ°è¿™é‡Œ sudo apt install meson sudo apt install some_depenced_libs Wayland $ git clone https://gitlab.freedesktop.org/wayland/wayland.git $ cd wayland $ meson build/ --prefix=$WLD $ ninja -C build/ install $ cd .. Wayland protocols $ git clone https://gitlab.freedesktop.org/wayland/wayland-protocols.git $ cd wayland-protocols $ meson build/ --prefix=$WLD $ ninja -C build/ install $ cd .. Weston $ git clone https://gitlab.freedesktop.org/wayland/weston.git $ cd weston $ meson build/ --prefix=$WLD $ ninja -C build/ install $ cd .. ç¬¬ä¸‰æ–¹ä¾èµ–åº“çš„ç¼–è¯‘ éœ€è¦çš„ç¬¬ä¸‰æ–¹åº“ Libxml2-dev Libexpat-dev Libffi-dev Libinput-dev Libdrm-dev Libxkbcommon-dev libpixman-1-dev libcairo2-dev libudev å®ƒä»¬æœ‰çš„é€šè¿‡configureé…ç½®ç„¶åmakeï¼Œ æœ‰çš„é€šè¿‡mesa, ninjaç¼–è¯‘. éœ€è¦æ³¨æ„è®¾ç½®æ­£ç¡®çš„PKG_CONFIG_PATHï¼Œä½¿çš„pkg-configå¯ä»¥æ‰¾åˆ°ç›¸å…³çš„åº“ä¿¡æ¯ã€‚ å¦‚æœæ˜¯mesaï¼Œç•™æ„ç›®å½•ä¸‹æ˜¯å¦æœ‰meson_options.txt, å…¶ä¸­å®šä¹‰äº†å„ç§ç¼–è¯‘é€‰é¡¹ï¼Œå¯å¯¹å®ƒè¿›è¡Œä¿®æ”¹ã€‚ meson äº¤å‰ç¼–è¯‘ åœ¨mesonç³»ç»Ÿä¸­è¿›è¡Œäº¤å‰ç¼–è¯‘ï¼Œéœ€è¦ä¸ºmesonä¸­æ·»åŠ å‚æ•° â€“cross-file xxx_filename, åœ¨xxx_filenameä¸­å®šä¹‰gccç­‰çš„è·¯å¾„è·¯å¾„ ä¸‹é¢æ˜¯ä¸€ä¸ªç¤ºä¾‹ [binaries] c = '/opt/cross-arm/bin/arm-linux-gnueabihf-gcc' cpp = '/opt/cross-arm/bin/arm-linux-gnueabihf-g++' ld ='/opt/cross-arm/bin/arm-linux-gnueabihf-ld' strip= '/opt/cross-arm/bin/arm-linux-gnueabihf-strip' pkgconfig ='/usr/bin/pkg-config' [host_machine] system = 'linux' cpu_family = 'aarch64' cpu = 'cortex-a73' endian = 'little åœ¨configureç³»ç»Ÿä¸­ï¼Œåˆ™æ˜¯export GCC CFLAG ç­‰ç¯å¢ƒå˜é‡ æŒ‡å®šè¾“å…¥è¾“å‡º meson build_dir/ sourc_code_dir/ 2.è¿è¡Œ configure file copy weston.ini to ~/.config/ run weston. login as root ./weston â€“tty=2 Ctrl+Alt+Backspace â€“&gt; é€€å‡ºWestonç•Œé¢ å¦‚ä¸€èˆ¬ç”¨æˆ·å¯åŠ¨westonï¼Œè¿™æ—¶è¦å€ŸåŠ©weston-launch æ¥å®Œæˆã€‚ ç›¸å…³codeï¼šlibweston/weston-launch.c run weston-client test login as root export WAYLAND_DISPLAY=wayland-1 ç¤ºä¾‹1, æŒ‡å®šbackend å’Œshell Server: ./weston --tty=2 --shell=fullscreen-shell.so --backend= drm-backend.so Client: weston-simple-dmabuf-egl ç¤ºä¾‹2 Serverï¼š./weston --tty=2 --shell=fullscreen-shell.so --backend=fbdev-backend.so Client./weston-simple-damage 3.Wayland 3.1 codeçš„ç»„æˆ waylandä¸»è¦ç”±ä¸‰éƒ¨åˆ†ç»„æˆã€‚ Waylandæä¾›äº†protocolçš„å®šä¹‰æ–¹å¼ åœ¨è·¯å¾„protocolæ–‡ä»¶å¤¹ä¸‹ï¼Œä»¥xmlçš„å½¢å¼å®šä¹‰äº†Waylandçš„æ ¸å¿ƒåè®®ã€‚ å¦‚ä¸‹é¢çš„xmlï¼Œå°±å®šä¹‰äº†wl_display &lt;interface name=\"wl_display\" version=\"1\"&gt; &lt;description summary=\"core global object\"&gt; The core global object. This is a special singleton object. It is used for internal Wayland protocol features. &lt;/description&gt; ..... &lt;/interface&gt; xmlåˆ°codeçš„è½¬æ¢å·¥å…· xmlåˆ°codeçš„è½¬æ¢å·¥å…·æ˜¯wayland-scannerï¼Œå®ƒçš„source codeåœ¨waylandç›®å½•ä¸‹ï¼Œå¯é€šè¿‡ç¼–è¯‘ç”Ÿæˆå®ƒã€‚ waylandè¿˜å®ç°äº†ä¸€ä¸ªé«˜æ•ˆç‡çš„ Server+Clienté€šä¿¡æ¨¡å¼ Serverç«¯ï¼Œä¸»è¦æ˜¯ä½¿ç”¨epoll+socketç›‘å¬Clientç«¯äº‹ä»¶ï¼Œå¹¶å¯¹æ”¶åˆ°çš„æ¶ˆæ¯ååºåˆ—åŒ–ã€‚ Clientç«¯ï¼šwayland-clientæä¾›äº†å·²å®ç°çš„åºåˆ—åŒ–æ¥å£ æ€»ä¹‹ï¼Œå®˜æ–¹æä¾›çš„Waylandæºç ï¼Œä¸»è¦åŒ…æ‹¬åè®®çš„å®šä¹‰ã€åè®®åˆ°ä»£ç çš„ç”Ÿæˆå·¥å…·ï¼Œä»¥åŠä¸€å¥—å®ç°å¥½çš„é€šä¿¡æ¨¡å‹ 3.2 åŸºç¡€æ¦‚å¿µ å‡ ä¹æ‰€æœ‰çš„Wayland APIéƒ½éœ€è¦Waylandå…¨å±€å¯¹è±¡ä½œä¸ºå‚æ•°ã€‚ åç§° ä½œç”¨ wl_display è¡¨ç¤ºä¸æœåŠ¡å™¨çš„è¿æ¥ã€‚ wl_registry å…¨å±€å¯¹è±¡æ³¨å†Œè¡¨ï¼Œå…¨å±€å¯¹è±¡éœ€è¦é€šè¿‡å®ƒè·å–ã€‚ wl_compositor çª—å£åˆæˆå™¨ï¼Œä¹Ÿæ˜¯æœåŠ¡å™¨ã€‚ wl_shm å†…å­˜ç®¡ç†å™¨ï¼Œä¸çª—å£åˆæˆå™¨å…±äº«å†…å­˜ç”¨ã€‚ wl_shell æ”¯æŒçª—å£æ“ä½œåŠŸèƒ½ã€‚ wl_seat è¾“å…¥è®¾å¤‡ç®¡ç†å™¨ã€‚ ã€‚ é€šè¿‡capabilities( )å›è°ƒå‡½æ•°å¾—åˆ°pointerã€keyboardç­‰ wl_pointer ä»£è¡¨é¼ æ ‡è®¾å¤‡ã€‚ wl_keyboard ä»£è¡¨é”®ç›˜è®¾å¤‡ã€‚ Waylandæ²¡æœ‰æä¾›Getå‡½æ•°æ¥è·å–ä»¥ä¸Šå…¨å±€å¯¹è±¡ï¼Œåªèƒ½é€šè¿‡wl_registryè·å–å…¨å±€å¯¹è±¡ 3.2.1 Clientç«¯objectçš„ä½¿ç”¨ Waylandä¸­serveræä¾›ç»™clientä½¿ç”¨çš„å¯¹è±¡å¯ä»¥å½’ä¸º global objectå’Œ resource objectã€‚ Global ä¹Ÿæ˜¯ä¸€ä¸­resourceã€‚ Global objectå¦‚ wl_display, wl_compositor, wl_seat ç­‰ã€‚ å®ƒä»¬åœ¨clientç«¯æ˜¯é€šè¿‡bindæ¥è·å–åˆ°ä¸€ä¸ªclient å¯¹åº”å¯¹è±¡ï¼Œç„¶åå°±å¯ä»¥å¯¹å®ƒè¿›è¡Œæ“ä½œ Resource object åœ¨clientç«¯æ˜¯é€šè¿‡Global object æ¥åˆ›å»ºçš„ï¼Œ å¦‚ wl_surface, wl_shell_surface ç­‰ã€‚ 3.2.2 Serverç«¯objectçš„å®ç° Global èµ„æºçš„åˆ›å»ºï¼š wayland/src/wayland-server.c wl_global_create( â€¦., bind_xxx_function ) bind_xxx_function // åœ¨clientä¸­è°ƒç”¨wl_registry_bindå‡½æ•°æ—¶è¢«call wl_resource_create( ) wayland protocal æä¾›çš„æ¥å£ï¼Œåˆ›å»ºä¸€ä¸ªresource objectï¼Œå¹¶æŠŠå®ƒæ’å…¥åˆ°clientçš„mapè¡¨ä¸­ï¼Œä»¥åå°±å¯ä»¥é€šè¿‡ID æ‰¾åˆ°å¯¹åº”çš„resource objï¼Œæœ‰åˆ©äºserver&lt;â€“&gt;client é€šè®¯è°ƒç”¨å¯¹åº”å‡½æ•° wl_resource_set_implementation( ) // è®¾å®šèµ„æºæ¥å£çš„å®ç°, å¯ä¾›clienté€šè¿‡IPCè°ƒç”¨ wl_priv_signal_emit( ) // wl_client_add_resource_created_listener will be notified æ™®é€š Resource çš„åˆ›å»ºï¼š åº”è¯¥æ˜¯ç”±æŸäº› å¯¹global èµ„æºçš„æ“ä½œè§¦å‘ wl_resource_create() wl_resource_set_implementation( ) 3.2.3 Client Serveré€šè®¯ Listener æ˜¯server â€“&gt; client çš„é€šçŸ¥æ–¹å¼. Client æ³¨å†Œlistener ç»™serverï¼Œæœ‰ç›‘å¬äº‹ä»¶å‘ç”Ÿï¼Œserverå‘ä¿¡æ¯ç»™client. Serverä¾§å‘ç”Ÿé€šçŸ¥çš„å‡½æ•°å‘½åç‰¹å¾: xxxx_send_xxxx( ) 3.2.4 Wayland Serverå®ç° 3.2.4 Wayland Clientå®ç° 3.3 ç®€å•çš„wayland app æµç¨‹ 3.4 Wayland log éœ€è®¾ç½®ç¯å¢ƒå˜é‡ï¼š export WAYLAND_DEBUG=1 3.5 xml å…¶ä¸­æœ€é‡è¦çš„wayland.xmlä¸­å®šä¹‰äº†å¦‚ä¸‹æ¥å£ï¼š ./wayland/protocol/wayland.xml wl_display wl_registry wl_callback wl_compositor wl_shm_pool wl_shm wl_buffer wl_data_offer wl_data_source wl_data_device wl_data_device_manager wl_shell wl_shell_surface wl_surface wl_seat wl_pointer wl_keyboard wl_touch wl_output wl_region wl_subcompositor wl_subsurface 3.6 åœ¨çº¿æŸ¥çœ‹ waylandåè®® å„ç§åè®®æŸ¥çœ‹ https://wayland.app/ The Wayland Protocol ä¸­æ–‡ç‰ˆ https://wayland.arktoria.org/ 4.Weston ç®€ä»‹ Westonæ˜¯åŸºäºwaylandåè®®ï¼Œå®ç°çš„Compositorã€‚ Westonçš„å…¥å£åœ¨ï¼ˆè¿™é‡Œä»¥10.0.0ä¸ºä¾‹ï¼‰: weston-10.0.0./compositor/main.c weston-10.0.0./compositor/executable.c 4.1 æ¡†æ¶ä¸å¯¹è±¡ æ¡†æ¶ Westonä¸­æœ‰ä»¥ä¸‹å‡ ä¸ªä¸»è¦éƒ¨åˆ†ï¼šShellã€Compositorã€Renderã€backendã€Input Shellï¼šçª—å£ç®¡ç†å™¨ï¼Œç”»é¢å±‚çº§ã€çª—å£ä¿¡æ¯ã€çª—å£ç”Ÿå‘½å‘¨æœŸã€Focusçª—å£ç­‰ç­‰ä¸€äº›åå‘äºä¸šåŠ¡å±‚çš„å¤„ç†ã€‚é»˜è®¤çš„shellä¸ºdesktop-shellï¼ŒåŒæ—¶æä¾›äº†å…¶ä»–shellå®ç°ï¼ˆå¦‚ivi-shellï¼‰ Compositorï¼šè´Ÿè´£ç”»é¢çš„åˆæˆï¼Œä½¿ç”¨DRMè¿æ¥outputï¼Œå°†ç”»é¢è¾“å‡ºåˆ°å®é™…æ˜¾ç¤ºè®¾å¤‡ã€‚ Renderï¼šè´Ÿè´£æ¸²æŸ“ï¼Œæ¯”å¦‚gl-renderï¼Œåšä¸€äº›çº¹ç†è´´å›¾æ“ä½œã€‚ Inputï¼šlibinputæ¨¡å—ï¼Œä¸evdevã€uvdevæ¨¡å—äº¤äº’ï¼Œä»åº•å±‚è®¾å¤‡èŠ‚ç‚¹æ¥æ”¶touchã€keyç­‰è¾“å…¥ backend: Weston ä½¿ç”¨åç«¯çš„æ¦‚å¿µæ¥æŠ½è±¡å…¶è¿è¡Œç¯å¢ƒçš„åº•å±‚æ¥å£ã€‚åç«¯è´Ÿè´£å¤„ç†è¾“å…¥å’Œç”Ÿæˆè¾“å‡º å¯¹è±¡ 4.2 mainå‡½æ•°çš„åŸºæœ¬æ¡†æ¶ å®ç°å†…å®¹ï¼š è§£æcmdline åˆå§‹åŒ–logç³»ç»Ÿ åˆ›å»ºwl_displayå¯¹è±¡ï¼Œå¹¶ä¾¦å¬clientæ¥å…¥ åˆ›å»ºweston_compositorå¯¹è±¡ï¼Œä»è€Œåˆ›å»ºglobal resource compositor å’Œ shmï¼Œ ä»¥å‰å…¶ä»–èµ„æº load backendï¼Œ é»˜è®¤ä¸ºdrm_backend, åœ¨drm_backendåˆå§‹åŒ–çš„è¿‡ç¨‹ä¸­ä¼šload gl_renderer load shell, é»˜è®¤ä¸ºdesktop-shell.so è°ƒç”¨wl_display_run( ) å¾ªç¯ç­‰å¾…eventçš„å‘ç”Ÿ int wet_main(int argc, char *argv[], const struct weston_testsuite_data *test_data){ // åˆå§‹åŒ– layoutput_list wl_list_init(&amp;wet.layoutput_list); ... // parse command line ... // init log system ... // è°ƒç”¨waylandæä¾›çš„å‡½æ•°wl_display_create() // åˆ›å»º wl_display å¯¹è±¡ display = wl_display_create(); ... // åˆ›å»º weston_compositor å¯¹è±¡ // --&gt; åˆ›å»º global resource compositor and shm ä»¥åŠå…¶ä»–resource weston_compositor_create( ); // è¯»å–config for compositor ... // load backendï¼Œé€šç”¨çš„ä¸ºload_drm_backend( ) // æœ€ç»ˆè°ƒç”¨ å¯¹åº”backendå®ç°çš„weston_backend_init( ) // åœ¨backend åˆå§‹åŒ–çš„è¿‡ç¨‹ä¸­ä¼šè£…è½½ gl_renderer load_backend(compositor, backend) ... // åˆ›å»ºsocketï¼Œ ä¾¦å¬clientçš„è¿æ¥è¯·æ±‚ weston_create_listening_socket(display, socket_name) ... // load shell, é»˜è®¤ä¸º desktop-shell.so wet_load_shell(compositor, shell, ...) ... // loop, å¾ªç¯ç­‰å¾…eventçš„å‘ç”Ÿ wl_display_run(display) ... // é€€å‡ºæµç¨‹ï¼Œèµ„æºçš„é‡Šæ”¾ } 4.3 backendåˆ›å»º Weston ä½¿ç”¨åç«¯çš„æ¦‚å¿µæ¥æŠ½è±¡å…¶è¿è¡Œç¯å¢ƒçš„åº•å±‚æ¥å£ã€‚åç«¯è´Ÿè´£å¤„ç†è¾“å…¥å’Œç”Ÿæˆè¾“å‡ºã€‚ ä½œä¸º libweston çš„ç”¨æˆ·ï¼ŒWeston å¯ä»¥åœ¨ä¸åŒçš„åç«¯ä¸Šè¿è¡Œï¼ŒåŒ…æ‹¬åµŒå¥—åœ¨å…¶ä»– Wayland åˆæˆå™¨ä¸­çš„æ–¹å¼ï¼ˆä½¿ç”¨ wayland åç«¯ï¼‰ï¼Œä¹Ÿå¯ä»¥åœ¨ X11 ä¸Šè¿è¡Œï¼Œæˆ–è€…åœ¨ç‹¬ç«‹çš„åç«¯ä¸Šè¿è¡Œï¼Œä¾‹å¦‚ DRM/KMSã€‚ å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œäººä»¬åº”è¯¥å…è®¸ Weston è‡ªåŠ¨é€‰æ‹©åç«¯ï¼Œå› ä¸ºå®ƒä¼šäº§ç”Ÿæœ€ä½³ç»“æœã€‚ä¾‹å¦‚ï¼Œåœ¨å·²ç»è¿è¡Œå¦ä¸€ä¸ªå›¾å½¢ç¯å¢ƒçš„æœºå™¨ä¸Šè¿è¡Œ Weston æ—¶ï¼Œå®ƒä¼šè‡ªåŠ¨é€‰æ‹©åˆé€‚çš„åç«¯ï¼Œæ— è®ºæ˜¯å¦ä¸€ä¸ª Wayland åˆæˆå™¨è¿˜æ˜¯ X11 æœåŠ¡å™¨ã€‚ åªæœ‰åœ¨ä½ çŸ¥é“ Weston è‡ªåŠ¨é€‰æ‹©çš„åç«¯ä¸æ˜¯æœ€ä½³é€‰æ‹©ï¼Œæˆ–è€…ä½ æƒ³ä½¿ç”¨ä¸åŒäºé»˜è®¤åŠ è½½çš„åç«¯æ—¶ï¼Œæ‰éœ€è¦æ‰‹åŠ¨æŒ‡å®šåç«¯ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¯ä»¥ä½¿ç”¨ -B [backend] å‘½ä»¤è¡Œé€‰é¡¹æ¥é€‰æ‹©åç«¯ã€‚ å¯ç”¨çš„åç«¯åŒ…æ‹¬ï¼š drmï¼šç‹¬ç«‹è¿è¡Œåœ¨ DRM/KMS å’Œ evdev ä¸Šï¼ˆæ¨èï¼‰ã€‚ waylandï¼šä½œä¸º Wayland åº”ç”¨ç¨‹åºåµŒå¥—åœ¨å¦ä¸€ä¸ª Wayland åˆæˆå™¨å®ä¾‹ä¸­ã€‚ x11ï¼šä½œä¸º X11 åº”ç”¨ç¨‹åºåµŒå¥—åœ¨ X11 æ˜¾ç¤ºæœåŠ¡å™¨å®ä¾‹ä¸­ã€‚ rdpï¼šä½œä¸ºä¸€ä¸ªæ²¡æœ‰æœ¬åœ°è¾“å…¥æˆ–è¾“å‡ºçš„ RDP æœåŠ¡å™¨è¿è¡Œã€‚ headlessï¼šæ— è¾“å…¥æˆ–è¾“å‡ºè¿è¡Œï¼Œé€‚ç”¨äºæµ‹è¯•å¥—ä»¶ã€‚ pipewireï¼šæ— è¾“å…¥ï¼Œè¾“å‡ºåˆ° PipeWire èŠ‚ç‚¹ã€‚ weston_backend_init { destroy() repaint_begin() //compositeä¹‹å‰è°ƒç”¨ repaint_cancel() // ä¸­é€”å–æ¶ˆ repaint_flush() // composite å®Œæˆåè°ƒç”¨ï¼Œ å¯ç”¨äºå®ç°æäº¤åˆ°display create_output() // åˆ›å»ºweston_output device_changed() can_scanout_dmabuf() }Weston_backend, Compositor-&gt;backend 4.4 shellåˆ›å»º westonæä¾›äº†å¤šç§shellï¼Œæ¯”å¦‚ï¼šdesktop shellï¼Œivi-shell, kiosk shell, fullscreen shellç­‰ 4.5 headå’Œoutput weston_head å’Œ weston_output æ˜¯libwestonä¸­çš„ä¸¤ä¸ªå…³é”®æ¦‚å¿µï¼Œç”¨äºç®¡ç†æ˜¾ç¤ºè¾“å‡ºå’Œå›¾åƒå‘ˆç°ã€‚ weston_headï¼ˆå¤´éƒ¨ï¼‰ weston_head è¡¨ç¤ºä¸€ä¸ªè¿æ¥å™¨æˆ–ç›‘è§†å™¨ã€‚ åœ¨ç¡¬ä»¶é©±åŠ¨ä¸­ï¼Œå¤´éƒ¨é€šå¸¸æŒ‡çš„æ˜¯ä¸€ä¸ªæ˜¾ç¤ºå™¨ï¼Œä½†å®ƒä¹Ÿå¯ä»¥æ˜¯å¦ä¸€ä¸ªçª—å£ç³»ç»Ÿä¸­çš„çª—å£ï¼Œæˆ–è€…æ˜¯ä¸€ä¸ªè™šæ‹Ÿæ¦‚å¿µã€‚ å¤´éƒ¨æ˜¯ä¸€ä¸ªå¯ä»¥å‘ˆç°å›¾åƒçš„ä½ç½®ã€‚ weston_head è´Ÿè´£ä»¥ä¸‹ä»»åŠ¡ï¼š ç®¡ç†å¸§ç¼“å†²åŒºã€‚ è·Ÿè¸ªæŸååŒºåŸŸã€‚ å¤„ç†æ˜¾ç¤ºæ—¶åºã€‚ ç®¡ç†é‡ç»˜çŠ¶æ€æœºã€‚ åœ¨æ˜¾ç¤ºç¡¬ä»¶ä¸­ï¼Œweston_head è¡¨ç¤ºä¸€ä¸ªCRTCï¼ˆæ˜¾ç¤ºæ§åˆ¶å™¨ï¼‰ï¼Œä½†ä»…åœ¨æˆåŠŸå¯ç”¨åæ‰ä¼šå¦‚æ­¤ã€‚åœ¨å¤´éƒ¨çš„ç”Ÿå‘½å‘¨æœŸå†…ï¼ŒCRTC å¯èƒ½ä¼šåˆ‡æ¢åˆ°å¦ä¸€ä¸ªã€‚ weston_head çš„ç”Ÿå‘½å‘¨æœŸç”±libwestonç”¨æˆ·æ§åˆ¶ã€‚ æ‚¨å¯ä»¥é€šè¿‡å°†è‡³å°‘ä¸€ä¸ªweston_head é™„åŠ åˆ°weston_output æ¥æ„å»ºä¸€ä¸ªå¯ä¾›åˆæˆå™¨ä½¿ç”¨çš„weston_output å¯¹è±¡ï¼Œç„¶åä½¿ç”¨ weston_output_enable() å¯ç”¨è¯¥è¾“å‡ºã€‚å·²å¯ç”¨çš„è¾“å‡ºæ— æ³•é‡æ–°é…ç½®ï¼Œä½†è¿™åœ¨æœªæ¥å¯èƒ½ä¼šå‘ç”Ÿå˜åŒ–ã€‚æ‚¨å¯ä»¥ä½¿ç”¨ weston_output_disable() æ¥ç¦ç”¨ä¸€ä¸ªè¾“å‡ºï¼Œç„¶åé‡æ–°é…ç½®å®ƒï¼Œä½†è¿™ä¼šå¯¼è‡´å¯è§çš„æ•…éšœã€‚ weston_outputï¼ˆè¾“å‡ºï¼‰ weston_output å†³å®šäº†å…¨å±€åˆæˆå™¨åæ ‡ç©ºé—´çš„å“ªä¸€éƒ¨åˆ†å°†è¢«åˆæˆæˆå›¾åƒä»¥åŠä½•æ—¶è¿›è¡Œåˆæˆã€‚ è¯¥å›¾åƒåœ¨é™„åŠ çš„å¤´éƒ¨ä¸Šå‘ˆç°ã€‚ weston_output è´Ÿè´£ä»¥ä¸‹ä»»åŠ¡ï¼š å¸§ç¼“å†²åŒºç®¡ç†ã€‚ æŸååŒºåŸŸè·Ÿè¸ªã€‚ æ˜¾ç¤ºæ—¶åºã€‚ é‡ç»˜çŠ¶æ€æœºã€‚ è§†é¢‘æ¨¡å¼ã€è¾“å‡ºæ¯”ä¾‹å’Œè¾“å‡ºå˜æ¢æ˜¯è¾“å‡ºçš„å±æ€§ã€‚ åœ¨æ˜¾ç¤ºç¡¬ä»¶ä¸­ï¼Œweston_output è¡¨ç¤ºä¸€ä¸ªCRTCï¼Œä½†ä»…åœ¨æˆåŠŸå¯ç”¨åæ‰ä¼šå¦‚æ­¤ã€‚CRTC å¯èƒ½ä¼šåœ¨è¾“å‡ºçš„ç”Ÿå‘½å‘¨æœŸå†…åˆ‡æ¢åˆ°å¦ä¸€ä¸ªã€‚ weston_output çš„ç”Ÿå‘½å‘¨æœŸç”±libwestonç”¨æˆ·æ§åˆ¶ã€‚ ä¸‹é¢æ˜¯å„ç§caseçš„æµç¨‹å›¾ Heads are being created on compositor start-up with a backend that manages head lifetimes completely on its own A compositor handles libweston notification of something with heads having changed. This happens on both compositor start-up and later due to hotplug A compositor creates and configures an output for a head or heads it wants to light up. A compositor finds out a head has been disconnected and proceeds to destroy the corresponding output. The backend realises that a piece of hardware has disappeared and needs to destroy the corresponding head. The head is released, and even when the compositor is not listening for head destroy signal, the output gets automatically disabled, though not destroyed. 4.6 layer, view, surface 4.7 create_surface 4.8 get_shell_surface 4.9 create_pool 4.10 surface_attach surface_damage 4.11 surface_commit 4.12 share buffer 4.12.1 create_shm_buffer 4.12.2 import dmabuf Client åŸºæœ¬æµç¨‹å¦‚ä¸‹ï¼š ç»‘å®š linux_dmabuf wl_registry_bind(zwp_linux_dmabuf_v1_interface ) åˆ›å»ºä¸€ä¸ªparamå¯¹è±¡ zwp_linux_dmabuf_v1_create_params( zwp_linux_dmabuf_v1) åœ¨paramä¸­è®¾ç½®dmbufçš„å„ç§ä¿¡æ¯(fdï¼Œwidthï¼Œ height), YUVæ—¶ï¼Œé€šè¿‡æ•°ç»„å¯¼å…¥å¤šä¸ªplaneä¿¡æ¯ zwp_linux_buffer_params_v1_add(dmabuf_fd) å¯¹paramå¯¹è±¡æ·»åŠ listener zwp_linux_buffer_params_v1_add_listener() ä¾æ®paramåœ¨Serverä¾§å¯¼å…¥dmabufå¯¹è±¡ zwp_linux_buffer_params_v1_create( ) é€šè¿‡callbackæ¥æ”¶å¯¼å…¥ç»“æœ params_listener callback create_succeeded() 4.13 weston event loop 4.14 weston idle å¤„ç† 4.15 gl-renderer westonä¸­çš„å‡ ä¸ªrenderer 4.16 libinput source codeï¼šhttps://gitlab.freedesktop.org/libinput/libinput ä¸ºäº†æé«˜è¾“å…¥ç®¡ç†éƒ¨åˆ†çš„æ¨¡å—æ€§ï¼ŒWestonå°†å¯¹è¾“å…¥è®¾å¤‡(é”®ç›˜ï¼Œé¼ æ ‡ï¼Œè§¦æ‘¸å±ç­‰)çš„å¤„ç†åˆ†ç¦»åˆ°ä¸€ä¸ªå•ç‹¬çš„åº“ï¼Œä¹Ÿå°±æ˜¯libinput ä¸­ã€‚å…·ä½“åœ°ï¼Œå®ƒæä¾›äº†è®¾å¤‡æ£€æµ‹ï¼Œè®¾å¤‡å¤„ç†ï¼Œè¾“å…¥äº‹ä»¶å¤„ç†ç­‰åŸºæœ¬åŠŸèƒ½ï¼Œç±»ä¼¼äºAndroid ä¸­çš„EventHubã€‚æ­¤å¤–å®ƒè¿˜æœ‰pointer acceleration, touchpad support åŠgesture recognitionç­‰åŠŸèƒ½ã€‚ libinputæ›´åƒæ˜¯ä¸€ä¸ªæ¡†æ¶ï¼Œå®ƒå°†å‡ ä¸ªæ›´åº•å±‚çš„åº“çš„åŠŸèƒ½æ•´åˆèµ·æ¥ã€‚å®ƒä¸»è¦ä¾èµ–äºä»¥ä¸‹å‡ ä¸ªåº“: mtdev: Multi-touch è®¾å¤‡å¤„ç†ï¼Œæ¯”å¦‚å®ƒä¼šå°†ä¸å¸¦tracking IDçš„protocol Aè½¬åŒ–ä¸º protocol Bã€‚ libevdev: ä¸kernelä¸­evdev æ¨¡å—å¯¹æ¥ã€‚ libudev:ä¸»è¦ç”¨äºå’Œ udevd(userspace device)çš„é€šä¿¡ï¼Œä»è€Œè·å–è®¾å¤‡çš„å¢åŠ åˆ é™¤äº‹ä»¶ã€‚ä¹Ÿå¯ä»kernelè·å–ã€‚ Weston ä¸­çš„è¾“å…¥ç®¡ç†æ¨¡å—ä¸libinputå¯¹æ¥ï¼Œå®ƒå®ç°äº†ä¸¤å¤§éƒ¨åˆ†çš„åŠŸèƒ½: å¯¹è¾“å…¥è®¾å¤‡çš„ç»´æŠ¤ï¼Œ å¯¹è¾“å…¥äº‹ä»¶çš„å¤„ç†ã€‚ å¯¹äºè¾“å…¥äº‹ä»¶æ—¢ä¼šåœ¨Westonä¸­åšå¤„ç†ï¼Œä¹Ÿä¼šä¼ ç»™ç›¸åº”çš„ clientã€‚ ä»äº‹ä»¶å¤„ç†æ¨¡å‹ä¸Šæ¥çœ‹ï¼Œlibinputä¸»å¾ªç¯ç›‘å¬udev monitor fdï¼Œå®ƒä¸»è¦ç”¨äºç›‘å¬è®¾å¤‡çš„æ·»åŠ åˆ é™¤äº‹ä»¶ã€‚å¦‚æœæœ‰è®¾å¤‡æ·»åŠ ï¼Œä¼šæ‰“å¼€è¯¥è®¾å¤‡å¹¶æŠŠfdåŠ å…¥åˆ°libinputçš„ä¸»å¾ªç¯ä¸Šã€‚å¦ä¸€æ–¹é¢ï¼ŒWestonä¸­ä¼šå°† libinput çš„ epoll fdåŠ å…¥ä¸»å¾ªç¯ã€‚è¿™æ ·å½¢æˆçº§è”çš„epollï¼Œæ— è®ºæ˜¯ udev monitor è¿˜æ˜¯input deviceçš„fdæœ‰äº‹ä»¶æ¥ï¼Œéƒ½ä¼šé€šçŸ¥åˆ°Westonå’Œlibinputçš„ä¸»å¾ªç¯ã€‚ Westonä¸­æ”¯æŒä¸‰ç§è¾“å…¥è®¾å¤‡ï¼Œåˆ†åˆ«æ˜¯é”®ç›˜ï¼Œè§¦æ‘¸å’Œé¼ æ ‡ã€‚ä¸€å¥—è¾“å…¥è®¾å¤‡å±äºä¸€ä¸ªseat(ä¸¥æ ¼æ¥è¯´ï¼Œseatä¸­åŒ…æ‹¬ä¸€å¥—è¾“å…¥è¾“å‡ºè®¾å¤‡)ã€‚å› æ­¤ï¼Œweston_seat ä¸­åŒ…å«weston_keyboard,weston_pointer å’Œweston_touchä¸‰ä¸ªç»“æ„ã€‚ç³»ç»Ÿä¸­å¯ä»¥æœ‰å¤šä¸ªseat,å®ƒä»¬çš„ç»“æ„è¢«ä¸²åœ¨weston_compositor çš„ seat_listé“¾è¡¨ä¸­ã€‚ å¯ä»¥çœ‹åˆ°ï¼Œå¯¹äºç„¦ç‚¹å¤„ç†ï¼Œæ¯ä¸ªè®¾å¤‡æœ‰è‡ªå·±çš„focus,å®ƒæŒ‡å‘ç„¦ç‚¹çª—å£ï¼Œç”¨äºæ‹–æ‹½å’Œè¾“å…¥ç­‰ã€‚æˆå‘˜focus_resource_list ä¸­åŒ…å«äº†ç„¦ç‚¹çª—å£æ‰€åœ¨clientä¸­è¾“å…¥è®¾å¤‡ proxyå¯¹åº”çš„ resource å¯¹è±¡ã€‚åœ¨è¿™ä¸ª list ä¸­æ„å‘³ç€å¯ä»¥æ¥æ”¶åˆ°ç›¸åº”çš„äº‹ä»¶ã€‚ å¯¹äºç„¦ç‚¹å¤„ç†ï¼Œæ¯ä¸ªè®¾å¤‡æœ‰è‡ªå·±çš„ focusï¼Œå®ƒæŒ‡å‘ç„¦ç‚¹çª—å£ï¼Œç”¨äºæ‹–æ‹½å’Œè¾“å…¥ç­‰ã€‚æˆå‘˜focus_resource_list ä¸­åŒ…å«äº†ç„¦ç‚¹çª—å£æ‰€åœ¨ client ä¸­è¾“å…¥è®¾å¤‡ proxy å¯¹åº”çš„ resource å¯¹è±¡ã€‚åœ¨è¿™ä¸ªlistä¸­çš„resourceå°±å¯ä»¥æ¥æ”¶åˆ°ç›¸åº”çš„äº‹ä»¶ã€‚ ç›¸å…³å‡½æ•°weston_keyboard_send_key(), å‚è€ƒ 4.18.10 keyçš„å¤„ç† 4.16.1 udevd udev æ˜¯ Linux ç³»ç»Ÿä¸­çš„ä¸€ä¸ªé‡è¦ç»„ä»¶ï¼Œç”¨äºåŠ¨æ€è®¾å¤‡ç®¡ç†ã€‚è¯¦ç»†ä»‹ç»ä¸€ä¸‹ï¼š udev çš„å…¨ç§°æ˜¯ â€œuserspace deviceâ€ï¼Œå®ƒæ˜¯ä¸€ä¸ªç”¨æˆ·ç©ºé—´çš„è®¾å¤‡ç®¡ç†å·¥å…·ã€‚ åŠŸèƒ½ï¼š æ¥æ”¶æ¥è‡ªå†…æ ¸çš„è®¾å¤‡äº‹ä»¶ï¼ˆueventsï¼‰ï¼Œä¾‹å¦‚è®¾å¤‡çš„æ·»åŠ ã€ç§»é™¤æˆ–çŠ¶æ€å˜åŒ–ã€‚ æ ¹æ®é…ç½®çš„ä¸€ç»„è§„åˆ™ï¼Œå¯¹è®¾å¤‡è¿›è¡Œè¯†åˆ«å’Œå¤„ç†ã€‚ ç®¡ç†è®¾å¤‡èŠ‚ç‚¹çš„æƒé™å’Œå±æ€§ã€‚ åˆ›å»ºç¬¦å·é“¾æ¥ä»¥æä¾›æœ‰æ„ä¹‰çš„è®¾å¤‡åç§°ã€‚ å·¥ä½œæµç¨‹ï¼š å†…æ ¸å‘å‡ºè®¾å¤‡äº‹ä»¶ï¼ˆueventï¼‰ã€‚ udev å®ˆæŠ¤è¿›ç¨‹ï¼ˆé€šå¸¸æ˜¯ systemd-udevd.serviceï¼‰æ¥æ”¶äº‹ä»¶ã€‚ udev æ ¹æ®é…ç½®çš„è§„åˆ™åŒ¹é…è®¾å¤‡å±æ€§ï¼Œè¯†åˆ«è®¾å¤‡ã€‚ åŒ¹é…çš„è§„åˆ™å¯èƒ½ä¼šåˆ›å»ºç¬¦å·é“¾æ¥ã€ä¿®æ”¹è®¾å¤‡èŠ‚ç‚¹çš„æƒé™æˆ–è¿è¡ŒæŒ‡å®šçš„ç¨‹åºã€‚ è§„åˆ™æ–‡ä»¶ï¼š udev è§„åˆ™å­˜å‚¨åœ¨ä¸åŒç›®å½•ä¸‹çš„æ–‡ä»¶ä¸­ï¼Œä¾‹å¦‚ /usr/lib/udev/rules.dã€/run/udev/rules.d å’Œ /etc/udev/rules.dã€‚ è§„åˆ™æ–‡ä»¶ä»¥ .rules æ‰©å±•åç»“å°¾ã€‚ æ¯è¡ŒåŒ…å«è‡³å°‘ä¸€ä¸ªé”®å€¼å¯¹ï¼Œç”¨äºåŒ¹é…å’Œèµ‹å€¼ã€‚ è§„åˆ™æŒ‰ç…§è¯æ³•é¡ºåºå¤„ç†ï¼Œå¯ä»¥è¦†ç›–ç³»ç»Ÿæä¾›çš„è§„åˆ™ã€‚ åº“æ”¯æŒï¼š udev å¤„ç†çš„æ‰€æœ‰è®¾å¤‡ä¿¡æ¯å­˜å‚¨åœ¨ udev æ•°æ®åº“ä¸­ï¼Œå¹¶é€šè¿‡ libudev åº“æä¾›å¯¹å­˜å‚¨æ•°æ®å’Œäº‹ä»¶æºçš„è®¿é—®ã€‚ æ€»ä¹‹ï¼Œudev æ˜¯ä¸€ä¸ªå…³é”®çš„ Linux è®¾å¤‡ç®¡ç†å·¥å…·ï¼Œè´Ÿè´£è®¾å¤‡äº‹ä»¶çš„å¤„ç†ã€è®¾å¤‡è¯†åˆ«ã€æƒé™ç®¡ç†å’Œç¬¦å·é“¾æ¥çš„åˆ›å»º 4.16.2 grab key ç‰¹æ®Šæƒ…å†µä¸‹ï¼Œshellå¯¹keyçš„grab 4.17 Clientåˆ›å»ºçª—å£ 4.17.1 åˆ›å»ºshmçª—å£ 4.17.2 åˆ›å»ºeglçª—å£ 4.18 è°ƒç”¨çš„backtrace 4.18.1 Client eglSwapBuffers Client App è°ƒç”¨eglSwapBuffers æäº¤bufferç»™compositorçš„å †æ ˆ 4.18.2 wl_output globalçš„åˆ›å»º 4.18.3 wl_surface_commit wl_surface_commit() è§¦å‘çš„åç»§æ“ä½œ 4.18.4 drm_output_repaint() drm_output_repaint() çš„è°ƒç”¨æ ˆ 4.18.5 repaint_views repaint_views() çš„è°ƒç”¨æ ˆ 4.18.6 ç¬¬ä¸€æ¬¡repaintçš„è§¦å‘ 4.18.7 é€æ˜¾çš„backtrace 4.18.8 weston-desktop-shell 4.18.9 Weston_keyboard è¿›ç¨‹çš„åˆ›å»º åœ¨weston.iniä¸­çš„ã€input-methodã€‘è®¾ç½® path= ç©º æ¥ä¸åˆ›å»ºå®ƒ, å‡½æ•°launch_input_method() ä¼šæ£€æŸ¥path. 4.18.10 keyçš„å¤„ç† 4.19 weston misc 4.19.1 å®šæ—¶å™¨å‡½æ•° åˆ›å»ºå®šæ—¶å™¨ï¼šwl_event_loop_add_timer() Enable å®šæ—¶å™¨ï¼šwl_event_source_timer_update( source, ms_delay) // ms_delay ==0 ïƒ disable 4.19.2 wayland signal wl_signal_add( , ) æ·»åŠ ä¸€ä¸ªlisteneråˆ° listerner_list é“¾è¡¨ wl_signal_emit( , ) è§¦å‘ä¸€ä¸ªsignal, ä»listener_listä¸­è°ƒç”¨æ¯ä¸ªlistener notify listerner_list å…¶å®å°±æ˜¯ä¸€ä¸ªcallbacké“¾è¡¨ struct wl_listener { struct wl_list link; wl_notify_func_t notify; }; 4 12.3 libwayland-egl.so.xxx ç”± wayland-1.20.0/eglä¸‹æ–‡ä»¶ç¼–è¯‘ç”Ÿæˆ ä¸»è¦åŠŸèƒ½ç”Ÿæˆ/é”€æ¯wl_egl_windowï¼Œ å¹¶è·å–å®ƒçš„å¤§å°å±æ€§ ä½¿ç”¨: client/backend-wayland å¯ä»¥åˆ©ç”¨å®ƒæ¥ç”Ÿæˆwl_egl_window, ç„¶åä¼ ç»™eglCreateWindowSurface( ) ç¤ºä¾‹ï¼š./clients/simple-egl.c å¥½åƒä¸éœ€è¦å†åˆ†é…buffer attchåˆ° wl_surface, å‚è€ƒsimple-egl-window.c 4.19.4 weston_client_start() åœ¨westoné‡Œå®šä¹‰ï¼Œ Weston call å®ƒæ¥ å‘èµ·ä¸€ä¸ªclient è¿›ç¨‹, å®ƒä¼šè°ƒç”¨weston_client_launch() 4.19.5 weston-screenshooter æˆªå±è¿›ç¨‹ï¼Œ è¢«desktop-shell è¿›ç¨‹call screenshooter_create( )åˆ›å»º 4.19.6 æ˜¾ç¤ºä¸€å¸§çš„è¿‡ç¨‹ epollæ”¶åˆ°event æ„å»ºcompositor View_listï¼Œ å«æœ‰orderä¿¡æ¯ backend call gl_renderer set current surface ä¾æ¬¡æ ¹æ®å„ä¸ªviewçš„ä¿¡æ¯æ„å»ºçº¹ç†ï¼Œè¿›è¡Œæ¸²æŸ“ eglswapbufferï¼ˆï¼‰ éå†å„ä¸ªoutputï¼Œå®Œæˆ1ï½4 repaint_flash() -&gt; drm ä¸Šå± 4.19.7 repaint_timer_triger 4.19.8 Compositor sleep ç›¸å…³ In weston.init, ç›¸å…³é…ç½® idle-timeï¼Œ å•ä½sec åœ¨å‡½æ•°weston_compositor_wake()è®¾ç½® å¤šé•¿æ—¶é—´æ— æ“ä½œè¿›å…¥sleepçŠ¶æ€ å®šæ—¶å™¨compositor-&gt;idle_sourceï¼Œ åœ¨weston_compositor_create()ä¸­åˆ›å»º åœ¨weston_compositor_offscreen() , weston_compositor_sleep() ä¸­å…³é—­å®šæ—¶å™¨ 4.19.9 surfaceä¸buffer Surfaceï¼š Surface æ˜¯ DRM ä¸­çš„ä¸€ä¸ªæ¦‚å¿µï¼Œç”¨äºæè¿°ä¸€ä¸ªå¯ç»˜åˆ¶çš„åŒºåŸŸã€‚å®ƒæ˜¯ä¸€ä¸ªæŠ½è±¡çš„å›¾å½¢è¡¨é¢ï¼Œå¯ä»¥ç”¨äºç»˜åˆ¶å›¾åƒã€æ–‡æœ¬æˆ–å…¶ä»–å†…å®¹ã€‚ Surface å¯ä»¥æ˜¯å±å¹•ä¸Šçš„ä¸€éƒ¨åˆ†ï¼Œä¹Ÿå¯ä»¥æ˜¯ä¸€ä¸ªçª—å£ã€ä¸€ä¸ªå›¾åƒæˆ–å…¶ä»–å¯è§†å…ƒç´ ã€‚ åº”ç”¨ç¨‹åºå¯ä»¥å°†å›¾å½¢ç»˜åˆ¶åˆ° Surface ä¸Šï¼Œç„¶åç”± DRM ç®¡ç†å…¶æ˜¾ç¤ºã€‚ ä¾‹å¦‚ï¼Œåœ¨ DRM ä¸­ï¼Œä¸€ä¸ªçª—å£å¯ä»¥æœ‰å¤šä¸ªå…³è”çš„ Surfaceï¼Œæ¯ä¸ª Surface å¯¹åº”ä¸€ä¸ªç¼“å†²åŒºã€‚ Bufferï¼š Buffer æ˜¯ä¸€å—å†…å­˜åŒºåŸŸï¼Œç”¨äºå­˜å‚¨åƒç´ æ•°æ®ã€‚åœ¨ DRM ä¸­ï¼Œå®ƒé€šå¸¸ä¸ Surface å…³è”ã€‚ Buffer å¯ä»¥æ˜¯å¸§ç¼“å†²åŒºã€çº¹ç†ã€æ¸²æŸ“ç¼“å†²åŒºç­‰ã€‚ Buffer å­˜å‚¨ç€å›¾åƒçš„åƒç´ å€¼ï¼Œå¯ä»¥ç›´æ¥è®¿é—®å’Œæ“ä½œã€‚ ä¾‹å¦‚ï¼Œå½“åº”ç”¨ç¨‹åºç»˜åˆ¶å›¾åƒæ—¶ï¼Œå®ƒå°†åƒç´ æ•°æ®å†™å…¥ Bufferï¼Œç„¶åç”± DRM å°†å…¶æ˜¾ç¤ºåœ¨å±å¹•ä¸Šã€‚ æ€»ç»“ï¼š Surface æ˜¯ä¸€ä¸ªæŠ½è±¡çš„å›¾å½¢è¡¨é¢ï¼Œç”¨äºç»˜åˆ¶å›¾åƒã€‚ Buffer æ˜¯å®é™…å­˜å‚¨åƒç´ æ•°æ®çš„å†…å­˜åŒºåŸŸï¼Œä¸ Surface å…³è”ã€‚ 4.19.10 drm_virtual_output drm_backend_init_virtual_output_api () &lt;- #ifdef BUILD_DRM_VIRTUAL &lt;- /libweston/backend-drm/meson.build &lt;- remoting or pipewire in configure drm_virtual_output ç”¨äº remoting or pipewire åœºæ™¯ï¼Œ åœ¨meson_options.txt é‡Œé…ç½® 4.19.11 explicit-synchronization ç»‘å®šæ˜¾ç¤ºåŒæ­¥å¯¹è±¡ wl_registry_bind(zwp_linux_explicit_synchronization_v1_interface) é’ˆå¯¹surfaceåˆ›å»ºsyncå¯¹è±¡ zwp_linux_explicit_synchronization_v1_get_synchronization(expliciti_sync, surface) Client è¿›è¡ŒOpenglæ¸²æŸ“ï¼Œå¹¶é€šè¿‡sync åˆ›å»ºä¸€ä¸ªfence_fd eglCreateSyncKHR() --&gt; sync eglDupNativeFenceFDANDROID(sync) --&gt; fence_fd eglDestroySyncKHR(sync) ä¸ºsurface_syncå¯¹è±¡è®¾ç½®fence_fdï¼Œ compositorå°†ä¼šç­‰å¾…å®ƒçš„å®Œæˆ zwp_linux_surface_synchronization_v1_set_acquire_fence(fence_fd) åˆ›å»ºreleaseå¯¹è±¡ï¼Œç”¨äºç›‘å¬server callback zwp_linux_surface_synchronization_v1_get_release(surface_sync) æäº¤surfaceï¼Œcompositorå¼€å§‹åˆæˆå¹¶é€šè¿‡callback è¿”å›è¦clientç­‰å¾…çš„fence_fd wl_surface_attach() wl_surface_commit() Client ç­‰å¾…ä¸Šé¢callback è¿”å›çš„fence_fd eglCreateSyncKHR(..fence_fd..) â€“&gt; sync eglWaitSyncKHR(..sync..) 4.20 shell westonæä¾›æœ‰å››ç§shellï¼Œ desktopã€ IVIã€kiosk å’Œfullscreen-shell ./kiosk-shell/util.c ./kiosk-shell/kiosk-shell.c ./kiosk-shell/kiosk-shell-grab.c ./ivi-shell/hmi-controller.c ./ivi-shell/ivi-shell.c ./ivi-shell/ivi-layout-transition.c ./ivi-shell/ivi-layout.c ./fullscreen-shell/fullscreen-shell.c ./desktop-shell/input-panel.c ./desktop-shell/exposay.c ./desktop-shell/shell.c 4.20.1 kiosk-shell åœ¨ Weston ä¸­ï¼Œkiosk-shell æ˜¯ä¸€ç§ç®€å•çš„çª—å£ç®¡ç†å™¨ï¼ˆshellï¼‰ï¼Œä¸“ä¸ºå•åº”ç”¨ç¨‹åºæˆ–å•åº”ç”¨ç¨‹åºæ¨¡å¼ï¼ˆkiosk æ¨¡å¼ï¼‰è®¾è®¡ã€‚è®©æˆ‘è¯¦ç»†ä»‹ç»ä¸€ä¸‹ï¼š kiosk-shell çš„åŠŸèƒ½ï¼š kiosk-shell ä½¿æ‰€æœ‰é¡¶å±‚åº”ç”¨ç¨‹åºçª—å£å…¨å±æ˜¾ç¤ºã€‚ å®ƒæ”¯æŒå®šä¹‰å°†å“ªäº›åº”ç”¨ç¨‹åºæ”¾ç½®åœ¨ç‰¹å®šè¾“å‡ºä¸Šã€‚ è¿™é€šè¿‡åœ¨ weston.ini ä¸­ç›¸åº”è¾“å‡ºéƒ¨åˆ†çš„ app-ids= å­—æ®µä¸­å®ç°ã€‚ ä½¿ç”¨ç¤ºä¾‹ï¼š åœ¨ weston.ini ä¸­ï¼Œæ‚¨å¯ä»¥æŒ‡å®šå“ªäº›åº”ç”¨ç¨‹åºåº”è¯¥åœ¨ç‰¹å®šè¾“å‡ºä¸Šè¿è¡Œã€‚ ä¾‹å¦‚ï¼š [output] name=screen0 app-ids=org.domain.app1,com.domain.app2 è¦ä½¿ç”¨ kiosk-shell è¿è¡Œ Westonï¼Œè¯·åœ¨ weston.ini ä¸­è®¾ç½® shell=kiosk-shell.soï¼Œæˆ–ä½¿ç”¨å‘½ä»¤è¡Œé€‰é¡¹ â€“shell=kiosk-shell.soã€‚ é€‚ç”¨åœºæ™¯ï¼š kiosk-shell é€‚ç”¨äºåµŒå…¥å¼è®¾å¤‡ã€æ•°å­—æ ‡ç‰Œã€è‡ªåŠ©æœåŠ¡ç»ˆç«¯ã€å±•ç¤ºå°ç­‰åœºæ™¯ï¼Œå…¶ä¸­åªæœ‰ä¸€ä¸ªåº”ç”¨ç¨‹åºéœ€è¦å…¨å±æ˜¾ç¤ºã€‚ 4.20.2 ivi-shell IVI : In-Vehicle Information åœ¨ Weston é¡¹ç›®ä¸­ï¼ŒIVI-shell æ˜¯ä¸€ä¸ªé«˜åº¦å¯å®šåˆ¶çš„å¤–å£³ï¼ˆshellï¼‰ï¼Œä¸“æ³¨äºé‚£äº›éœ€è¦å¯¹å¤–å£³çª—å£å¸ƒå±€è¿›è¡Œè‡ªå®šä¹‰æ§åˆ¶çš„ç”¨ä¾‹ï¼Œè€Œæ— éœ€ç”¨æˆ·è¿›è¡Œäº¤äº’å¼å¸ƒå±€é…ç½®ã€‚IVI-shellçš„ç¤ºä¾‹ç”¨ä¾‹åŒ…æ‹¬æ±½è½¦ä¿¡æ¯å¨±ä¹ç³»ç»Ÿï¼ˆIVIï¼‰åº”ç”¨ç¨‹åºæˆ–å·¥ä¸šäººæœºç•Œé¢ã€‚é€šå¸¸æƒ…å†µä¸‹ï¼Œå½“ç”¨æˆ·ç•Œé¢éœ€è¦åœ¨ä¸€ä¸ªæˆ–å¤šä¸ªå±å¹•ä¸Šç²¾ç¡®å®šä½å¤šä¸ªåº”ç”¨ç¨‹åºè¡¨é¢æ—¶ï¼ŒIVI-shell æ˜¯ä¸€ä¸ªç†æƒ³çš„é€‰æ‹©ã€‚ ä»¥ä¸‹æ˜¯å…³äº IVI-shellçš„ä¸€äº›é‡è¦ä¿¡æ¯ï¼š IVI-shellå®¢æˆ·ç«¯åè®®ï¼š Wayland å®¢æˆ·ç«¯å¯ä»¥å®ç° ivi_application Wayland åè®®ï¼Œé€šè¿‡è¯¥åè®®ï¼Œå®ƒä»¬å¯ä»¥æŒ‡å®šä¸€ä¸ª ivi_idï¼Œä»¥ä¾¿ IVIæ§åˆ¶å™¨å¯ä»¥è¯†åˆ«åº”ç”¨ç¨‹åºã€‚è¿™ä½¿å¾—æ§åˆ¶å™¨å¯ä»¥ä¸ºä¼—æ‰€å‘¨çŸ¥çš„åº”ç”¨ç¨‹åºå®ç°ç‰¹æ®Šè¡Œä¸ºã€‚æ­¤å¤–ï¼ŒIVI-shellä¹Ÿå¯ä»¥å¤„ç†ä½¿ç”¨xdg-shellåè®®çš„å®¢æˆ·ç«¯ï¼Œä½†åœ¨è¿™äº›æƒ…å†µä¸‹ï¼ŒIVI-shelléœ€è¦å…¶ä»–æ–¹å¼æ¥è¯†åˆ«å®¢æˆ·ç«¯åº”ç”¨ç¨‹åºã€‚ IVI-shellçš„ç»„æˆéƒ¨åˆ†ï¼š ivi-shell.soï¼šè´Ÿè´£å¤„ç†åº”ç”¨ç¨‹åºIDï¼Œå¹¶æä¾›æŠ½è±¡æ¥é€šè¿‡ivi_layout_interfaceé…ç½®çª—å£å¸ƒå±€ã€‚è¿™ä¸ªæ¥å£åœ¨IVI-shellç»„åˆå™¨å®ç°ä¸­è®¨è®ºã€‚ è‡ªå®šä¹‰ IVI æ§åˆ¶å™¨ï¼šä½¿ç”¨ ivi_layout_interface æ¥å®ç°çª—å£ç®¡ç†å™¨ï¼Œè´Ÿè´£é…ç½®çª—å£å¸ƒå±€ï¼Œå³åº”ç”¨ç¨‹åºåœ¨å±å¹•ä¸Šçš„ä½ç½®ã€‚ç”±äºè¿™ç§åˆ†ç¦»ï¼Œå¿…é¡»åœ¨æ‚¨çš„weston.iniä¸­åŠ è½½è¿™ä¸¤ä¸ªæ¨¡å—æ‰èƒ½ä½¿ç”¨IVI-shellã€‚ IVI-shellçš„æ§åˆ¶ï¼š IVI-shellæä¾›äº† ivi_layout_interface APIï¼Œæ§åˆ¶å™¨å¿…é¡»ä½¿ç”¨å®ƒæ¥æ§åˆ¶IVI-shellçš„çª—å£å¸ƒå±€ã€‚æœ‰å…³æ­¤ API çš„å®šä¹‰ï¼Œè¯·å‚é˜… ivi-shell/ivi-layout-export.hã€‚ å¯¹äºåˆå§‹é…ç½®ï¼Œæ§åˆ¶å™¨å¿…é¡»è‡³å°‘åˆ›å»ºä¸€ä¸ª ivi_layout_layer å¹¶å°†å…¶æ·»åŠ åˆ°ä¸€ä¸ª weston_outputã€‚å›¾å±‚å…è®¸å°†å¤šä¸ªåº”ç”¨ç¨‹åºè¡¨é¢åˆ†ç»„å¹¶ä¸€èµ·æ§åˆ¶ï¼Œæ˜¯ç»„ç»‡å’Œç®¡ç†è¡¨é¢çš„ä¸»è¦æœºåˆ¶ã€‚ æ§åˆ¶å™¨è¿˜å¿…é¡»ä½¿ç”¨è§¦å‘å™¨æ¥è·å–å¯¹å®¢æˆ·ç«¯è¡¨é¢çš„æ§åˆ¶æƒã€‚å®¢æˆ·ç«¯è¡¨é¢æ˜¾ç¤ºä¸º ivi_layout_surfaceã€‚è¿™äº›è¡¨é¢å…·æœ‰ IDï¼Œå…è®¸æ§åˆ¶å™¨è¯†åˆ«è¡¨é¢å¹¶ç›¸åº”åœ°é‡æ–°é…ç½®çª—å£å¸ƒå±€ã€‚ æ€»ä¹‹ï¼ŒIVI-shellæ˜¯ä¸€ä¸ªå¼ºå¤§çš„å·¥å…·ï¼Œç”¨äºåœ¨æ±½è½¦ä¿¡æ¯å¨±ä¹ç³»ç»Ÿã€å·¥ä¸šç•Œé¢ç­‰åœºæ™¯ä¸­ç²¾ç¡®æ§åˆ¶åº”ç”¨ç¨‹åºçš„çª—å£å¸ƒå±€ã€‚ 4.20.3 fullscreen-shell ä¸‹å›¾æ˜¯fullscreen-shellçš„åˆå§‹åŒ–ï¼Œä»¥åŠsurface commitæ—¶çš„å¤„ç†ã€‚ å¯å‚è€ƒ [4.11 surface_commit] 4.21 wcap åœ¨ Westoné¡¹ç›®ä¸­ï¼Œwcap ç›®å½•æ˜¯ç”¨äºå¤„ç† Weston çš„å±å¹•å½•åˆ¶åŠŸèƒ½çš„ã€‚å…·ä½“æ¥è¯´ï¼Œwcap æ˜¯ä¸€ç§ç‰¹å®šäº Westonçš„æ— æŸè§†é¢‘æ ¼å¼ï¼Œå®ƒä»…è®°å½•å¸§ä¹‹é—´çš„å·®å¼‚ã€‚è¿™æ„å‘³ç€å®ƒåªæ•è·å±å¹•ä¸Šå‘ç”Ÿå˜åŒ–çš„éƒ¨åˆ†ï¼Œè€Œä¸æ˜¯å®Œæ•´çš„æ¯ä¸€å¸§ã€‚è¿™å¯¹äºå±å¹•å½•åˆ¶éå¸¸æœ‰ç”¨ï¼Œå› ä¸ºå®ƒå¯ä»¥å‡å°‘æ–‡ä»¶å¤§å°å¹¶æé«˜æ•ˆç‡ã€‚ å¦‚æœæ‚¨åœ¨ Weston ä¸­è¿›è¡Œå±å¹•å½•åˆ¶ï¼Œç”Ÿæˆçš„å½•åˆ¶æ–‡ä»¶å°†ä»¥ .wcap æ ¼å¼ä¿å­˜åœ¨å½“å‰å·¥ä½œç›®å½•ä¸­ã€‚è¦æ’­æ”¾è¿™äº›å½•åˆ¶æ–‡ä»¶ï¼Œæ‚¨éœ€è¦å°† .wcapæ–‡ä»¶è½¬æ¢ä¸ºå…¶ä»–åª’ä½“æ’­æ”¾å™¨å¯ä»¥ç†è§£çš„æ ¼å¼ã€‚ä¾‹å¦‚ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ wcap-decodeå·¥å…·å°† .wcap æ–‡ä»¶è½¬æ¢ä¸ºå•ç‹¬çš„PNGå›¾åƒæ–‡ä»¶ï¼Œä»¥ä¾¿æŸ¥çœ‹æ¯ä¸€å¸§çš„å±å¹•å†…å®¹ã€‚ è¯·æ³¨æ„ï¼Œè¿™é‡Œæåˆ°çš„ wcap æ˜¯ä¸€ç§ä¸“é—¨ç”¨äº Weston çš„æ ¼å¼ï¼Œä¸åŒäºå…¶ä»–å¸¸è§çš„è§†é¢‘æ ¼å¼ï¼Œå¦‚ MP4 æˆ– AVIã€‚ ./wcap/main.c ./wcap/wcap-decode.c"
  },"/blog/graphic/2001-02-01-DRM.html": {
    "title": "DRMå­ç³»ç»Ÿ",
    "keywords": "graphic",
    "url": "/blog/graphic/2001-02-01-DRM.html",
    "body": "1.DRMæ€»è¿° 1.1åœ¨æ•´ä¸ªç³»ç»Ÿä¸­çš„ä½ç½® Appè§’åº¦ DRMå†…éƒ¨ waylandå®ä¾‹ 2.å›¾å½¢bufferç›¸å…³ 2.1 dumb buffer æ—§æ—¶çš„æ˜¾å¡ç”±ä¸€å—å¾ˆå°çš„æ˜¾å­˜ï¼ˆé€šå¸¸ä¸º640x480ï¼‰åŠ ä¸€å—æ•°æ¨¡è½¬æ¢ç”µè·¯ï¼ˆDACï¼‰ç»„æˆï¼Œè¯´ç™½äº†å°±æ˜¯ä¸€å— Framebuffer + Display Controllerã€‚æ˜¾å¡çš„åŠŸèƒ½æå…¶ç®€å•ï¼Œåªè´Ÿè´£å°†æ˜¾å­˜ä¸­çš„å›¾åƒæ•°æ®è½¬æ¢æˆRGBä¿¡å·å‘é€å‡ºå»å³å¯ï¼Œè€Œæ‰€æœ‰çš„ç»˜å›¾æ“ä½œåˆ™éƒ½äº¤ç»™ CPU æ¥å®Œæˆã€‚è¡Œä¸šé‡Œå°†è¿™ç§æ˜¾å¡ç§°ä¸º VGA(Video Graphics Array) Cardï¼Œå®ƒçš„æ˜¾å­˜åˆ™è¢«ç§°ä¸ºâ€œDumb Frame Bufferâ€ã€‚è€Œåˆ°äº†åæœŸï¼Œéšç€æ˜¾å¡æŠ€æœ¯çš„ä¸æ–­å‘å±•ï¼Œè®¸å¤šåŸæ¥ç”± CPU å¹²çš„æ´»ï¼Œæ¸æ¸çš„éƒ½è¢«æ˜¾å¡å–ä»£äº†ã€‚ä»æœ€åˆæ”¯æŒæŸäº›ç‰¹å®šç»˜å›¾æŒ‡ä»¤ï¼ˆå¦‚ç”»ç‚¹ã€ç”»çº¿ï¼‰çš„æ˜¾å¡ï¼Œåˆ°åæ¥æ”¯æŒè§†é¢‘è§£ç çš„ Video Cardï¼Œå†åˆ°ç°ä»£æ”¯æŒå¤æ‚3Dæ¸²æŸ“æŒ‡ä»¤ï¼ˆå¦‚OpenGLï¼‰çš„ GPU æ˜¾å¡ï¼ŒCPU ç»˜å›¾çš„ç¹é‡ä»»åŠ¡å½»åº•å¾—åˆ°äº†è§£æ”¾ã€‚ä¸ VGA Card ç›¸æ¯”è¾ƒï¼Œè¡Œä¸šé‡Œå°†åæ¥æ˜¾å¡çš„æ˜¾å­˜ç§°ä¸ºâ€œSmart Frame Bufferâ€ã€‚ é¦–å…ˆä»è¿™ä¸¤ç§ç§°è°“ä¸Šæˆ‘ä»¬å°±å¯ä»¥çœ‹å‡ºï¼Œdumb æ˜¯ smart çš„åä¹‰è¯ï¼Œå› æ­¤ dumb åœ¨è¿™é‡Œçš„è§£é‡Šåº”è¯¥æ˜¯â€œå‚»çš„â€æˆ–â€œå‚»ç“œå¼çš„â€ï¼Œè€Œä¸æ˜¯â€œå“‘çš„â€ã€‚ dumb buffer å’Œ smart buffer çš„åŒºåˆ«å°±åœ¨äºï¼Œä½ å†™åˆ°æ˜¾å­˜é‡Œçš„æ•°æ®ï¼Œæ˜¯å¯ä»¥ç›´æ¥ä¸Šå±æ˜¾ç¤ºçš„å›¾åƒå†…å®¹ï¼Œè¿˜æ˜¯ä¸€å †éœ€è¦GPUè§£æçš„å‘½ä»¤å’Œèµ„æºæ•°æ®ã€‚ ä¸ dumb buffer å‘½åç±»ä¼¼çš„è¿˜æœ‰ï¼š dumb-terminalï¼šä¸æ”¯æŒç‰¹æ®Šå­—ç¬¦çš„ç»ˆç«¯ï¼Œå¦‚â€œæ¸…å±â€ã€â€œç²—ä½“â€ã€â€œå½©è‰²å­—ç¬¦â€ç­‰ç­‰ dumb-panelï¼šä¸å¸¦ GRAM çš„ panel dumb-TVï¼šä¸ Smart-TV ç›¸åï¼ŒæŒ‡ä»¥å‰è€å¼çš„é»‘ç™½ç”µè§† å¦‚ä»Šçš„ IT é¢†åŸŸï¼Œdumbä¸€è¯æ›´å¤šçš„ä»£è¡¨ â€œåŠŸèƒ½ç®€å•çš„â€ã€â€œè€å¼çš„â€ã€â€œä¼ ç»Ÿçš„â€ å«ä¹‰ 2.1.1è¶…ç®€å•DUMBå®ç° ä¸dumb bufferç›¸å…³çš„userspaceæ¥å£æœ‰å››ä¸ª, ä¸‹è¡¨åˆ—å‡ºäº†å®ƒä»¬çš„åå­—, ä½œç”¨å’Œå¯¹åº”è¦å®ç°çš„å‡½æ•° interface Description drm driver ioctl(fd, DRM_IOCTL_MODE_CREATE_DUMB, â€¦) å‘é©±åŠ¨ç”³è¯·ä¸€ä¸ªdumb bufferï¼Œè¿”å›ä¸€ä¸ªhandleï¼ŒæŒ‡å‘æ–°åˆ†é…çš„buffer .dumb_create() ioctl(fd, DRM_IOCTL_MODE_MAP_DUMB, â€¦) ä¸ºbuffer mapåšå‡†å¤‡ï¼Œä¼ å…¥handleï¼Œå¾—åˆ°ä¸€ä¸ªoffset .dumb_map_offset() ioctl(fd, DRM_IOCTL_MODE_DESTROY_DUMB, â€¦) é”€æ¯è¯¥dumb buffer .dumb_destroy() mmap(fd, â€¦) ä¼ å…¥ bufferå¯¹åº”çš„offsetï¼Œæ˜ å°„åˆ°è¿›ç¨‹ç©ºé—´ï¼Œè¿”å›ä¸€ä¸ªç”¨æˆ·ç©ºé—´å¯ä½¿ç”¨çš„åœ°å€ã€‚ .fops.mmap() 2.1.1.1 ç®€å•åº”ç”¨ç¨‹åº ä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„åº”ç”¨ç¨‹åºï¼Œæ¼”ç¤ºäº†dumb bufferçš„ç”³è¯·ï¼Œmmapï¼Œä½¿ç”¨å’Œé”€æ¯ã€‚ #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; #include &lt;sys/mman.h&gt; #include &lt;unistd.h&gt; #include &lt;xf86drm.h&gt; #define log(fmt, args...) printf(\"%s():%d \" fmt \"\\n\", __func__, __LINE__, ##args) #define err(fmt, args...) printf(\"\\033[35m%s():%d \" fmt \"\\033[0m\\n\", __func__, __LINE__, ##args) static int create_dumb_buffer(int fd, int width, int height){ int ret = 0; struct drm_mode_create_dumb create = {}; create.width = width; create.height =height; create.bpp = 4*8; // byte per pixel ret = drmIoctl(fd, DRM_IOCTL_MODE_CREATE_DUMB, &amp;create); if(ret){ err(\"ret:%d\", ret); return 0; } return create.handle; } static int get_dumb_buffer_offset(int fd, int handle){ struct drm_mode_map_dumb map = {}; map.handle = handle; int ret = drmIoctl(fd, DRM_IOCTL_MODE_MAP_DUMB, &amp;map); if(ret){ err(\"ret:%d\", ret); return 0; } return map.offset; } static void* mmap_dumb_buffer(int fd, int size, int offset){ void *addr = NULL; addr = mmap(0, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, offset); if(!addr){ err(\"mmap dumb buffer offset:0x%x failed\", offset); return NULL; } return addr; } static void destroy_dumb_buffer(int fd, int handle){ struct drm_mode_destroy_dumb destroy = {}; destroy.handle = handle; int ret = drmIoctl(fd, DRM_IOCTL_MODE_DESTROY_DUMB, &amp;destroy); if(ret){ err(\"DRM_IOCTL_MODE_DESTROY_DUMB failed. ret:%d\", ret); return; } } int main(int argc, char **argv){ int fd; int width = 1024; int height = 1; int size = width*height; fd = open(\"/dev/dri/card0\", O_RDWR | O_CLOEXEC); if(fd&lt;=0){ err(\"open dev failed.\"); return -1; } int handle = create_dumb_buffer(fd, width, height); log(\"create dumb buffer, get handle:%d\", handle); int offset = get_dumb_buffer_offset(fd, handle); log(\"get dumb buffer offset:0x%x\", offset); void *addr = mmap_dumb_buffer(fd, size, offset); log(\"get dumb buffer addr:%p\",addr); //åœ¨addræ‰€æŒ‡å‘çš„bufferä¸Šè¿›è¡Œç»˜å›¾ memset(addr, 0, width*height); munmap(addr, size); destroy_dumb_buffer(fd, handle); log(\"destroy dumb buffer\"); getchar(); close(fd); return 0; } 2.1.1.2 å®ç°ç®€å•çš„é©±åŠ¨ åŸºäºkernel 5.15.126ï¼Œ ä¸»è¦æ˜¯.dumb_create(), .dumb_map_offset(), .dumb_destroy, fops.mmap()çš„å®ç° #include &lt;linux/module.h&gt; #include &lt;linux/platform_device.h&gt; #include &lt;drm/drm_drv.h&gt; #include &lt;drm/drm_file.h&gt; #include &lt;drm/drm_ioctl.h&gt; #define DRIVER_NAME \"drm dumb driver\" #define DRIVER_DESC \"Virtual drm dumb driver\" #define DRIVER_DATE \"20191114\" #define DRIVER_MAJOR 1 #define DRIVER_MINOR 0 #define MAX_NUM 10 #define log(fmt, args...) printk(\"%s():%d \" fmt \"\\n\", __func__, __LINE__, ##args) #define err(fmt, args...) printk(\"\\033[35m%s():%d \" fmt \"\\033[0m\\n\", __func__, __LINE__, ##args) struct dumb_device { struct drm_device drm; struct platform_device *platform_dev; }; static struct dumb_device* dumb_device = NULL; static struct page *pages[MAX_NUM] = {0}; static u32 buffer_size[MAX_NUM] = {0}; static int page_idx = 0; static int dumb_mmap_impl(struct file* filp, struct vm_area_struct* vma) { unsigned long pfn_start = 0; unsigned long size = vma-&gt;vm_end - vma-&gt;vm_start; int ret = 0; int idx = 0; /********************************************************************* * vm_pgoff: ä¹Ÿæ˜¯vm_are_structçš„ä¸€ä¸ªå­—æ®µ * è¡¨ç¤ºåç§»é‡ï¼Œå®ƒæ˜¯ä»¥page sizeè®¡æ•°çš„ã€‚ pgè¡¨ç¤ºpageè®¡æ•°ï¼Œoffè¡¨ç¤ºåç§» *********************************************************************/ idx = vma-&gt;vm_pgoff; pfn_start = page_to_pfn(pages[idx]); log(\"idx:%d phy: 0x%lx, vm_pgoff: 0x%lx, vma-&gt;vm_start:0x%lx, size: 0x%lx\", idx, pfn_start &lt;&lt; PAGE_SHIFT, vma-&gt;vm_pgoff, vma-&gt;vm_start, size); ret = remap_pfn_range(vma, vma-&gt;vm_start, pfn_start, size, vma-&gt;vm_page_prot); if (ret) err(\"remap_pfn_range failed at [0x%lx 0x%lx]\", vma-&gt;vm_start, vma-&gt;vm_end); else{ unsigned long virt_start = (unsigned long)page_address(pages[idx]); log(\"map 0x%lx to 0x%lx, size: 0x%lx\", virt_start, vma-&gt;vm_start, size); } return 0; } static const struct file_operations dumb_driver_fops = { .owner = THIS_MODULE, .open = drm_open, .release = drm_release, .unlocked_ioctl = drm_ioctl, .compat_ioctl = drm_compat_ioctl, .mmap = dumb_mmap_impl, }; static void dumb_release(struct drm_device* dev) { log(); } static int dumb_create_impl(struct drm_file *file_priv, struct drm_device *dev, struct drm_mode_create_dumb* args) { u32 size = 0; log(); if(page_idx&gt;=MAX_NUM){ err(\"only support alloc %d buffers\", MAX_NUM); return -ENOMEM; } size = roundup((args-&gt;width * args-&gt;height * args-&gt;bpp/8), PAGE_SIZE); // åˆ†é…é¡µé¢ pages[page_idx] = alloc_pages(GFP_KERNEL, get_order(size)); if (!pages[page_idx]) { err(\"alloc_pages() failed\"); return -ENOMEM; } buffer_size[page_idx] = size; // èµ‹å€¼è¿”å›å‚æ•° args-&gt;size = size; args-&gt;pitch = args-&gt;width * args-&gt;bpp/8; args-&gt;handle = page_idx++; return 0; } static int dumb_map_offset_impl(struct drm_file *file_priv, struct drm_device *dev, uint32_t handle, uint64_t* offset) { log(\"%d\", handle); //æ ¹æ®handleå¾—åˆ°ä¸€ä¸ªoffsetï¼Œä¸ºäº†ç®€å•ï¼Œè¿™é‡Œç›´æ¥ä½¿ç”¨handle *offset = 0x1000*(u64)handle; return 0; } static int dumb_destroy_impl(struct drm_file *file_priv, struct drm_device *dev, uint32_t handle){ log(\"handle:%d\", handle); free_pages((unsigned long)page_address(pages[handle]), get_order(buffer_size[handle])); return 0; } static struct drm_driver dumb_driver = { .fops = &amp;dumb_driver_fops, .release = dumb_release, .dumb_create = dumb_create_impl, .dumb_map_offset = dumb_map_offset_impl, .dumb_destroy = dumb_destroy_impl, .name = DRIVER_NAME, .desc = DRIVER_DESC, .date = DRIVER_DATE, .major = DRIVER_MAJOR, .minor = DRIVER_MINOR, }; static int __init dumb_drv_init(void) { int ret; struct platform_device* pdev = NULL; log(\"build time: %s %s\", __DATE__, __TIME__); pdev = platform_device_register_simple(DRIVER_NAME, -1, NULL, 0); if (IS_ERR(pdev)) return PTR_ERR(pdev); if (!devres_open_group(&amp;pdev-&gt;dev, NULL, GFP_KERNEL)) { ret = -ENOMEM; goto out_unregister; } // åˆ†é… dumb_device = devm_drm_dev_alloc(&amp;pdev-&gt;dev, &amp;dumb_driver, struct dumb_device, drm); if (IS_ERR(dumb_device)) { ret = PTR_ERR(dumb_device); goto out_devres; } // æ³¨å†Œ ret = drm_dev_register(&amp;dumb_device-&gt;drm, 0); if (ret) goto out_devres; dumb_device-&gt;platform_dev = pdev; log(\"Finish\"); return 0; out_devres: devres_release_group(&amp;pdev-&gt;dev, NULL); out_unregister: platform_device_unregister(pdev); return ret; } static void __exit dumb_drv_exit(void) { struct platform_device *pdev = dumb_device-&gt;platform_dev; log(); drm_dev_unregister(&amp;dumb_device-&gt;drm); devres_release_group(&amp;pdev-&gt;dev, NULL); platform_device_unregister(pdev); } module_init(dumb_drv_init); module_exit(dumb_drv_exit); MODULE_AUTHOR(\"kevin\"); MODULE_DESCRIPTION(DRIVER_DESC); MODULE_LICENSE(\"GPL\"); 2.1.1.3 å®ƒä»¬æ˜¯å¦‚ä½•è¡”æ¥èµ·æ¥çš„ 2.1.2 åŸºäºGEMçš„å®ç° GEMæ˜¯ç³»ç»Ÿæä¾›çš„ä¸€å¥—å®ç°æ¡†æ¶æˆ–è€…å¸®åŠ©å·¥å…·ã€‚åœ¨å„è‡ªå®ç°ç§æœ‰çš„drm driveræ—¶ï¼Œæ€»æœ‰ä¸€äº›å†…å®¹æ˜¯ç›¸åŒæˆ–ç›¸ä¼¼çš„ï¼ŒGEMå°±å¯¹è¿™äº›ç›¸åŒéƒ¨åˆ†è¿›è¡Œäº†æ€»ç»“ï¼ŒæŠ½è±¡ï¼Œç„¶åå®ç°äº†å®ƒä»¬ï¼Œä¾›å¼€å‘è€…ä½¿ç”¨ã€‚å…·ä½“å®ç°åœ¨drm_gem.c 2.1.2.1 å®ç°ä»£ç  ä¸‹é¢æ˜¯åŸºäºGEMå¯¹ä¸Šé¢driverå®ç°çš„æ”¹é€ ã€‚ å®ƒåˆ©ç”¨äº†GEM æä¾›çš„å¦‚ä¸‹å‡½æ•°ï¼š interface åŠŸèƒ½ drm_gem_object_init() åˆå§‹åŒ–ä¸€ä¸ªgemå¯¹è±¡ drm_gem_handle_create() é€šè¿‡gemå¯¹è±¡ç”Ÿæˆä¸€ä¸ªhandle drm_gem_object_lookup() æ ¹æ®handle æ‰¾åˆ°å¯¹åº”çš„gemå¯¹è±¡ drm_gem_dumb_map_offset() é€šè¿‡gemå¯¹è±¡ç”Ÿæˆä¸€ä¸ªoffset drm_gem_mmap() å¯¹mmap()çš„æ”¯æŒï¼Œå¦‚æœå¼€å‘è€…ä½¿ç”¨å®ƒï¼Œå°±å¯åˆ©ç”¨gem mmapçš„å®ç°éƒ¨åˆ† struct drm_gem_object_funcs ä½¿ç”¨gemå¯¹è±¡æ—¶å¯èƒ½è°ƒç”¨åˆ°ä¸€ç»„å‡½æ•°,æ­¤å¤„å®ç°äº†.mmap,å¯¹åº”drm_gem_mmap() #include &lt;linux/module.h&gt; #include &lt;linux/platform_device.h&gt; #include &lt;drm/drm_gem.h&gt; #include &lt;drm/drm_drv.h&gt; #include &lt;drm/drm_file.h&gt; #include &lt;drm/drm_ioctl.h&gt; #define DRIVER_NAME \"drm dumb gem driver\" #define DRIVER_DESC \"Virtual drm dumb driver\" #define DRIVER_DATE \"20191116\" #define DRIVER_MAJOR 1 #define DRIVER_MINOR 0 #define log(fmt, args...) printk(\"%s():%d \" fmt \"\\n\", __func__, __LINE__, ##args) #define err(fmt, args...) printk(\"\\033[35m%s():%d \" fmt \"\\033[0m\\n\", __func__, __LINE__, ##args) #define DRM_GEM_OBJECT_TO_DUMB_BUFFER_OBJ(target) \\ container_of(target, struct dumb_buffer_object, gem_obj) struct dumb_device { struct drm_device drm; struct platform_device *platform_dev; }; struct dumb_buffer_object{ struct drm_gem_object gem_obj; struct page *start_page; u32 size; }; static struct dumb_device* dumb_device = NULL; static int dumb_gem_mmap_impl(struct file* filp, struct vm_area_struct* vma) { log(\"call drm_gem_mmap()\"); // åˆ©ç”¨GEMæ–¹æ³•è¿›è¡Œmappingï¼Œ // åœ¨å®ƒé‡Œé¢ä¼šè°ƒç”¨ä¹‹å‰è®¾ç½®å¥½çš„drm_gem_object_funcs.mmap() return drm_gem_mmap(filp, vma); } static const struct file_operations dumb_driver_fops = { .owner = THIS_MODULE, .open = drm_open, .release = drm_release, .poll = drm_poll, .read = drm_read, .llseek = noop_llseek, .mmap = dumb_gem_mmap_impl, .unlocked_ioctl = drm_ioctl, .compat_ioctl = drm_compat_ioctl, }; static int dumb_gem_obj_mmap(struct drm_gem_object *gem_obj, struct vm_area_struct *vma){ int ret = 0; unsigned long pfn_start = 0; unsigned long size = vma-&gt;vm_end - vma-&gt;vm_start; struct dumb_buffer_object *dumb_buffer_obj = NULL; dumb_buffer_obj = DRM_GEM_OBJECT_TO_DUMB_BUFFER_OBJ(gem_obj); log(\"mmaping dumb_buffer_obj:%p\", dumb_buffer_obj); pfn_start = page_to_pfn(dumb_buffer_obj-&gt;start_page); ret = remap_pfn_range(vma, vma-&gt;vm_start, pfn_start, size, vma-&gt;vm_page_prot); if (ret){ err(\"remap_pfn_range failed at [0x%lx 0x%lx]\", vma-&gt;vm_start, vma-&gt;vm_end); } return 0; } static const struct drm_gem_object_funcs dumb_gem_obj_funcs = { .open = NULL, .mmap = dumb_gem_obj_mmap, //.vm_ops = &amp;dumb_gem_vm_ops, // èµ‹å€¼åˆ°struct vm_area_struct çš„vm_ops, ä¾›ç¼ºé¡µæ—¶è°ƒç”¨ã€‚ }; static void dumb_release(struct drm_device* dev) { log(); } static int dumb_create_gem_impl(struct drm_file* file_priv, struct drm_device* dev, struct drm_mode_create_dumb* args) { u32 size = 0; int ret = 0; struct dumb_buffer_object *dumb_buffer_obj; struct drm_gem_object *gem_obj; log(); size = ALIGN((args-&gt;width * args-&gt;height * args-&gt;bpp/8), PAGE_SIZE); //1. åˆ†é…buffer_obj // å¯ä»¥åœ¨æ­¤å¤„åˆ†é…page,ä¹Ÿå¯ä»¥åœ¨faultæ—¶å†åˆ†é… dumb_buffer_obj = kzalloc(sizeof(*dumb_buffer_obj), GFP_KERNEL); size = roundup(size, PAGE_SIZE); log(\"page_size:%d\",size); // 2. åˆå§‹åŒ–dumb_buffer_objå†…çš„drm_gem_object gem_obj = &amp;(dumb_buffer_obj-&gt;gem_obj); gem_obj-&gt;funcs = &amp;dumb_gem_obj_funcs; /* è®¾ç½®è¯¥gem objectçš„æ“ä½œå‡½æ•° */ drm_gem_object_init(dev, gem_obj, size); // 3. åˆ©ç”¨GEMæ–¹æ³•ç”Ÿæˆä¸€ä¸ªgem_objå¯¹åº”çš„handle ret = drm_gem_handle_create(file_priv, gem_obj, &amp;args-&gt;handle); if(ret){ log(); } dumb_buffer_obj-&gt;start_page = alloc_pages(GFP_KERNEL, get_order(size)); if (!dumb_buffer_obj-&gt;start_page) { err(\"alloc_pages() failed\"); return -ENOMEM; } dumb_buffer_obj-&gt;size = size; // 4. èµ‹å€¼è¿”å›å‚æ•° args-&gt;size = size; args-&gt;pitch = args-&gt;width*args-&gt;bpp/8; //TODO: åº”è®¡ç®—å¾—åˆ° log(\"create dumb_buffer_obj:%p success, return handle:%d\", dumb_buffer_obj, args-&gt;handle); return 0; } static int dumb_map_offset_gem_impl(struct drm_file* file_priv, struct drm_device* dev, uint32_t handle, uint64_t* offset) { int ret; log(\"handle:%d\", handle); // åˆ©ç”¨GEMæ–¹æ³•å¾—åˆ°ä¸€ä¸ªoffset ret =drm_gem_dumb_map_offset(file_priv, dev, handle, offset); if(ret){ err(\"drm_gem_dumb_map_offset failed. ret:%d\", ret); }else{ log(\"get offset:0x%llx from drm_gem_dumb_map_offset()\", *offset); } return ret; } static int dumb_release_gem_impl(struct drm_file *file_priv, struct drm_device *dev, u32 handle){ struct drm_gem_object *gem_obj; struct dumb_buffer_object *dumb_buffer_obj = NULL; log(\"\"); gem_obj = drm_gem_object_lookup(file_priv, handle); dumb_buffer_obj = DRM_GEM_OBJECT_TO_DUMB_BUFFER_OBJ(gem_obj); log(\"free page:%p\",dumb_buffer_obj-&gt;start_page); free_pages((unsigned long)page_address(dumb_buffer_obj-&gt;start_page), get_order(dumb_buffer_obj-&gt;size)); kfree(dumb_buffer_obj); return 0; } static struct drm_driver dumb_driver = { .driver_features = DRIVER_GEM, .fops = &amp;dumb_driver_fops, .release = dumb_release, .dumb_create = dumb_create_gem_impl, .dumb_map_offset = dumb_map_offset_gem_impl, .dumb_destroy = dumb_release_gem_impl, .name = DRIVER_NAME, .desc = DRIVER_DESC, .date = DRIVER_DATE, .major = DRIVER_MAJOR, .minor = DRIVER_MINOR, }; static int __init dumb_drv_init(void) { int ret; struct platform_device* pdev = NULL; log(\"build time: %s %s\", __DATE__, __TIME__); pdev = platform_device_register_simple(DRIVER_NAME, -1, NULL, 0); if (IS_ERR(pdev)) return PTR_ERR(pdev); if (!devres_open_group(&amp;pdev-&gt;dev, NULL, GFP_KERNEL)) { ret = -ENOMEM; goto out_unregister; } dumb_device = devm_drm_dev_alloc(&amp;pdev-&gt;dev, &amp;dumb_driver, struct dumb_device, drm); if (IS_ERR(dumb_device)) { ret = PTR_ERR(dumb_device); goto out_devres; } ret = drm_dev_register(&amp;dumb_device-&gt;drm, 0); if (ret) goto out_devres; dumb_device-&gt;platform_dev = pdev; log(\"Finish\"); return 0; out_devres: devres_release_group(&amp;pdev-&gt;dev, NULL); out_unregister: platform_device_unregister(pdev); return ret; } static void __exit dumb_drv_exit(void) { struct platform_device *pdev = dumb_device-&gt;platform_dev; log(); drm_dev_unregister(&amp;dumb_device-&gt;drm); devres_release_group(&amp;pdev-&gt;dev, NULL); platform_device_unregister(pdev); } module_init(dumb_drv_init); module_exit(dumb_drv_exit); MODULE_AUTHOR(\"kevin\"); MODULE_DESCRIPTION(DRIVER_DESC); MODULE_LICENSE(\"GPL\"); 2.1.2.2 æµç¨‹å›¾ 2.2 PRIME PRIME åœ¨ DRM é©±åŠ¨ä¸­å…¶å®æ˜¯ä¸€ç§bufferå…±äº«æœºåˆ¶ï¼Œå®ƒæ˜¯åŸºäº dma-buf æ¥å®ç°çš„. 2010å¹´2æœˆ9æ—¥ï¼ŒNVIDIA å®˜æ–¹å‘å¸ƒäº†ä¸€é¡¹æ–°çš„åŒæ˜¾å¡æŠ€æœ¯ â€”â€” Optimus Technologyã€‚è¯¥æŠ€æœ¯ä¸»è¦è¿ç”¨äºå¸¦åŒæ˜¾å¡çš„ç¬”è®°æœ¬ï¼ˆé›†æˆæ˜¾å¡+ç‹¬ç«‹æ˜¾å¡ï¼‰ï¼Œå¯ä»¥æ ¹æ®å½“å‰é›†æˆæ˜¾å¡çš„å·¥ä½œè´Ÿè½½ï¼Œè‡ªåŠ¨çš„å°†ä¸€éƒ¨åˆ†å›¾å½¢ä»»åŠ¡äº¤ç»™ç‹¬ç«‹æ˜¾å¡å»å¤„ç†ï¼Œä»¥æ­¤æ¥è¾¾åˆ°åŠŸè€—å’Œæ€§èƒ½çš„æœ€ä½³å¹³è¡¡ã€‚ä¸¾ä¾‹æ¥è¯´ï¼Œä¸€ä¸ªå¸¦ Intel é›†æˆæ˜¾å¡å’Œ NVIDIA ç‹¬ç«‹æ˜¾å¡çš„ç¬”è®°æœ¬ï¼Œé€šå¸¸å°†é›†æˆæ˜¾å¡åšä¸ºé»˜è®¤æ˜¾å¡ï¼Œä¸”å……å½“äº† Display Controller çš„è§’è‰²ã€‚å½“ç”¨æˆ·ä½¿ç”¨åŠå…¬è½¯ä»¶æ—¶ï¼Œç”±äºéœ€è¦æ¸²æŸ“çš„ä»»åŠ¡é‡ä¸å¤šï¼Œæ­¤æ—¶ç›´æ¥ç”± Intel é›†æˆæ˜¾å¡æ¥å®Œæˆã€‚è€Œå½“ç”¨æˆ·ç©3Dæ¸¸æˆæ—¶ï¼Œç”±äºå›¾å½¢æ¸²æŸ“çš„è´Ÿè½½è¾ƒé‡ï¼Œæ­¤æ—¶ç³»ç»Ÿä¼šå°†éƒ¨åˆ†æˆ–å…¨éƒ¨çš„ä»»åŠ¡äº¤ç»™ NVIDIA ç‹¬ç«‹æ˜¾å¡å»å¤„ç†ï¼Œç­‰å¤„ç†å®Œåå†å°†ç»“æœé€å›ç»™é›†æˆæ˜¾å¡åšæœ€åçš„åˆæˆæ˜¾ç¤ºã€‚è€Œè¿™æ•´ä¸ªè¿‡ç¨‹éƒ½æ˜¯ç”±è½¯ç¡¬ä»¶è‡ªåŠ¨å®Œæˆçš„ï¼Œä¸­é—´æ— éœ€äººä¸ºå¹²é¢„ï¼Œç”¨æˆ·ä½“éªŒååˆ†æµç•…ã€‚åªå¯æƒœï¼Œè¯¥æŠ€æœ¯åªèƒ½ç”¨åœ¨ Windows ç³»ç»Ÿä¸Šï¼ŒLinux ç³»ç»Ÿä¸æ”¯æŒã€‚ å½“æ—¶çš„ Linux å¼€æºç¤¾åŒºï¼ŒDave Airlie ï¼ˆRedHat Graphics å·¥ç¨‹å¸ˆï¼ŒDRM ç¤¾åŒº maintainerï¼‰åœ¨ä¸šä½™æ—¶é—´é‡Œç ”ç©¶èµ· Optimus æŠ€æœ¯ï¼Œå¹¶ç¢ç£¨ç€æ€æ ·åœ¨ Linux å¹³å°ä¸Šå®ç°ç±»ä¼¼çš„åŠŸèƒ½ã€‚ç»“æœä¸åˆ°2å‘¨æ—¶é—´ï¼Œä»–å°±åšå‡ºäº†è¯¥æ–¹æ¡ˆçš„åŸå‹è®¾è®¡ï¼Œå¹¶åœ¨è‡ªå·±çš„ç¬”è®°æœ¬ä¸Šï¼ˆIntelé›†æˆæ˜¾å¡+ATIç‹¬ç«‹æ˜¾å¡ï¼‰å®ç°äº†è¯¥åŠŸèƒ½çš„éªŒè¯ã€‚ ä»–å°†è¿™é¡¹æŠ€æœ¯å‘½åä¸ºâ€œPRIMEâ€ã€‚ å‘½åä¸ºPRIME ä¸»è¦æ˜¯æ˜ å°„Optimus Optimus Prime å°±æ˜¯å˜å½¢é‡‘åˆš æ“å¤©æŸ±çš„åå­—ï¼ NVIDIA å½“åˆç»™ä»–ä»¬ Optimus æŠ€æœ¯å‘½åçš„ç²¾å¦™ä¹‹å¤„ï¼šæ“å¤©æŸ±æœ¬èº«æ‰€å…·æœ‰çš„å˜å½¢èƒ½åŠ›ï¼Œå½¢è±¡çš„è¡¨è¾¾äº† Optimus è¿™é¡¹æŠ€æœ¯å¯ä»¥åœ¨åŠŸè€—å’Œæ€§èƒ½ä¹‹é—´æ¥å›è‡ªç”±å˜æ¢ã€‚ Dave å°†ä»–è¿™é¡¹ Linux ä¸‹çš„æŠ€æœ¯å‘½åä¸º â€œPRIMEâ€ï¼Œå…¶å®æ˜¯å¾ˆå·§å¦™çš„ç©äº†ä¸€æŠŠæ–‡å­—æ¸¸æˆï¼Œéšæ™¦çš„å‘Šè¯‰å¤§å®¶ï¼šDRM Prime æŠ€æœ¯å°±æ˜¯ç”¨æ¥å¯¹æ ‡ NVIDIA Optimus æŠ€æœ¯çš„ã€‚ 2.2.1 PRIMEçš„åŸºæœ¬å®ç° ä¸ºäº†å®ç°è®¾å¤‡é—´çš„bufferå…±äº«ï¼Œéœ€è¦æœ‰ä¸€å¥—æœºåˆ¶æ¥å¯¼å‡ºã€å¯¼å…¥bufferã€‚æä¾›bufferçš„é©±åŠ¨è´Ÿè´£å¯¼å‡ºbufferï¼Œä½¿ç”¨bufferçš„è®¾å¤‡å¯¼å…¥bufferã€‚ DMA_BUFå·²ç»æä¾›äº†è¿™æ ·ä¸€å¥—æœºåˆ¶ã€‚ åœ¨DRMçš„å®ç°ä¸­å°±ä½¿ç”¨äº†è¿™å¥—æœºåˆ¶ï¼Œå…·ä½“æ˜¯é€šè¿‡å€ŸåŠ©dmabuf fdæ¥å®Œæˆçš„ã€‚ å¯¼å‡ºbufferçš„é©±åŠ¨å¯¹å¤–æä¾›ä¸€ä¸ªfdï¼Œæ¥ä»£è¡¨ä¸€ä¸ªbufferï¼Œ è€Œè¦ä½¿ç”¨è¿™ä¸ªbufferçš„å…¶ä»–è®¾å¤‡é©±åŠ¨å°±é€šè¿‡è¿™ä¸ªfdå¯¼å…¥bufferï¼Œä»è€Œè®¿é—®è¯¥bufferã€‚ åœ¨DRMä¸­æˆ‘ä»¬éœ€è¦å®ç°ä¸€å®šçš„DMA_BUFæ¥å£æ¥æ”¯æŒbufferçš„å¯¼å‡ºã€å¯¼å…¥ã€‚ ä¸‹å›¾æ˜¯ä¸€ä¸ªåœ¨ä¸åŒè®¾å¤‡é©±åŠ¨ä¹‹é—´å¯¼å…¥ã€å¯¼å‡ºdma_bufçš„ç®€å•ç¤ºæ„å›¾ 2.2.1.1 exporté©±åŠ¨å®ç° åœ¨é©±åŠ¨çš„å®ç°ä¸­ä¸»è¦æ·»åŠ  .prime_handle_to_fd å’Œ .prime_fd_to_handle_implçš„å®ç°ã€‚ interface å®ç°åŠŸèƒ½ prime_handle_to_fd éœ€è¦å®ç°buffer handle åˆ°dmabuf fdçš„è½¬æ¢ prime_fd_to_handle_impl éœ€è¦å®ç°dmabuf fd åˆ°buffer handleçš„è½¬æ¢ ä¸‹é¢æ˜¯æ”¯æŒbufferå¯¼å‡ºçš„ç®€å•å®ç°. åœ¨å‰é¢codeçš„åŸºç¡€ä¸Šæ·»åŠ äº†å¯¹dma-buf exportçš„æ”¯æŒ,ä¸»è¦æ˜¯å¯¹struct dma_buf_opsçš„å®ç°ã€‚ ç»“æ„dma_buf_ops struct dma_buf_opsç»“æ„å¦‚ä¸‹ï¼š #include &lt;linux/module.h&gt; #include &lt;linux/platform_device.h&gt; #include &lt;linux/slab.h&gt; #include &lt;linux/dma-buf.h&gt; #include &lt;drm/drm_drv.h&gt; #include &lt;drm/drm_file.h&gt; #include &lt;drm/drm_ioctl.h&gt; #define DRIVER_NAME \"drm prime driver\" #define DRIVER_DESC \"test drm prime driver\" #define DRIVER_DATE \"20191124\" #define DRIVER_MAJOR 1 #define DRIVER_MINOR 0 #define log(fmt, args...) printk(\"%s():%d \" fmt \"\\n\", __func__, __LINE__, ##args) #define err(fmt, args...) printk(\"\\033[35m%s():%d \" fmt \"\\033[0m\\n\", __func__, __LINE__, ##args) struct dumb_device { struct drm_device drm; struct platform_device* platform_dev; }; #define MAX_NUM 10 static struct dumb_device* dumb_device = NULL; static struct page* pages[MAX_NUM] = {0}; static u32 buffer_size[MAX_NUM] = {0}; static int page_idx = 0; static int prime_dmabuf_attach_impl(struct dma_buf* dmabuf, struct dma_buf_attachment* attachment) { log(\"attach dmabuf to device, return attachment\"); return 0; } static void prime_dmabuf_detach_impl(struct dma_buf* dmabuf, struct dma_buf_attachment* attachment) { log(\"detach dmabuf\"); } static struct sg_table* prime_dmabuf_map_impl(struct dma_buf_attachment* attachment, enum dma_data_direction dir) { struct page* page = attachment-&gt;dmabuf-&gt;priv; struct sg_table* table; int err; log(\"page:%p\", page); table = kmalloc(sizeof(*table), GFP_KERNEL); if (!table) { log(); return ERR_PTR(-ENOMEM); } // ç”Ÿæˆæ•£åˆ—è¡¨å¹¶èµ‹å€¼ err = sg_alloc_table(table, 1, GFP_KERNEL); if (err) { log(); kfree(table); return ERR_PTR(err); } sg_set_page(table-&gt;sgl, page, PAGE_SIZE, 0); sg_dma_address(table-&gt;sgl) = dma_map_page(&amp;(dumb_device-&gt;platform_dev-&gt;dev), page, 0, PAGE_SIZE, dir); log(\"map attachment into sg_table and return sg_table\"); return table; } static void prime_dmabuf_unmap_impl(struct dma_buf_attachment* attachment, struct sg_table* table, enum dma_data_direction dir) { log(); dma_unmap_page(attachment-&gt;dev, sg_dma_address(table-&gt;sgl), PAGE_SIZE, dir); sg_free_table(table); kfree(table); } static void prime_dmabuf_release_impl(struct dma_buf* dma_buf) { struct page* page = dma_buf-&gt;priv; log(\"put_page:%p\", page); put_page(page); } static int prime_dmabuf_vmap_impl(struct dma_buf* dma_buf, struct dma_buf_map* map) { void* vaddr = NULL; struct page* page = dma_buf-&gt;priv; vaddr = vmap(&amp;page, 1, 0, PAGE_KERNEL); dma_buf_map_set_vaddr(map, vaddr); log(\"mapping page:%p, get virtual addr:%p\", page, vaddr); return 0; } static void prime_dmabuf_vunmap_impl(struct dma_buf* dma_buf, struct dma_buf_map* map) { log(\"unmapping addr:%p\", map-&gt;vaddr); vunmap(map-&gt;vaddr); } static int prime_dmabuf_mmap_impl(struct dma_buf* dma_buf, struct vm_area_struct* vma) { struct page* page = dma_buf-&gt;priv; log(); return remap_pfn_range(vma, vma-&gt;vm_start, page_to_pfn(page), PAGE_SIZE, vma-&gt;vm_page_prot); } static const struct dma_buf_ops exp_dmabuf_ops = { .attach = prime_dmabuf_attach_impl, .detach = prime_dmabuf_detach_impl, .map_dma_buf = prime_dmabuf_map_impl, .unmap_dma_buf = prime_dmabuf_unmap_impl, .release = prime_dmabuf_release_impl, .mmap = prime_dmabuf_mmap_impl, .vmap = prime_dmabuf_vmap_impl, .vunmap = prime_dmabuf_vunmap_impl, }; static int prime_handle_to_fd_impl(struct drm_device* dev, struct drm_file* file_priv, uint32_t handle, uint32_t flags, int* prime_fd) { DEFINE_DMA_BUF_EXPORT_INFO(exp_info); struct dma_buf* dmabuf; log(\"dma_buf -&gt; page:%p\", pages[handle]); exp_info.ops = &amp;exp_dmabuf_ops; exp_info.size = buffer_size[handle]; exp_info.flags= O_CLOEXEC; exp_info.priv = pages[handle]; // bufferå’Œdmabufå»ºç«‹å…³è” // æ„å»ºä¸€ä¸ªdma_buf dmabuf = dma_buf_export(&amp;exp_info); if (IS_ERR(dmabuf)) { log(); return -1; } // ä¸ºè¯¥dma_bufç”Ÿæˆfd *prime_fd = dma_buf_fd(dmabuf, O_CLOEXEC); if (prime_fd &lt;= 0) { log(); return -1; } return 0; } static int prime_fd_to_handle_impl(struct drm_device* dev, struct drm_file* file_priv, int prime_fd, uint32_t* handle) { struct dma_buf* dma_buf; struct page* page = NULL; int idx = 0; log(); dma_buf = dma_buf_get(prime_fd); page = dma_buf-&gt;priv; if (dma_buf-&gt;ops == &amp;exp_dmabuf_ops) { for (idx = 0; idx &lt; MAX_NUM; idx++) { if (pages[idx] == page) { break; } } *handle = idx; log(\"return handle:%d\", *handle); } else { log(\"doesn't support\"); return -1; } dma_buf_put(dma_buf); return 0; } static const struct file_operations dumb_driver_fops = { .owner = THIS_MODULE, .open = drm_open, .release = drm_release, .unlocked_ioctl = drm_ioctl, .compat_ioctl = drm_compat_ioctl, }; static void dumb_release(struct drm_device* dev) { log(); } static int dumb_create_impl(struct drm_file *file_priv, struct drm_device *dev, struct drm_mode_create_dumb* args) { u32 size = 0; log(); if(page_idx&gt;=MAX_NUM){ err(\"only support alloc %d buffers\", MAX_NUM); return -ENOMEM; } size = roundup((args-&gt;width * args-&gt;height * args-&gt;bpp/8), PAGE_SIZE); // åˆ†é…é¡µé¢ pages[page_idx] = alloc_pages(GFP_KERNEL, get_order(size)); if (!pages[page_idx]) { err(\"alloc_pages() failed\"); return -ENOMEM; } buffer_size[page_idx] = size; // èµ‹å€¼è¿”å›å‚æ•° args-&gt;size = size; args-&gt;pitch = args-&gt;width * args-&gt;bpp/8; args-&gt;handle = page_idx++; return 0; } static int dumb_destroy_impl(struct drm_file *file_priv, struct drm_device *dev, uint32_t handle){ log(\"handle:%d\", handle); //__free_pages(pages[handle], get_order(dumb_buffer_size[handle])); free_pages((unsigned long)page_address(pages[handle]), get_order(buffer_size[handle])); return 0; } static struct drm_driver dumb_driver = { .release = dumb_release, .fops = &amp;dumb_driver_fops, .dumb_create = dumb_create_impl, .dumb_destroy = dumb_destroy_impl, .prime_handle_to_fd = prime_handle_to_fd_impl, .prime_fd_to_handle = prime_fd_to_handle_impl, //å…¶ä»–é©±åŠ¨åˆ†é…çš„dma_bufå¯¼å…¥åˆ°DRMç³»ç»Ÿ .name = DRIVER_NAME, .desc = DRIVER_DESC, .date = DRIVER_DATE, .major = DRIVER_MAJOR, .minor = DRIVER_MINOR, }; static int __init dumb_drv_init(void) { int ret; struct platform_device* pdev = NULL; log(\"build time: %s %s\", __DATE__, __TIME__); pdev = platform_device_register_simple(DRIVER_NAME, -1, NULL, 0); if (IS_ERR(pdev)) return PTR_ERR(pdev); if (!devres_open_group(&amp;pdev-&gt;dev, NULL, GFP_KERNEL)) { ret = -ENOMEM; goto out_unregister; } // åˆ†é… dumb_device = devm_drm_dev_alloc(&amp;pdev-&gt;dev, &amp;dumb_driver, struct dumb_device, drm); if (IS_ERR(dumb_device)) { ret = PTR_ERR(dumb_device); goto out_devres; } // æ³¨å†Œ ret = drm_dev_register(&amp;dumb_device-&gt;drm, 0); if (ret) goto out_devres; dumb_device-&gt;platform_dev = pdev; log(\"Finish\"); return 0; out_devres: devres_release_group(&amp;pdev-&gt;dev, NULL); out_unregister: platform_device_unregister(pdev); return ret; } static void __exit dumb_drv_exit(void) { struct platform_device *pdev = dumb_device-&gt;platform_dev; log(); drm_dev_unregister(&amp;dumb_device-&gt;drm); devres_release_group(&amp;pdev-&gt;dev, NULL); platform_device_unregister(pdev); } module_init(dumb_drv_init); module_exit(dumb_drv_exit); MODULE_AUTHOR(\"kevin\"); MODULE_DESCRIPTION(DRIVER_DESC); MODULE_LICENSE(\"GPL\"); 2.2.1.1 importé©±åŠ¨å®ç° import dmabuf çš„é©±åŠ¨éƒ¨åˆ†å®ç°è¾ƒä¸ºç®€å•ï¼Œä¸»è¦æ˜¯å¯¹ä¸‹åˆ—å‡½æ•°çš„è°ƒç”¨,è¿™äº›å‡½æ•°æ­£å¥½å’Œä¸Šé¢struct dma_buf_opsçš„å®ç°ç›¸å¯¹åº”ã€‚ function åŠŸèƒ½ dma_buf_get ç”±fdå¾—åˆ°å¯¹åº”çš„struct dma_buf dma_buf_attach attach dmabuf åˆ°ä¸€ä¸ªè®¾å¤‡ï¼Œå¾—åˆ°ä¸€ä¸ª dma_buf_attachment dma_buf_map_attachment æŠŠä¸€ä¸ªdmabufæ˜ å°„åˆ°ä¸€ä¸ªè®¾å¤‡çš„åœ°å€ç©ºé—´ dma_buf_unmap_attachment å–æ¶ˆdmabufåœ¨è®¾å¤‡åœ°å€ç©ºé—´çš„æ˜ å°„ dma_buf_detach å–æ¶ˆä¸è®¾å¤‡çš„å…³è” #include &lt;linux/dma-buf.h&gt; #include &lt;linux/module.h&gt; #include &lt;linux/miscdevice.h&gt; #include &lt;linux/slab.h&gt; #define log(fmt, args...) printk(\"%s():%d \" fmt \"\\n\", __func__, __LINE__, ##args) static int test_dma_buf(struct dma_buf* dma_buf) { struct dma_buf_attachment* attachment; struct sg_table* table; struct device* dev; unsigned int reg_addr, reg_size; struct scatterlist* sg; struct page* page; int i = 0; if (!dma_buf) { log(); return -EINVAL; } dev = kzalloc(sizeof(*dev), GFP_KERNEL); if (!dev) { log(); return -ENOMEM; } dev_set_name(dev, \"importer\"); attachment = dma_buf_attach(dma_buf, dev); if (IS_ERR(attachment)) { pr_err(\"dma_buf_attach() failed\\n\"); return PTR_ERR(attachment); } log(\"call dma_buf_map_attachment to get sg_table\"); table = dma_buf_map_attachment(attachment, DMA_BIDIRECTIONAL); if (IS_ERR(table)) { pr_err(\"dma_buf_map_attachment() failed\\n\"); dma_buf_detach(dma_buf, attachment); return PTR_ERR(table); } log(\"table-&gt;nents:%d\", table-&gt;nents); sg = table-&gt;sgl; for (i = 0; i &lt; table-&gt;nents; i++) { reg_addr = sg_dma_address(sg); reg_size = sg_dma_len(sg); page = sg_page(sg); log(\"addr = 0x%08x, size = 0x%08x %p %p\\n\", reg_addr, reg_size, page, page_address(page)); sg = sg_next(sg); } // do something on dma-buf log(\"unmap and detach dma_buf\"); dma_buf_unmap_attachment(attachment, table, DMA_BIDIRECTIONAL); dma_buf_detach(dma_buf, attachment); return 0; } static long importer_ioctl(struct file* filp, unsigned int cmd, unsigned long arg) { int fd; struct dma_buf* dma_buf; if (copy_from_user(&amp;fd, (void __user*)arg, sizeof(int))) { log(\"copy_from_user() failed\"); return -EFAULT; } dma_buf = dma_buf_get(fd); log(\"get dma_buf:%p by fd:%d\", dma_buf, fd); if (IS_ERR(dma_buf)) { log(); return PTR_ERR(dma_buf); } test_dma_buf(dma_buf); return 0; } static struct file_operations importer_fops = { .owner = THIS_MODULE, .unlocked_ioctl = importer_ioctl, }; static struct miscdevice mdev = { .minor = MISC_DYNAMIC_MINOR, .name = \"importer\", .fops = &amp;importer_fops, }; static int __init importer_init(void) { log(); return misc_register(&amp;mdev); } static void __exit importer_exit(void) { log(); misc_deregister(&amp;mdev); } module_init(importer_init); module_exit(importer_exit); MODULE_LICENSE(\"GPL v2\"); 2.2.1.1 è¿›ç¨‹é—´åˆ†äº«fd å¦‚æœè¦ä¸åŒè®¾å¤‡ä¸­å…±äº«bufferï¼Œå°±éœ€è¦å¯¼å…¥dmabufåˆ°ä¸åŒçš„è®¾å¤‡ä¸­ï¼Œè¿™å°±æ¶‰åŠåˆ°ä¸€ä¸ªfdå…±äº«çš„é—®é¢˜ã€‚æˆ‘ä»¬çŸ¥é“fdæ˜¯å’Œè¿›ç¨‹ç›¸å…³çš„ï¼Œæ¯ä¸ªè¿›ç¨‹éƒ½æœ‰å®ƒè‡ªå·±çš„æ–‡ä»¶æè¿°ç¬¦è¡¨ï¼Œä¸åŒè¿›ç¨‹çš„fdè¡¨æ˜¯ä¸åŒçš„ã€‚æ‰€ä»¥ä¸èƒ½æŠŠä¸€ä¸ªè¿›ç¨‹çš„fdç›´æ¥ä¼ é€’ç»™å¦ä¸€ä¸ªè¿›ç¨‹ä¸­ä½¿ç”¨ï¼Œéœ€è¦é€šè¿‡ä¸€å®šçš„æ–¹æ³•æ¥å…±äº«fdï¼Œä¹Ÿå°±æ˜¯fdçš„è·¨è¿›ç¨‹ä¼ é€’ã€‚ è¿™ä¸ªæ–¹æ³•å°±æ˜¯UNIXåŸŸçš„socketæ¥å£ã€‚ ä»£ç å¦‚ä¸‹ï¼š å‘é€æ–¹ä»£ç ï¼š #define SHARE_DMABUF_PATH \"./share_dmabuf_file\" static void send_fd(int fd) { int ret = 0; char c = 0; struct iovec iov[1]; iov[0].iov_base = &amp;c; iov[0].iov_len = 1; int sockfd = 0; struct sockaddr_un addr; bzero(&amp;addr, sizeof(addr)); addr.sun_family = AF_UNIX; strcpy(addr.sun_path, SHARE_DMABUF_PATH); sockfd = socket(AF_UNIX, SOCK_STREAM, 0); if (sockfd &lt; 0) { perror(\"socket error\"); exit(-1); } ret = connect(sockfd, (struct sockaddr *)&amp;addr, sizeof(addr)); if(ret &lt;0){ perror(\"connect() failed\"); exit(0); } int cmsgsize = CMSG_LEN(sizeof(int)); struct cmsghdr* cmptr = (struct cmsghdr*)malloc(cmsgsize); if(cmptr == NULL){ err_exit(); } cmptr-&gt;cmsg_level = SOL_SOCKET; cmptr-&gt;cmsg_type = SCM_RIGHTS; cmptr-&gt;cmsg_len = cmsgsize; struct msghdr msg; msg.msg_iov = iov; msg.msg_iovlen = 1; msg.msg_name = NULL; msg.msg_namelen = 0; msg.msg_control = cmptr; msg.msg_controllen = cmsgsize; *(int *)CMSG_DATA(cmptr) = fd; ret = sendmsg(sockfd, &amp;msg, 0); if (ret == -1){ perror(\"sendmsg() failed.\"); err_exit(); } free(cmptr); close(sockfd); } æ¥æ”¶æ–¹ä»£ç  static int recv_fd(int sock) { struct cmsghdr* pcmsg = NULL; union { struct cmsghdr cm; char control[CMSG_SPACE(sizeof(int))]; } control_un; char buf; struct iovec iov[1]; iov[0].iov_base = &amp;buf; iov[0].iov_len = sizeof(buf); struct msghdr msg; msg.msg_iov = iov; msg.msg_iovlen = 1; msg.msg_name = NULL; msg.msg_namelen = 0; msg.msg_control = control_un.control; msg.msg_controllen = sizeof(control_un.control);; int ret = recvmsg(sock, &amp;msg, 0); if (ret == -1) { printf(\"\\033[31m%s:%d sock:%d err:%m \\033[0m\\n\\n\",__func__,__LINE__, sock); exit(1); } pcmsg = CMSG_FIRSTHDR(&amp;msg); int fd = *(int *)CMSG_DATA(pcmsg); return fd; } static int recv_prime_fd_from_socket(void){ int sockfd = 0; struct sockaddr_un addr; unlink(SHARE_DMABUF_PATH); addr.sun_family = AF_UNIX; strcpy(addr.sun_path, SHARE_DMABUF_PATH); int prime_fd; int clientfd; struct sockaddr cliaddr; socklen_t clilen; unsigned int len = strlen(addr.sun_path) + sizeof(addr.sun_family); sockfd = socket(AF_UNIX, SOCK_STREAM, 0); if (sockfd &lt; 0) { perror(\"socket error\"); exit(-1); } if (bind(sockfd, (struct sockaddr*)&amp;addr, len) &lt; 0) { perror(\"bind error\"); close(sockfd); exit(-1); } listen(sockfd, 2); clientfd = accept(sockfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen); if(clientfd&lt;=0){ log(\"clientfd:%d %m\", clientfd); exit(-1); } prime_fd = recv_fd(clientfd); log(\"Recv prime_fd: %d\", prime_fd); return prime_fd; } 2.2.1.2 æµ‹è¯•ç¨‹åº åŸºäºä¸Šè¿°è¿›ç¨‹é—´åˆ†äº«fdçš„æ–¹æ³•ï¼Œç»“åˆPRIME exportå’Œimporté©±åŠ¨å®ç°ï¼Œå¯ä»¥å†™å‡ºå¦‚ä¸‹æµ‹è¯•PRIMEçš„code å¯¼å‡º prime éƒ¨åˆ† #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;xf86drm.h&gt; #include &lt;sys/socket.h&gt; #include &lt;sys/un.h&gt; #define SHARE_DMABUF_PATH \"./tt\" #define log(fmt, args...) printf(\"%s():%d \" fmt \"\\n\", __func__, __LINE__, ##args) #define err_return(fmt, args...) do{ \\ printf(\"%s():%d \" fmt \"\\n\", __func__, __LINE__, ##args); \\ return -1;\\ }while(0) #define err_exit(fmt, args...) do{ \\ printf(\"%s():%d \" fmt \"\\n\", __func__, __LINE__, ##args); \\ exit(1);\\ }while(0) struct buffer_object { uint32_t width; uint32_t height; uint32_t pitch; uint32_t handle; uint32_t size; int prime_fd; }; struct buffer_object buf; static int create_dumb_get_prime_fd(int fd, struct buffer_object *bo){ int ret = 0; struct drm_mode_create_dumb create = {}; create.width = bo-&gt;width; create.height = bo-&gt;height; create.bpp = 4*8; //ARGB ret = drmIoctl(fd, DRM_IOCTL_MODE_CREATE_DUMB, &amp;create); if(ret){ err_return(\"drmIoctl(DRM_IOCTL_MODE_CREATE_DUMB) failed\"); } ret = drmPrimeHandleToFD(fd, create.handle, DRM_CLOEXEC, &amp;bo-&gt;prime_fd); if(ret){ err_return(\"drmPrimeHandleToFD() failed\"); } bo-&gt;handle = create.handle; log(\"get handle:%d prime fd:%d\", create.handle, bo-&gt;prime_fd); return 0; } static void destroy_fd(int fd, struct buffer_object *bo){ int ret = 0; uint32_t handle = 0; struct drm_mode_destroy_dumb destroy = {}; ret = drmPrimeFDToHandle(fd, bo-&gt;prime_fd, &amp;handle); if(ret){ err_exit(\"drmFDToPrimeHandle() failed\"); } log(\"handle:%d vs bo-&gt;handle:%d\", handle, bo-&gt;handle); destroy.handle = handle; drmIoctl(fd, DRM_IOCTL_MODE_DESTROY_DUMB, &amp;destroy); } int main(int argc, char **argv){ int fd; fd = open(\"/dev/dri/card0\", O_RDWR | O_CLOEXEC); if(fd&lt;=0){ printf(\"%s():%d\\n\", __func__,__LINE__); return -1; } buf.width = 1024; buf.height = 1; create_dumb_get_prime_fd(fd, &amp;buf); send_fd(buf.prime_fd); printf(\"press any key to exit\\n\"); getchar(); destroy_fd(fd, &amp;buf); close(fd); return 0; } å¯¼å…¥prime éƒ¨åˆ† #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/socket.h&gt; #include &lt;sys/un.h&gt; #include &lt;sys/ioctl.h&gt; #define log(fmt, args...) printf(\"%s():%d \" fmt \"\\n\", __func__, __LINE__, ##args) #define SHARE_DMABUF_PATH \"./tt\" #define err_return(fmt, args...) do{ \\ printf(\"%s():%d \" fmt \"\\n\", __func__, __LINE__, ##args); \\ return -1;\\ }while(0) #define err_return_void(fmt, args...) do{ \\ printf(\"%s():%d \" fmt \"\\n\", __func__, __LINE__, ##args); \\ return;\\ }while(0) int main(int argc, char **argv){ int ret = 0; int fd; int prime_fd = 5; fd = open(\"/dev/importer\", O_RDWR | O_CLOEXEC); if(fd&lt;=0){ printf(\"%s():%d\\n\", __func__,__LINE__); return -1; } prime_fd = recv_prime_fd_from_socket(); // æŠŠfdä¼ é€’ç»™importé©±åŠ¨è¿›è¡Œè®¿é—® ret = ioctl(fd, 0, &amp;prime_fd); if(ret&lt;0){ err_return(\"ioctl failed\"); } close(prime_fd); close(fd); return 0; } 2.2.2 åŸºäºGEMçš„PRIMEå®ç° ä¸‹å›¾å±•ç¤ºäº†åŸºäºGEMå¦‚ä½•å»å®ç°PRIMEç‰¹æ€§ï¼Œä»£ç å†—é•¿ï¼Œå°±ä¸å†è´´å‡ºã€‚ åœ¨å®ç°driveræ—¶ï¼Œä¸»è¦å·¥ä½œæœ‰ä¸¤ä¸ªæ–¹é¢ã€‚ å®ç° struct drm_driverï¼Œå¦‚å›¾æ‰€ç¤ºï¼Œå°±æ˜¯å„å‡½æ•°æŒ‡é’ˆç›´æ¥è®¾å®šä¸ºGEMçš„å¯¹åº”å‡½æ•°å³å¯ å®ç° drm_gem_object_funcs. åªè¦å®ç°å›¾ä¸­drm_gem_object_funcs å„é¡¹å³å¯ã€‚å®ƒæ‰€è¦å®ç°æ¥å£å¯¹åº”è°ƒç”¨å…³ç³»å¦‚å›¾æ‰€ç¤ºï¼Œä»ä¸­ä¹Ÿå¯çœ‹å‡ºå®ƒä»¬éœ€è¦å®ç°çš„å†…å®¹ã€‚ 2.3 ç³»ç»Ÿç°æœ‰çš„ä¸‰ç§å®ç° 2.3.1 share memory å®ƒæ˜¯åŸºäºGEMå’Œshare memoryå®ç°çš„ä¸€ç»„DRMæ“ä½œï¼Œæ–¹ä¾¿ä¸Šå±‚ä½¿ç”¨ã€‚ /** * DRM_GEM_SHMEM_DRIVER_OPS - Default shmem GEM operations * * This macro provides a shortcut for setting the shmem GEM operations in * the &amp;drm_driver structure. * è¿™ä¸ªå®å®šä¹‰äº†ä¸€ç»„shmem çš„GEMæ“ä½œï¼Œåˆ©ç”¨å®ƒå¯ä»¥å¿«æ·çš„åœ¨drm_driverç»“æ„ä¸­å®šä¹‰GEMæ“ä½œã€‚ * * åœ¨udl, hyperv, vkms, tiny, mgag200å’Œgud é©±åŠ¨ä¸­æœ‰ç”¨åˆ°å®ƒï¼Œå¯åšå‚è€ƒã€‚ * */ #define DRM_GEM_SHMEM_DRIVER_OPS \\ .prime_handle_to_fd = drm_gem_prime_handle_to_fd, \\ .prime_fd_to_handle = drm_gem_prime_fd_to_handle, \\ .gem_prime_import_sg_table = drm_gem_shmem_prime_import_sg_table, \\ .gem_prime_mmap = drm_gem_prime_mmap, \\ .dumb_create = drm_gem_shmem_dumb_create // GEM æä¾›çš„å¯ä¾›driverä½¿ç”¨çš„struct file_operations #define DEFINE_DRM_GEM_FOPS(name) \\ static const struct file_operations name = {\\ .owner = THIS_MODULE,\\ .open = drm_open,\\ .release = drm_release,\\ .unlocked_ioctl = drm_ioctl,\\ .compat_ioctl = drm_compat_ioctl,\\ .poll = drm_poll,\\ .read = drm_read,\\ .llseek = noop_llseek,\\ .mmap = drm_gem_mmap,\\ } åœ¨ç°æœ‰çš„udl, hyperv, vkms, tiny, mgag200å’Œgud é©±åŠ¨ä¸­ï¼Œéƒ½ä½¿ç”¨äº†DEFINE_DRM_GEM_FOPS å’ŒDRM_GEM_SHMEM_DRIVER_OPS æ¥ç®€åŒ–driverçš„å¼€å‘ã€‚ shem_helperçš„å®ç°ï¼Œä¸»è¦å°±æ˜¯é’ˆå¯¹share memoryï¼Œå®ç°drm_gem_object_funcsä¸­å®šä¹‰çš„å„ä¸ªå‡½æ•°æ¥å£ã€‚ å…³ç³»å›¾å¦‚ä¸‹ï¼š 2.3.1.1 create dumb å®ç°æµç¨‹å›¾å¦‚ä¸‹ï¼š 2.3.1.2 mmap å®ç°æµç¨‹å›¾å¦‚ä¸‹ï¼š 2.3.1.3 å…¶ä»–å…³äºGEMçš„å®ç° å®ç°æµç¨‹å›¾å¦‚ä¸‹ï¼š 2.3.2 CMA CMA: Contiguous Memory Allocatorï¼Œ CMAæ˜¯ä¸€ç§å†…å­˜åˆ†é…æœºåˆ¶ï¼Œç¡®ä¿åˆ†é…ç‰©ç†ä¸Šè¿ç»­çš„å†…å­˜åŒºåŸŸï¼Œå®ƒç‰¹åˆ«é€‚ç”¨äºéœ€è¦å…·æœ‰è¿ç»­å†…å­˜çš„è®¾å¤‡ï¼ˆä¾‹å¦‚æ˜¾ç¤ºæ§åˆ¶å™¨ï¼‰çš„æƒ…å†µã€‚ DRMçš„CMA helperæä¾›äº†ä¸€ç§åˆ†é…æ—¢å…·æœ‰ç‰©ç†è¿ç»­æ€§åˆé€‚ç”¨äºDMAï¼ˆç›´æ¥å†…å­˜è®¿é—®ï¼‰æ“ä½œçš„å†…å­˜çš„æ–¹æ³•ï¼Œé€‚åˆåœ¨ç¡¬ä»¶ç¼ºä¹IOMMUï¼ˆè¾“å…¥/è¾“å‡ºå†…å­˜ç®¡ç†å•å…ƒï¼‰æ¥æ˜ å°„åˆ†æ•£çš„ç¼“å†²åŒºçš„åœºæ™¯ä½¿ç”¨ã€‚ /** * DRM_GEM_CMA_DRIVER_OPS_WITH_DUMB_CREATE - CMA GEM driver operations * @dumb_create_func: callback function for .dumb_create * * This macro provides a shortcut for setting the default GEM operations in the * &amp;drm_driver structure. * * This macro is a variant of DRM_GEM_CMA_DRIVER_OPS for drivers that * override the default implementation of &amp;struct rm_driver.dumb_create. Use * DRM_GEM_CMA_DRIVER_OPS if possible. Drivers that require a virtual address * on imported buffers should use * DRM_GEM_CMA_DRIVER_OPS_VMAP_WITH_DUMB_CREATE() instead. * * ä½¿ç”¨åˆ°å®ƒçš„ç°æœ‰é©±åŠ¨æœ‰: aspeed, sti vc4 hisilicon ingenic shmobile xlnx imx sun4i tiny meson ç­‰ */ #define DRM_GEM_CMA_DRIVER_OPS_WITH_DUMB_CREATE(dumb_create_func) \\ .dumb_create = (dumb_create_func), \\ .prime_handle_to_fd = drm_gem_prime_handle_to_fd, \\ .prime_fd_to_handle = drm_gem_prime_fd_to_handle, \\ .gem_prime_import_sg_table = drm_gem_cma_prime_import_sg_table, \\ .gem_prime_mmap = drm_gem_prime_mmap #define DRM_GEM_CMA_DRIVER_OPS \\ DRM_GEM_CMA_DRIVER_OPS_WITH_DUMB_CREATE(drm_gem_cma_dumb_create) cma_helperçš„å®ç°ï¼Œä¸»è¦å°±æ˜¯é’ˆå¯¹CMAçš„ç‰¹æ€§è°ƒç”¨DMAçš„æ¥å£å®ç°drm_gem_object_funcsä¸­å®šä¹‰çš„å„ä¸ªå‡½æ•°æ¥å£ã€‚ ä¸€äº›åœ¨CMAä¸­å®ç°çš„å‡½æ•° function åŠŸèƒ½ drm_gem_cma_create åˆ†é…ç”±CMAå†…å­˜æ”¯æŒçš„GEMå¯¹è±¡ã€‚ drm_gem_cma_dumb_create_internal ä¸ºDRMå¸§ç¼“å†²åˆ›å»ºå†…å­˜åŒºåŸŸã€‚ drm_gem_cma_dumb_map_offset å°†DRMå¸§ç¼“å†²çš„å†…å­˜åŒºåŸŸæ˜ å°„åˆ°ç”¨æˆ·ç©ºé—´ã€‚ drm_gem_cma_mmap ä¸ºç”¨æˆ·ç©ºé—´è®¿é—®æ˜ å°„åˆ†é…çš„å†…å­˜ã€‚ drm_gem_cma_free_object é‡Šæ”¾GEMå¯¹è±¡ã€‚ drm_gem_cma_prime_get_sg_table è·å–å¯¼å…¥PRIMEç¼“å†²åŒºçš„æ•£å°„/èšé›†è¡¨ã€‚ drm_gem_cma_prime_import_sg_table ä»æ•£å°„/èšé›†è¡¨å¯¼å…¥GEMå¯¹è±¡ã€‚ drm_gem_cma_prime_mmap ä¸ºPRIME mmapæ˜ å°„GEMå¯¹è±¡ã€‚ drm_gem_cma_prime_vmapå’Œdrm_gem_cma_prime_vunmap ä¸ºPRIMEæ˜ å°„å’Œå–æ¶ˆæ˜ å°„GEMå¯¹è±¡ã€‚ å…³ç³»å›¾å¦‚ä¸‹ï¼š 2.3.2.1 create dumb å®ç°æµç¨‹å›¾å¦‚ä¸‹ï¼š 2.3.2.2 mmap å®ç°æµç¨‹å›¾å¦‚ä¸‹ï¼š 2.3.2.3 å…¶ä»–å…³äºGEMçš„å®ç° å®ç°æµç¨‹å›¾å¦‚ä¸‹ï¼š 2.3.3 VRAM VRAM: Video RAM VRAMæ˜¯æ˜¾å¡ä¸Šçš„ä¸“ç”¨å†…å­˜ï¼Œç”¨äºå­˜å‚¨å›¾åƒã€çº¹ç†ã€å¸§ç¼“å†²åŒºå’Œå…¶ä»–ä¸å›¾å½¢ç›¸å…³çš„æ•°æ®ã€‚åœ¨æ˜¾å¡ä¸­ï¼ŒVRAMæ˜¯ç”¨äºæ˜¾ç¤ºè¾“å‡ºçš„å†…å­˜æ± ã€‚å®ƒé€šå¸¸ä½äºæ˜¾å¡èŠ¯ç‰‡ä¸Šï¼Œå…·æœ‰é«˜å¸¦å®½å’Œä½å»¶è¿Ÿï¼Œé€‚ç”¨äºå›¾å½¢æ¸²æŸ“ã€‚VRAMçš„å¤§å°ç›´æ¥å½±å“æ˜¾å¡çš„æ€§èƒ½ã€‚æ›´å¤§çš„VRAMå…è®¸å­˜å‚¨æ›´å¤šå›¾åƒæ•°æ®ï¼Œä»è€Œæé«˜å›¾å½¢å¤„ç†é€Ÿåº¦ã€‚ /** * define DRM_GEM_VRAM_DRIVER - default callback functions for \\ &amp;struct drm_driver * * Drivers that use VRAM MM and GEM VRAM can use this macro to initialize * &amp;struct drm_driver with default functions. * * ä½¿ç”¨åˆ°å®ƒçš„ç°æœ‰é©±åŠ¨æœ‰: ast, tiny vboxvideo */ #define DRM_GEM_VRAM_DRIVER \\ .debugfs_init = drm_vram_mm_debugfs_init, \\ .dumb_create = drm_gem_vram_driver_dumb_create, \\ .dumb_map_offset = drm_gem_ttm_dumb_map_offset, \\ .gem_prime_mmap = drm_gem_prime_mmap vram_helperçš„å®ç°ï¼Œä¸»è¦æ˜¯å¯¹TTMæ¥å£çš„å°è£…è°ƒç”¨æ¥å®ç°drm_gem_object_funcsä¸­å®šä¹‰çš„å„ä¸ªå‡½æ•°æ¥å£ã€‚ GEMã€ TTMä½¿ç”¨åœºæ™¯ GEMé€šå¸¸ç”¨äºUMAï¼ˆUnified Memory Architectureï¼‰è®¾å¤‡ï¼Œè€ŒTTMæ›´é€‚ç”¨äºå…·æœ‰ä¸“ç”¨è§†é¢‘RAMçš„è®¾å¤‡ã€‚ å…³ç³»å›¾å¦‚ä¸‹ï¼š 2.3.3.1 create dumb å®ç°æµç¨‹å›¾å¦‚ä¸‹ï¼š 2.3.3.2 mmap å®ç°æµç¨‹å›¾å¦‚ä¸‹ï¼š 2.3.3.3 å…¶ä»–å…³äºGEMçš„å®ç° å®ç°æµç¨‹å›¾å¦‚ä¸‹ï¼š 3.KMS 3.1 ç›¸å…³æ¦‚å¿µ KMSï¼ˆKernel Mode Settingï¼‰æ˜¯DRMæ¡†æ¶çš„ä¸€ä¸ªé‡è¦æ¨¡å—ï¼Œ ä¸»è¦ä¸¤ä¸ªåŠŸèƒ½ï¼š æ˜¾ç¤ºå‚æ•°è®¾ç½®ï¼š KMSè´Ÿè´£è®¾ç½®æ˜¾å¡æˆ–å›¾å½¢é€‚é…å™¨çš„æ¨¡å¼ï¼ŒåŒ…æ‹¬åˆ†è¾¨ç‡ã€åˆ·æ–°ç‡ã€ç”µæºçŠ¶æ€ï¼ˆä¼‘çœ å”¤é†’ï¼‰ç­‰ã€‚ æ˜¾ç¤ºç”»é¢æ§åˆ¶ï¼š KMSç®¡ç†æ˜¾ç¤ºç¼“å†²åŒºçš„åˆ‡æ¢ã€å¤šå›¾å±‚çš„åˆæˆæ–¹å¼ï¼Œä»¥åŠæ¯ä¸ªå›¾å±‚çš„æ˜¾ç¤ºä½ç½®ã€‚ KMSçš„ç»„æˆéƒ¨åˆ†ï¼š DRM FrameBufferï¼š è¿™æ˜¯ä¸€ä¸ªè½¯ä»¶æŠ½è±¡ï¼Œä¸ç¡¬ä»¶æ— å…³ï¼Œæè¿°äº†å›¾å±‚æ˜¾ç¤ºå†…å®¹çš„ä¿¡æ¯ï¼Œå¦‚å®½åº¦ã€é«˜åº¦ã€åƒç´ æ ¼å¼å’Œè¡Œè·ç­‰ã€‚ Planesï¼š åŸºæœ¬çš„æ˜¾ç¤ºæ§åˆ¶å•å…ƒï¼Œæ¯ä¸ªå›¾åƒéƒ½æœ‰ä¸€ä¸ªPlaneã€‚Planesçš„å±æ€§æ§åˆ¶ç€å›¾åƒçš„æ˜¾ç¤ºåŒºåŸŸã€ç¿»è½¬æ–¹å¼å’Œè‰²å½©æ··åˆæ–¹å¼ã€‚ CRTCï¼š CRTCè´Ÿè´£å°†è¦æ˜¾ç¤ºçš„å›¾åƒè½¬åŒ–ä¸ºåº•å±‚ç¡¬ä»¶ä¸Šçš„å…·ä½“æ—¶åºè¦æ±‚ã€‚å®ƒè¿˜è´Ÿè´£å¸§åˆ‡æ¢ã€ç”µæºæ§åˆ¶å’Œè‰²å½©è°ƒæ•´ï¼Œå¯ä»¥è¿æ¥å¤šä¸ªEncoderï¼Œå®ç°å±å¹•å¤åˆ¶åŠŸèƒ½ã€‚ Encoderï¼š å°†å†…å­˜ä¸­çš„åƒç´ è½¬æ¢æˆæ˜¾ç¤ºå™¨æ‰€éœ€çš„ä¿¡å·ã€‚ Connectorï¼š è¿æ¥å™¨è´Ÿè´£ç¡¬ä»¶è®¾å¤‡çš„æ¥å…¥ï¼Œå¦‚HDMIã€VGAç­‰ï¼Œè¿˜å¯ä»¥è·å–è®¾å¤‡çš„EDIDå’ŒDPMSè¿æ¥çŠ¶æ€ã€‚ è¿™äº›ç»„ä»¶å…±åŒæ„æˆäº†ä¸€ä¸ªå®Œæ•´çš„DRMæ˜¾ç¤ºæ§åˆ¶è¿‡ç¨‹ã€‚KMSçš„ç›®æ ‡æ˜¯é€‚åº”ç°ä»£æ˜¾ç¤ºè®¾å¤‡çš„é€»è¾‘ï¼Œä½¿å…¶èƒ½å¤Ÿæ›´å¥½åœ°æ”¯æŒæ–°ç‰¹æ€§ï¼Œå¦‚æ˜¾ç¤ºè¦†ç›–ã€GPUåŠ é€Ÿå’Œç¡¬ä»¶å…‰æ ‡ç­‰åŠŸèƒ½ã€‚ 3.2 é‡è¦ç»“æ„ä½“ 3.3 å‡½æ•°æµç¨‹ devm_drm_dev_alloc() drm_vblank_init() drm_mode_config_init() drmModeAddFb() init CRTC init plane init connector 3.4 ä¼ ç»Ÿå®ç° drmModeSetCrtc 3.5 atomicå®ç° smaple code #define _GNU_SOURCE #include &lt;errno.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdbool.h&gt; #include &lt;stdint.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;sys/mman.h&gt; #include &lt;time.h&gt; #include &lt;unistd.h&gt; #include &lt;xf86drm.h&gt; #include &lt;xf86drmMode.h&gt; struct buffer_object { uint32_t width; uint32_t height; uint32_t pitch; uint32_t handle; uint32_t size; uint32_t fb_id; }; struct buffer_object buf; static int modeset_create_fb(int fd, struct buffer_object *bo) { struct drm_mode_create_dumb create = {}; struct drm_mode_map_dumb map = {}; create.width = bo-&gt;width; create.height = bo-&gt;height; create.bpp = 32; drmIoctl(fd, DRM_IOCTL_MODE_CREATE_DUMB, &amp;create); bo-&gt;pitch = create.pitch; bo-&gt;size = create.size; bo-&gt;handle = create.handle; drmModeAddFB(fd, bo-&gt;width, bo-&gt;height, 24, 32, bo-&gt;pitch,bo-&gt;handle, &amp;bo-&gt;fb_id); // drmModeAddFB2 å¯ä»¥ä¼ é€’å¤šä¸ªhandle // drmModeAddFB(fd, bo-&gt;width, bo-&gt;height, 24, 32, bo-&gt;pitch, // bo-&gt;handle, &amp;bo-&gt;fb_id); //--&gt; calling mode_config_funcs.fb_create() map.handle = create.handle; drmIoctl(fd, DRM_IOCTL_MODE_MAP_DUMB, &amp;map); return 0; } static void modeset_destroy_fb(int fd, struct buffer_object *bo) { struct drm_mode_destroy_dumb destroy = {}; drmModeRmFB(fd, bo-&gt;fb_id); destroy.handle = bo-&gt;handle; drmIoctl(fd, DRM_IOCTL_MODE_DESTROY_DUMB, &amp;destroy); } static uint32_t get_property_id(int fd, drmModeObjectProperties *props, const char *name) { drmModePropertyPtr property; uint32_t i, id = 0; for (i = 0; i &lt; props-&gt;count_props; i++) { property = drmModeGetProperty(fd, props-&gt;props[i]); if (!strcmp(property-&gt;name, name)){ id = property-&gt;prop_id; } drmModeFreeProperty(property); if (id) break; } return id; } int main(int argc, char **argv) { int fd; drmModeConnector *conn; drmModeRes *res; drmModePlaneRes *plane_res; drmModeObjectProperties *props; drmModeAtomicReq *req; uint32_t conn_id; uint32_t crtc_id; uint32_t plane_id; uint32_t blob_id; uint32_t property_crtc_id; uint32_t property_mode_id; uint32_t property_active; uint32_t property_fb_id; uint32_t property_crtc_x; uint32_t property_crtc_y; uint32_t property_crtc_w; uint32_t property_crtc_h; uint32_t property_src_x; uint32_t property_src_y; uint32_t property_src_w; uint32_t property_src_h; fd = open(\"/dev/dri/card0\", O_RDWR | O_CLOEXEC); res = drmModeGetResources(fd); crtc_id = res-&gt;crtcs[0]; conn_id = res-&gt;connectors[0]; drmSetClientCap(fd, DRM_CLIENT_CAP_UNIVERSAL_PLANES, 1); plane_res = drmModeGetPlaneResources(fd); plane_id = plane_res-&gt;planes[0]; conn = drmModeGetConnector(fd, conn_id); buf.width = conn-&gt;modes[0].hdisplay; buf.height = conn-&gt;modes[0].vdisplay; modeset_create_fb(fd, &amp;buf); drmSetClientCap(fd, DRM_CLIENT_CAP_ATOMIC, 1); props = drmModeObjectGetProperties(fd, conn_id, DRM_MODE_OBJECT_CONNECTOR); property_crtc_id = get_property_id(fd, props, \"CRTC_ID\"); drmModeFreeObjectProperties(props); props = drmModeObjectGetProperties(fd, crtc_id, DRM_MODE_OBJECT_CRTC); property_active = get_property_id(fd, props, \"ACTIVE\"); property_mode_id = get_property_id(fd, props, \"MODE_ID\"); drmModeFreeObjectProperties(props); drmModeCreatePropertyBlob(fd, &amp;conn-&gt;modes[0], sizeof(conn-&gt;modes[0]), &amp;blob_id); req = drmModeAtomicAlloc(); drmModeAtomicAddProperty(req, crtc_id, property_active, 1); drmModeAtomicAddProperty(req, crtc_id, property_mode_id, blob_id); drmModeAtomicAddProperty(req, conn_id, property_crtc_id, crtc_id); drmModeAtomicCommit(fd, req, DRM_MODE_ATOMIC_ALLOW_MODESET, NULL); drmModeAtomicFree(req); /* get plane properties */ props = drmModeObjectGetProperties(fd, plane_id, DRM_MODE_OBJECT_PLANE); property_crtc_id = get_property_id(fd, props, \"CRTC_ID\"); property_fb_id = get_property_id(fd, props, \"FB_ID\"); property_crtc_x = get_property_id(fd, props, \"CRTC_X\"); property_crtc_y = get_property_id(fd, props, \"CRTC_Y\"); property_crtc_w = get_property_id(fd, props, \"CRTC_W\"); property_crtc_h = get_property_id(fd, props, \"CRTC_H\"); property_src_x = get_property_id(fd, props, \"SRC_X\"); property_src_y = get_property_id(fd, props, \"SRC_Y\"); property_src_w = get_property_id(fd, props, \"SRC_W\"); property_src_h = get_property_id(fd, props, \"SRC_H\"); drmModeFreeObjectProperties(props); /* atomic plane update */ req = drmModeAtomicAlloc(); drmModeAtomicAddProperty(req, plane_id, property_crtc_id, crtc_id); drmModeAtomicAddProperty(req, plane_id, property_fb_id, buf.fb_id); drmModeAtomicAddProperty(req, plane_id, property_crtc_x, 50); drmModeAtomicAddProperty(req, plane_id, property_crtc_y, 50); drmModeAtomicAddProperty(req, plane_id, property_crtc_w, 320); drmModeAtomicAddProperty(req, plane_id, property_crtc_h, 320); drmModeAtomicAddProperty(req, plane_id, property_src_x, 0); drmModeAtomicAddProperty(req, plane_id, property_src_y, 0); drmModeAtomicAddProperty(req, plane_id, property_src_w, 320 &lt;&lt; 16); drmModeAtomicAddProperty(req, plane_id, property_src_h, 320 &lt;&lt; 16); drmModeAtomicCommit(fd, req, 0, NULL); drmModeAtomicFree(req); printf(\"drmModeAtomicCommit SetPlane done\\n\"); getchar(); modeset_destroy_fb(fd, &amp;buf); drmModeFreeConnector(conn); drmModeFreePlaneResources(plane_res); drmModeFreeResources(res); close(fd); return 0; } drmModeGetProperty drmModeAtomicCommit 3.6 vkms VKMSï¼ˆVirtual Kernel Modesettingï¼‰æ˜¯ Linux å†…æ ¸ä¸­çš„ä¸€ä¸ªè½¯ä»¶æ¨¡æ‹Ÿ KMS é©±åŠ¨ç¨‹åºï¼Œä¸»è¦ç”¨äºæµ‹è¯•å’Œåœ¨æ— æ˜¾ç¤ºç¡¬ä»¶çš„æœºå™¨ä¸Šè¿è¡Œ Xï¼ˆæˆ–ç±»ä¼¼çš„å›¾å½¢ç•Œé¢ï¼‰ 4 MISC 4.1 modifier åœ¨ DRMï¼ˆDirect Rendering Managerï¼‰ ä¸­ï¼Œmodifier æ˜¯ç”¨äºæè¿°å›¾åƒå¸§çš„å†…å­˜å­˜å‚¨æ–¹å¼çš„æ ‡å¿—ã€‚è®©æˆ‘ä»¬è¯¦ç»†äº†è§£ä¸€ä¸‹ï¼š DRM Modifier æ˜¯ä»€ä¹ˆï¼Ÿ DRM Modifier æ˜¯ä¸€ä¸ª 64 ä½çš„ã€å‚å•†å‰ç¼€çš„ã€åŠé€æ˜çš„æ— ç¬¦å·æ•´æ•°ã€‚ å¤§å¤šæ•° modifier è¡¨ç¤ºå›¾åƒçš„å…·ä½“ã€å‚å•†ç‰¹å®šçš„å¹³é“ºæ ¼å¼ã€‚ ä¸ºä»€ä¹ˆéœ€è¦ Modifierï¼Ÿ å›¾åƒå¸§åœ¨å†…å­˜ä¸­çš„å­˜å‚¨æ–¹å¼å¯èƒ½å› ç¡¬ä»¶å’Œé©±åŠ¨ç¨‹åºè€Œå¼‚ã€‚ Modifier æè¿°äº†åƒç´ åˆ°å†…å­˜æ ·æœ¬ä¹‹é—´çš„è½¬æ¢æœºåˆ¶ï¼Œä»¥åŠç¼“å†²åŒºçš„å®é™…å†…å­˜å­˜å‚¨æ–¹å¼ã€‚ å¸¸è§ Modifier ç¤ºä¾‹ï¼š LINEAR Modifierï¼šæœ€ç›´æ¥çš„ Modifierï¼Œå…¶ä¸­æ¯ä¸ªåƒç´ å…·æœ‰è¿ç»­çš„å­˜å‚¨ï¼Œåƒç´ åœ¨å†…å­˜ä¸­çš„ä½ç½®å¯ä»¥é€šè¿‡æ­¥å¹…è½»æ¾è®¡ç®—ã€‚ TILED Modifierï¼šæè¿°äº†åƒç´ ä»¥ 4x4 å—çš„å½¢å¼å­˜å‚¨ï¼ŒæŒ‰è¡Œä¸»åºæ’åˆ—ã€‚ å…¶ä»– Modifier å¯èƒ½æ¶‰åŠåˆ°æ›´å¤æ‚çš„å†…å­˜è®¿é—®æœºåˆ¶ï¼Œä¾‹å¦‚å¹³é“ºå’Œå¯èƒ½çš„å‹ç¼©ã€‚ åº”ç”¨åœºæ™¯ï¼š DRM Modifier åœ¨è·¨è®¾å¤‡çš„ç¼“å†²åŒºå…±äº«ä¸­éå¸¸é‡è¦ï¼Œä¾‹å¦‚åœ¨ä¸åŒçš„å›¾å½¢ç¡¬ä»¶ä¹‹é—´å…±äº«å›¾åƒå¸§ã€‚ å®ƒä»¬ä¹Ÿç”¨äºæè¿°å›¾åƒå¸§çš„æ ¼å¼ï¼Œä¾‹å¦‚é¢œè‰²å®šä¹‰å’Œåƒç´ æ ¼å¼ã€‚ æ€»ä¹‹ï¼ŒDRM Modifier æ˜¯æè¿°å›¾åƒå¸§å†…å­˜å­˜å‚¨æ–¹å¼çš„å…³é”®æ ‡å¿—ï¼Œå¯¹äºå›¾å½¢ç¡¬ä»¶å’Œé©±åŠ¨ç¨‹åºä¹‹é—´çš„äº¤äº’è‡³å…³é‡è¦ã€‚ 4.2 gamma åœ¨ DRMï¼ˆDirect Rendering Managerï¼‰ ä¸­ï¼Œgamma æ˜¯ç”¨äºå›¾åƒé¢œè‰²æ ¡æ­£çš„ä¸€ä¸ªé‡è¦æ¦‚å¿µã€‚è®©æˆ‘è¯¦ç»†è§£é‡Šä¸€ä¸‹ï¼š Gamma æ˜¯ä»€ä¹ˆï¼Ÿ Gamma æ˜¯ä¸€ä¸ªéçº¿æ€§çš„é¢œè‰²æ ¡æ­£è¿‡ç¨‹ï¼Œç”¨äºè°ƒæ•´æ˜¾ç¤ºè®¾å¤‡çš„äº®åº¦å’Œå¯¹æ¯”åº¦ã€‚ å®ƒä¸»è¦å½±å“å›¾åƒçš„ä¸­é—´å’Œæš—éƒ¨ï¼Œè€Œä¸æ˜¯äº®éƒ¨ã€‚ Gamma æ ¡æ­£çš„ä½œç”¨ï¼š Gamma æ ¡æ­£ç”¨äºè¡¥å¿æ˜¾ç¤ºè®¾å¤‡çš„éçº¿æ€§å“åº”ã€‚ æ˜¾ç¤ºè®¾å¤‡ï¼ˆä¾‹å¦‚æ˜¾ç¤ºå™¨ã€ç”µè§†ï¼‰å¯¹è¾“å…¥ä¿¡å·çš„å“åº”ä¸æ˜¯çº¿æ€§çš„ï¼Œè€Œæ˜¯å‘ˆç°å‡ºä¸€ç§éçº¿æ€§çš„äº®åº¦-è¾“å…¥å…³ç³»ã€‚ é€šè¿‡åº”ç”¨ Gamma æ ¡æ­£ï¼Œå¯ä»¥ä½¿å›¾åƒåœ¨æ˜¾ç¤ºæ—¶æ›´æ¥è¿‘äººçœ¼æ„ŸçŸ¥çš„çº¿æ€§äº®åº¦ã€‚ Gamma æ›²çº¿ï¼š Gamma æ›²çº¿æè¿°äº†è¾“å…¥ä¿¡å·å’Œæ˜¾ç¤ºäº®åº¦ä¹‹é—´çš„å…³ç³»ã€‚ é€šå¸¸ï¼Œæ˜¾ç¤ºè®¾å¤‡çš„ Gamma æ›²çº¿æ˜¯ä¸€ä¸ªå¹‚å‡½æ•°ï¼Œé€šå¸¸åœ¨ 2.2 åˆ° 2.5 ä¹‹é—´ã€‚ åº”ç”¨åœºæ™¯ï¼š Gamma æ ¡æ­£åœ¨å›¾å½¢ã€è§†é¢‘å’Œæ¸¸æˆä¸­éƒ½å¾ˆé‡è¦ã€‚ åœ¨å›¾åƒå¤„ç†å’Œæ˜¾ç¤ºä¸­ï¼Œåº”ç”¨æ­£ç¡®çš„ Gamma æ›²çº¿å¯ä»¥ç¡®ä¿å›¾åƒçš„äº®åº¦å’Œå¯¹æ¯”åº¦åœ¨ä¸åŒè®¾å¤‡ä¸Šä¿æŒä¸€è‡´ã€‚ æ€»ä¹‹ï¼ŒGamma æ˜¯ä¸€ç§ç”¨äºè°ƒæ•´æ˜¾ç¤ºè®¾å¤‡å“åº”çš„éçº¿æ€§é¢œè‰²æ ¡æ­£æ–¹æ³•ï¼Œä»¥ç¡®ä¿å›¾åƒåœ¨ä¸åŒè®¾å¤‡ä¸Šå‘ˆç°ä¸€è‡´çš„äº®åº¦å’Œå¯¹æ¯”åº¦ã€‚ 4.3 Blob å½“æ¶‰åŠåˆ° DRMï¼ˆDirect Rendering Managerï¼‰ä¸­çš„â€œblobâ€æ—¶ï¼Œæˆ‘ä»¬å®é™…ä¸Šåœ¨è®¨è®ºä¸€ç§ç‰¹å®šç±»å‹çš„å±æ€§ã€‚è®©æˆ‘è¯¦ç»†è§£é‡Šä¸€ä¸‹ï¼š 1 ä»€ä¹ˆæ˜¯ Blobï¼Ÿ åœ¨ DRM ä¸­ï¼ŒBlob æ˜¯ä¸€ç§ç‰¹æ®Šçš„å±æ€§ï¼Œç”¨äºå­˜å‚¨è‡ªå®šä¹‰æ•°æ®å—ã€‚å®ƒå…è®¸ç”¨æˆ·ç©ºé—´åº”ç”¨ç¨‹åºå°†è‡ªå®šä¹‰ç»“æ„ä½“æ•°æ®ä¼ é€’ç»™å†…æ ¸ç©ºé—´ã€‚ Blob é€šå¸¸ç”¨äºå­˜å‚¨ä¸€äº›ä¸é€‚åˆä½¿ç”¨æ ‡å‡†å±æ€§çš„æ•°æ®ï¼Œä¾‹å¦‚æ¨¡å¼ä¿¡æ¯ã€LUTï¼ˆæŸ¥æ‰¾è¡¨ï¼‰æ•°æ®ã€æ ¡å‡†æ•°æ®ç­‰ã€‚ 2 Blob çš„ç»“æ„å’Œç”¨æ³•ï¼š Blob ç”±ä¸¤éƒ¨åˆ†ç»„æˆï¼š Blob IDï¼šæ¯ä¸ª Blob éƒ½æœ‰ä¸€ä¸ªå”¯ä¸€çš„ IDï¼Œç”¨äºåœ¨å†…æ ¸ä¸­æ ‡è¯†è¯¥ Blobã€‚ Blob æ•°æ®ï¼šè¿™æ˜¯ä¸€ä¸ªè‡ªå®šä¹‰é•¿åº¦çš„å†…å­˜å—ï¼Œå¯ä»¥å­˜å‚¨ä»»ä½•ç±»å‹çš„æ•°æ®ã€‚ Blob å¯ä»¥å­˜å‚¨å„ç§ä¿¡æ¯ï¼Œä¾‹å¦‚æ˜¾ç¤ºæ¨¡å¼ï¼ˆmodeï¼‰çš„è¯¦ç»†ä¿¡æ¯ã€é¢œè‰²æ ¡å‡†æ•°æ®ã€Gamma è¡¨ç­‰ã€‚ 3 Blob çš„ç¤ºä¾‹ç”¨é€”ï¼š æ¨¡å¼ä¿¡æ¯ï¼ˆMode Informationï¼‰ï¼šBlob å¯ä»¥å­˜å‚¨æ˜¾ç¤ºæ¨¡å¼çš„è¯¦ç»†ä¿¡æ¯ï¼Œä¾‹å¦‚åˆ†è¾¨ç‡ã€åˆ·æ–°ç‡ã€åƒç´ æ ¼å¼ç­‰ã€‚ é¢œè‰²æ ¡å‡†æ•°æ®ï¼šå¦‚æœæ‚¨éœ€è¦åœ¨æ˜¾ç¤ºè®¾å¤‡ä¸Šè¿›è¡Œé¢œè‰²æ ¡å‡†ï¼Œå¯ä»¥ä½¿ç”¨ Blob å­˜å‚¨æ ¡å‡†æ•°æ®ã€‚ Gamma è¡¨ï¼šGamma è¡¨ç”¨äºè°ƒæ•´æ˜¾ç¤ºè®¾å¤‡çš„äº®åº¦å’Œå¯¹æ¯”åº¦ã€‚è¿™äº›æ•°æ®å¯ä»¥å­˜å‚¨åœ¨ Blob ä¸­ã€‚ 4 å¦‚ä½•æ“ä½œ Blobï¼Ÿ ç”¨æˆ·ç©ºé—´åº”ç”¨ç¨‹åºå¯ä»¥é€šè¿‡ DRM æ¥å£æ¥åˆ›å»ºã€è·å–å’Œè®¾ç½® Blobã€‚ åˆ›å»º Blobï¼šä½¿ç”¨ drmModeCreatePropertyBlob å‡½æ•°æ¥åˆ›å»ºä¸€ä¸ª Blobï¼Œå¹¶å°†è‡ªå®šä¹‰æ•°æ®ä¼ é€’ç»™å†…æ ¸ã€‚ è·å– Blob æ•°æ®ï¼šä½¿ç”¨ drmModeGetPropertyBlob å‡½æ•°æ¥è·å– Blob ä¸­å­˜å‚¨çš„æ•°æ®ã€‚ è®¾ç½® Blob æ•°æ®ï¼šä½¿ç”¨ drmModeAtomicAddProperty å‡½æ•°å°† Blob ID æ·»åŠ åˆ° Atomic è¯·æ±‚ä¸­ï¼Œä»è€Œä¿®æ”¹ Blob æ•°æ®ã€‚ 5 ç¤ºä¾‹ #include &lt;xf86drm.h&gt; #include &lt;xf86drmMode.h&gt; int main() { int drm_fd = open(\"/dev/dri/card0\", O_RDWR); // æ‰“å¼€ DRM è®¾å¤‡ // è¯»å– GPU å›ºä»¶æ•°æ®ï¼ˆå‡è®¾å­˜åœ¨ firmware.bin æ–‡ä»¶ï¼‰ FILE *firmware_file = fopen(\"firmware.bin\", \"rb\"); fseek(firmware_file, 0, SEEK_END); size_t firmware_size = ftell(firmware_file); fseek(firmware_file, 0, SEEK_SET); void *firmware_data = malloc(firmware_size); fread(firmware_data, 1, firmware_size, firmware_file); fclose(firmware_file); // åˆ›å»º DRM blob uint32_t blob_handle; drmModeCreatePropertyBlob(drm_fd, firmware_data, firmware_size, &amp;blob_handle); // å°† blob è®¾ç½®ä¸º GPU çš„å›ºä»¶ // ...ï¼ˆå…¶ä»–æ“ä½œï¼Œä¾‹å¦‚åŠ è½½åˆ°æ˜¾å¡ï¼‰ // æ¸…ç†èµ„æº free(firmware_data); close(drm_fd); return 0; } æ€»ä¹‹ï¼ŒBlob æ˜¯ä¸€ç§ç”¨äºå­˜å‚¨è‡ªå®šä¹‰æ•°æ®çš„ç‰¹æ®Šå±æ€§ï¼Œå…è®¸ç”¨æˆ·ç©ºé—´åº”ç”¨ç¨‹åºä¸å†…æ ¸äº¤æ¢éæ ‡å‡†åŒ–çš„ä¿¡æ¯ã€‚å®ƒåœ¨ DRM ä¸­çš„åº”ç”¨èŒƒå›´å¾ˆå¹¿ï¼Œä¾‹å¦‚æ˜¾ç¤ºæ¨¡å¼ã€é¢œè‰²æ ¡å‡†å’Œ Gamma è¡¨ç­‰ã€‚ 4.4 drmModeSetCrtcä¸drmModePageFlip åœ¨ Linux å›¾å½¢æ˜¾ç¤ºæ¡†æ¶ä¸­ï¼ŒdrmModeSetCrtcã€drmModePageFlip å’Œ drmModeSetPlane æ˜¯ä¸‰ä¸ªé‡è¦çš„å‡½æ•°ï¼Œå®ƒä»¬ç”¨äºæ›´æ–°æ˜¾ç¤ºå†…å®¹ï¼Œä½†åœ¨åŠŸèƒ½å’Œæ‰§è¡Œæ—¶æœºä¸Šå­˜åœ¨ä¸€äº›åŒºåˆ«ï¼š drmModeSetCrtcï¼š drmModeSetCrtc æ˜¯æœ€æ ¸å¿ƒçš„å‡½æ•°ä¹‹ä¸€ï¼Œè´Ÿè´£å»ºç«‹ä»å¸§ç¼“å­˜åˆ°æ˜¾ç¤ºå™¨è¿æ¥å™¨çš„å…³è”ã€‚ å®ƒæ‰§è¡Œä¸¤ä¸ªä¸»è¦ä»»åŠ¡ï¼š æ›´æ–°ç”»é¢ï¼šåˆ‡æ¢æ˜¾ç¤ºç¼“å†²åŒºï¼Œåˆæˆå¤šå›¾å±‚ï¼Œè®¾ç½®æ¯ä¸ªå›¾å±‚çš„æ˜¾ç¤ºä½ç½®ã€‚ è®¾ç½®æ˜¾ç¤ºå‚æ•°ï¼šåŒ…æ‹¬åˆ†è¾¨ç‡ã€åˆ·æ–°ç‡ã€ç”µæºçŠ¶æ€ï¼ˆä¼‘çœ å”¤é†’ï¼‰ç­‰ã€‚ drmModePageFlipï¼š drmModePageFlip ä¹Ÿç”¨äºæ›´æ–°æ˜¾ç¤ºå†…å®¹ï¼Œä½†ä¸ drmModeSetCrtc æœ€å¤§çš„åŒºåˆ«åœ¨äºï¼š å®ƒåªä¼šåœ¨ VSYNC åˆ°æ¥åæ‰çœŸæ­£æ‰§è¡Œå¸§ç¼“å†²åŒºåˆ‡æ¢åŠ¨ä½œã€‚ ç­‰å¾… VSYNC å¯ä»¥é¿å…ç”»é¢æ’•è£‚ï¼ˆtearingï¼‰ç°è±¡ã€‚ é€‚ç”¨äºéœ€è¦åŒæ­¥åˆ·æ–°çš„åœºæ™¯ï¼Œå¦‚è§†é¢‘æ’­æ”¾ã€æ¸¸æˆç­‰ã€‚ drmModeSetPlaneï¼š drmModeSetPlane ç”¨äºè®¾ç½®ç¡¬ä»¶å¹³é¢ï¼ˆoverlay planeï¼‰çš„å‚æ•°ã€‚ ç¡¬ä»¶å¹³é¢æ˜¯ä¸€ç§ç‰¹æ®Šçš„å›¾å±‚ï¼Œå¯ä»¥åœ¨å…¶ä»–å›¾å±‚ä¹‹ä¸Šå åŠ æ˜¾ç¤ºã€‚ é€‚ç”¨äºå®ç°è§†é¢‘å åŠ ã€OSDï¼ˆOn-Screen Displayï¼‰ç­‰åŠŸèƒ½ã€‚ æ€»ç»“ï¼š drmModeSetCrtc è´Ÿè´£æ•´ä½“æ˜¾ç¤ºè®¾ç½®ã€‚ drmModePageFlip ç­‰å¾… VSYNC ååˆ‡æ¢å¸§ç¼“å†²åŒºã€‚ drmModeSetPlane æ§åˆ¶ç¡¬ä»¶å¹³é¢çš„æ˜¾ç¤ºã€‚ 5 IOCTL DRM_IOCTL_VERSION å®ƒé€šè¿‡ä¸»è¦ã€æ¬¡è¦å’Œè¡¥ä¸ç¨‹åºçº§åˆ«çš„ä¸‰å…ƒç»„æ¥æ ‡è¯†é©±åŠ¨ç¨‹åºç‰ˆæœ¬ã€‚ è¿™äº›ä¿¡æ¯åœ¨åˆå§‹åŒ–æ—¶è¢«æ‰“å°åˆ°å†…æ ¸æ—¥å¿—ä¸­ é€šè¿‡ DRM_IOCTL_VERSION ioctl ä¼ é€’åˆ°ç”¨æˆ·ç©ºé—´ã€‚ é©±åŠ¨ç¨‹åºçš„æè¿°æ˜¯ä¸€ä¸ªçº¯ç²¹çš„ä¿¡æ¯å­—ç¬¦ä¸²ï¼Œé€šè¿‡ DRM_IOCTL_VERSION ioctl ä¼ é€’ç»™ç”¨æˆ·ç©ºé—´ï¼Œä½†åœ¨å†…æ ¸ä¸­æ²¡æœ‰å…¶ä»–ç”¨é€”ã€‚é©±åŠ¨ç¨‹åºçš„æ—¥æœŸä»¥ YYYYMMDD æ ¼å¼è¡¨ç¤ºï¼Œç”¨äºæ ‡è¯†é©±åŠ¨ç¨‹åºçš„æœ€æ–°ä¿®æ”¹æ—¥æœŸã€‚ç”±äºå¤§å¤šæ•°é©±åŠ¨ç¨‹åºæœªèƒ½æ›´æ–°å®ƒï¼Œå…¶å€¼åŸºæœ¬ä¸Šæ˜¯æ— ç”¨çš„ã€‚ DRM_IOCTL_GET_UNIQUE å®ƒå…è®¸ç”¨æˆ·ç©ºé—´ç¨‹åºæŸ¥è¯¢ä¸ DRM è®¾å¤‡ç›¸å…³çš„å”¯ä¸€æ ‡è¯†ç¬¦ã€‚è¿™ä¸ªæ¥å£é€šå¸¸ç”¨äºè·å–è®¾å¤‡çš„ UUID æˆ–å…¶ä»–å”¯ä¸€æ ‡è¯†ï¼Œä»¥ä¾¿åœ¨å¤šä¸ªè®¾å¤‡ä¹‹é—´è¿›è¡ŒåŒºåˆ†ã€‚ DRM_IOCTL_SET_UNIQUE å®ƒå…è®¸ç”¨æˆ·ç©ºé—´ç¨‹åºè®¾ç½® DRM è®¾å¤‡çš„å”¯ä¸€åç§°ã€‚è®©æˆ‘ä»¬æ·±å…¥äº†è§£ä¸€ä¸‹è¿™ä¸ªæ¥å£çš„ä½œç”¨å’Œå®ç°ã€‚ æ¥å£ä½œç”¨ï¼š DRM_IOCTL_SET_UNIQUE å…è®¸ç”¨æˆ·ç©ºé—´ç¨‹åºä½¿ç”¨æŒ‡å®šçš„å­—ç¬¦ä¸²è®¾ç½® DRM è®¾å¤‡çš„å”¯ä¸€åç§°ã€‚ è¿™ä¸ªå”¯ä¸€åç§°é€šå¸¸ç”¨äºæ ‡è¯†ä¸åŒçš„ DRM è®¾å¤‡ï¼Œä»¥ä¾¿åœ¨å¤šä¸ªè®¾å¤‡ä¹‹é—´è¿›è¡ŒåŒºåˆ†ã€‚ å®ç°ç»†èŠ‚ï¼š åœ¨ Linux å†…æ ¸ä¸­ï¼ŒDRM_IOCTL_SET_UNIQUE çš„å®ç°å¯èƒ½å› ä¸åŒçš„ DRM é©±åŠ¨è€Œå¼‚ã€‚ ç”¨æˆ·ç©ºé—´ç¨‹åºå¯ä»¥é€šè¿‡è°ƒç”¨ç›¸åº”çš„ ioctl å‡½æ•°æ¥è®¾ç½®è®¾å¤‡çš„å”¯ä¸€åç§°ã€‚ DRM_IOCTL_IRQ_BUSID å®ƒç”¨äºåŸºäºæ€»çº¿ IDï¼ˆbusidï¼‰ä¸º PCI è®¾å¤‡è·å–ä¸­æ–­è¯·æ±‚ï¼ˆIRQï¼‰ã€‚åœ¨è¿‡å»ï¼Œè¿™ä¸ªæ¥å£æ˜¯é€šç”¨çš„ DRM æ¨¡å—å‡½æ•°ï¼Œå¯ä»¥ä¸ºå¤šä¸ªä¸åŒçš„è®¾å¤‡æä¾›æœåŠ¡ã€‚ç„¶è€Œï¼Œç°åœ¨å®ƒå¯èƒ½éœ€è¦æ›´æ”¹ï¼Œä»¥ä»…è¿”å›ä¸ç‰¹å®š drm_device_t ç›¸å…³è”çš„è®¾å¤‡çš„ä¸­æ–­å·ã€‚ DRM_IOCTL_GET_CLIENT å®ƒç”¨äºæŸ¥è¯¢ DRM è®¾å¤‡çš„å®¢æˆ·ç«¯ä¿¡æ¯ã€‚è®©æˆ‘ä»¬æ¥è¯¦ç»†äº†è§£ä¸€ä¸‹è¿™ä¸ªæ¥å£çš„ä½œç”¨å’Œå®ç°ã€‚ æ¥å£ä½œç”¨ï¼š DRM_IOCTL_GET_CLIENT å…è®¸ç”¨æˆ·ç©ºé—´ç¨‹åºæŸ¥è¯¢ä¸ DRM è®¾å¤‡ç›¸å…³çš„å®¢æˆ·ç«¯ä¿¡æ¯ã€‚ è¿™ä¸ªæ¥å£é€šå¸¸ç”¨äºè·å–å®¢æˆ·ç«¯çš„å”¯ä¸€æ ‡è¯†ç¬¦æˆ–å…¶ä»–ç›¸å…³ä¿¡æ¯ï¼Œä»¥ä¾¿åœ¨å¤šä¸ªå®¢æˆ·ç«¯ä¹‹é—´è¿›è¡ŒåŒºåˆ†ã€‚ å®ç°ç»†èŠ‚ï¼š åœ¨ Linux å†…æ ¸ä¸­ï¼ŒDRM_IOCTL_GET_CLIENT çš„å®ç°å¯èƒ½å› ä¸åŒçš„ DRM é©±åŠ¨è€Œå¼‚ã€‚ é€šè¿‡è°ƒç”¨ drmGetBusid() å‡½æ•°ï¼Œç”¨æˆ·ç©ºé—´ç¨‹åºå¯ä»¥è·å–ä¸æ€»çº¿ IDï¼ˆbusidï¼‰ç›¸å…³çš„å®¢æˆ·ç«¯ä¿¡æ¯ã€‚ è¯·æ³¨æ„ï¼Œè¿™ä¸ªæ¥å£çš„å…·ä½“å®ç°å¯èƒ½å› ä¸åŒçš„é©±åŠ¨è€Œæœ‰æ‰€ä¸åŒï¼Œå› æ­¤æ‚¨å¯ä»¥æŸ¥é˜…ç‰¹å®šé©±åŠ¨çš„æ–‡æ¡£æˆ–æºä»£ç ä»¥è·å–æ›´è¯¦ç»†çš„ä¿¡æ¯ã€‚ DRM_IOCTL_GET_STATS å®ƒå…è®¸ç”¨æˆ·ç©ºé—´ç¨‹åºæŸ¥è¯¢ä¸ DRM è®¾å¤‡ç›¸å…³çš„ç»Ÿè®¡ä¿¡æ¯ã€‚è®©æˆ‘ä»¬æ¥è¯¦ç»†äº†è§£ä¸€ä¸‹è¿™ä¸ªæ¥å£çš„ä½œç”¨å’Œå®ç°ã€‚ æ¥å£ä½œç”¨ï¼š DRM_IOCTL_GET_STATS å…è®¸ç”¨æˆ·ç©ºé—´ç¨‹åºè·å–ä¸ DRM è®¾å¤‡ç›¸å…³çš„ç»Ÿè®¡æ•°æ®ã€‚ è¿™ä¸ªæ¥å£é€šå¸¸ç”¨äºæŸ¥è¯¢è®¾å¤‡çš„æ€§èƒ½æŒ‡æ ‡ã€èµ„æºä½¿ç”¨æƒ…å†µã€é”™è¯¯ç»Ÿè®¡ç­‰ä¿¡æ¯ã€‚ å®ç°ç»†èŠ‚ï¼š åœ¨ Linux å†…æ ¸ä¸­ï¼ŒDRM_IOCTL_GET_STATS çš„å®ç°å¯èƒ½å› ä¸åŒçš„ DRM é©±åŠ¨è€Œå¼‚ã€‚ ç”¨æˆ·ç©ºé—´ç¨‹åºå¯ä»¥é€šè¿‡è°ƒç”¨ç›¸åº”çš„ ioctl å‡½æ•°æ¥è·å–ç»Ÿè®¡æ•°æ®ã€‚ è¯·æ³¨æ„ï¼Œè¿™ä¸ªæ¥å£çš„å…·ä½“å®ç°å¯èƒ½å› ä¸åŒçš„é©±åŠ¨è€Œæœ‰æ‰€ä¸åŒï¼Œå› æ­¤æ‚¨å¯ä»¥æŸ¥é˜…ç‰¹å®šé©±åŠ¨çš„æ–‡æ¡£æˆ–æºä»£ç ä»¥è·å–æ›´è¯¦ç»†çš„ä¿¡æ¯ã€‚ DRM_IOCTL_GET_CAP å®ƒå…è®¸ç”¨æˆ·ç©ºé—´ç¨‹åºæŸ¥è¯¢ä¸ DRM è®¾å¤‡ç›¸å…³çš„èƒ½åŠ›ä¿¡æ¯ã€‚è®©æˆ‘ä»¬æ¥è¯¦ç»†äº†è§£ä¸€ä¸‹è¿™ä¸ªæ¥å£çš„ä½œç”¨å’Œå®ç°ã€‚ æ¥å£ä½œç”¨ï¼š DRM_IOCTL_GET_CAP å…è®¸ç”¨æˆ·ç©ºé—´ç¨‹åºè·å–ä¸ DRM è®¾å¤‡ç›¸å…³çš„èƒ½åŠ›æ•°æ®ã€‚ è¿™ä¸ªæ¥å£é€šå¸¸ç”¨äºæŸ¥è¯¢è®¾å¤‡æ”¯æŒçš„åŠŸèƒ½ã€ç‰¹æ€§å’Œé™åˆ¶ã€‚ å®ç°ç»†èŠ‚ï¼š åœ¨ Linux å†…æ ¸ä¸­ï¼ŒDRM_IOCTL_GET_CAP çš„å®ç°å¯èƒ½å› ä¸åŒçš„ DRM é©±åŠ¨è€Œå¼‚ã€‚ ç”¨æˆ·ç©ºé—´ç¨‹åºå¯ä»¥é€šè¿‡è°ƒç”¨ç›¸åº”çš„ ioctl å‡½æ•°æ¥è·å–èƒ½åŠ›æ•°æ®ã€‚ è¯·æ³¨æ„ï¼Œè¿™ä¸ªæ¥å£çš„å…·ä½“å®ç°å¯èƒ½å› ä¸åŒçš„é©±åŠ¨è€Œæœ‰æ‰€ä¸åŒï¼Œå› æ­¤æ‚¨å¯ä»¥æŸ¥é˜…ç‰¹å®šé©±åŠ¨çš„æ–‡æ¡£æˆ–æºä»£ç ä»¥è·å–æ›´è¯¦ç»†çš„ä¿¡æ¯ã€‚ DRM_IOCTL_SET_CLIENT_CAP å®ƒå…è®¸ç”¨æˆ·ç©ºé—´ç¨‹åºè®¾ç½®ä¸ DRM è®¾å¤‡ç›¸å…³çš„èƒ½åŠ›ä¿¡æ¯ã€‚è®©æˆ‘ä»¬æ¥è¯¦ç»†äº†è§£ä¸€ä¸‹è¿™ä¸ªæ¥å£çš„ä½œç”¨å’Œå®ç°ã€‚ æ¥å£ä½œç”¨ï¼š DRM_IOCTL_SET_CLIENT_CAP å…è®¸ç”¨æˆ·ç©ºé—´ç¨‹åºè®¾ç½®ä¸ DRM è®¾å¤‡ç›¸å…³çš„èƒ½åŠ›æ•°æ®ã€‚ è¿™ä¸ªæ¥å£é€šå¸¸ç”¨äºæŸ¥è¯¢è®¾å¤‡æ”¯æŒçš„åŠŸèƒ½ã€ç‰¹æ€§å’Œé™åˆ¶ã€‚ å®ç°ç»†èŠ‚ï¼š åœ¨ Linux å†…æ ¸ä¸­ï¼ŒDRM_IOCTL_SET_CLIENT_CAP çš„å®ç°å¯èƒ½å› ä¸åŒçš„ DRM é©±åŠ¨è€Œå¼‚ã€‚ ç”¨æˆ·ç©ºé—´ç¨‹åºå¯ä»¥é€šè¿‡è°ƒç”¨ç›¸åº”çš„ ioctl å‡½æ•°æ¥è®¾ç½®èƒ½åŠ›æ•°æ®ã€‚ è¯·æ³¨æ„ï¼Œè¿™ä¸ªæ¥å£çš„å…·ä½“å®ç°å¯èƒ½å› ä¸åŒçš„é©±åŠ¨è€Œæœ‰æ‰€ä¸åŒï¼Œå› æ­¤æ‚¨å¯ä»¥æŸ¥é˜…ç‰¹å®šé©±åŠ¨çš„æ–‡æ¡£æˆ–æºä»£ç ä»¥è·å–æ›´è¯¦ç»†çš„ä¿¡æ¯ã€‚ DRM_CLIENT_CAP_ASPECT_RATIO: æ˜¯ä¸€ä¸ªå®¢æˆ·ç«¯èƒ½åŠ›æ ‡å¿—ï¼Œç”¨äºæŒ‡ç¤ºç”¨æˆ·ç©ºé—´åº”ç”¨ç¨‹åºæ˜¯å¦æ”¯æŒå›¾åƒçš„çºµæ¨ªæ¯”ä¿¡æ¯ã€‚å¦‚æœåº”ç”¨ç¨‹åºæ”¯æŒæ­¤æ ‡å¿—ï¼Œå†…æ ¸å°†åœ¨æ¨¡å¼ä¸­ä¼ é€’çºµæ¨ªæ¯”ä¿¡æ¯ã€‚è¿™å¯¹äºæ˜¾ç¤ºå›¾åƒæ—¶ä¿æŒæ­£ç¡®çš„çºµæ¨ªæ¯”éå¸¸é‡è¦ã€‚ å¦‚æœè®¾ç½®ä¸º 1ï¼ŒDRM å†…æ ¸å°†å‘ç”¨æˆ·ç©ºé—´å…¬å¼€åŸå­å±æ€§ã€‚è¿™éšå¼å¯ç”¨äº† DRM_CLIENT_CAP_UNIVERSAL_PLANES å’Œ DRM_CLIENT_CAP_ASPECT_RATIOã€‚å¦‚æœé©±åŠ¨ç¨‹åºä¸æ”¯æŒåŸå­æ¨¡å¼è®¾ç½®ï¼Œå¯ç”¨æ­¤åŠŸèƒ½å°†å¤±è´¥å¹¶è¿”å› -EOPNOTSUPP é”™è¯¯ã€‚è¿™ä¸ªåŠŸèƒ½æ˜¯åœ¨å†…æ ¸ç‰ˆæœ¬ 4.0 ä¸­å¼•å…¥çš„1ã€‚ DRM_IOCTL_WAIT_VBLANK å®ƒå…è®¸ç”¨æˆ·ç©ºé—´ç¨‹åºåœ¨æŒ‡å®šçš„vblankäº‹ä»¶å‘ç”Ÿæ—¶é˜»å¡æˆ–è¯·æ±‚ä¿¡å·ã€‚è®©æˆ‘ä»¬æ¥è¯¦ç»†äº†è§£ä¸€ä¸‹è¿™ä¸ªæ¥å£çš„ä½œç”¨å’Œå®ç°ï¼š æ¥å£ä½œç”¨ï¼š DRM_IOCTL_WAIT_VBLANK å…è®¸ç”¨æˆ·ç©ºé—´ç¨‹åºåœ¨æŒ‡å®šçš„vblankäº‹ä»¶å‘ç”Ÿæ—¶é˜»å¡æˆ–è¯·æ±‚ä¿¡å·ã€‚ è¿™ä¸ªæ¥å£é€šå¸¸ç”¨äºä¸æ˜¾ç¤ºç›¸å…³çš„åŒæ­¥æ“ä½œï¼Œä¾‹å¦‚åœ¨è¿›è¡Œé¡µé¢ç¿»è½¬æ—¶ç­‰å¾…vblankã€‚ å®ç°ç»†èŠ‚ï¼š DRM æ ¸å¿ƒå¤„ç†å¤§éƒ¨åˆ†vblankç®¡ç†é€»è¾‘ï¼ŒåŒ…æ‹¬è¿‡æ»¤æ‰è™šå‡ä¸­æ–­ã€ä¿æŒæ— ç«äº‰çš„ç©ºç™½è®¡æ•°ã€å¤„ç†è®¡æ•°å™¨å›ç»•å’Œé‡ç½®ï¼Œä»¥åŠä¿æŒä½¿ç”¨è®¡æ•°ã€‚ ç”¨æˆ·ç©ºé—´ç¨‹åºå¯ä»¥é€šè¿‡æ‰§è¡Œç›¸åº”çš„ ioctl å‡½æ•°æ¥ä½¿ç”¨è¿™ä¸ªæ¥å£ã€‚ è¿™ä¸ªæœºåˆ¶ç¡®ä¿åªæœ‰ç»è¿‡èº«ä»½éªŒè¯çš„è°ƒç”¨è€…æ‰èƒ½è®¿é—®ç‰¹å®šçš„ DRM åŠŸèƒ½ã€‚ å‚ç›´åŒæ­¥ï¼ˆVSYNCï¼‰ï¼š åœ¨å›¾å½¢æ¸²æŸ“ä¸­ï¼Œå‚ç›´åŒæ­¥æ˜¯ä¸€ç§æŠ€æœ¯ï¼Œç”¨äºç¡®ä¿å›¾åƒåœ¨æ˜¾ç¤ºå™¨ä¸Šçš„åˆ·æ–°ä¸æ˜¾ç¤ºå™¨çš„å‚ç›´ç©ºç™½æœŸï¼ˆvertical blanking intervalï¼‰åŒæ­¥ã€‚ vblank(å‚ç›´ç©ºç™½æœŸ)æ˜¯æ˜¾ç¤ºå™¨åœ¨ç»˜åˆ¶ä¸€å¸§å›¾åƒåï¼Œå‡†å¤‡ç»˜åˆ¶ä¸‹ä¸€å¸§ä¹‹é—´çš„æ—¶é—´é—´éš”ã€‚ drmWaitVBlank å‡½æ•°ï¼š è¿™ä¸ªå‡½æ•°ç”¨äºç­‰å¾…å‚ç›´åŒæ­¥ä¿¡å·ã€‚ å®ƒæ¥å—ä¸€ä¸ª DRM è®¾å¤‡æ–‡ä»¶æè¿°ç¬¦ï¼ˆfile descriptorï¼‰å’Œä¸€ä¸ªè¡¨ç¤ºæ˜¾ç¤ºè¾“å‡ºçš„ CRTCï¼ˆCathode Ray Tube Controllerï¼‰çš„ IDã€‚ å½“å‚ç›´åŒæ­¥ä¿¡å·åˆ°è¾¾æ—¶ï¼Œå‡½æ•°ä¼šè¿”å›ã€‚ åœ¨æ¸¸æˆå¼€å‘å’Œå›¾å½¢æ¸²æŸ“ä¸­ï¼ŒdrmWaitVBlank å¯ä»¥ç”¨äºç¡®ä¿é¡µé¢ç¿»è½¬ï¼ˆpage flipï¼‰ä¸å‚ç›´åŒæ­¥å¯¹é½ï¼Œä»è€Œé¿å…å±å¹•æ’•è£‚ï¼ˆtearingï¼‰ã€‚ DRM_IOCTL_MODE_GETGAMMA ç”¨äºä» Linux å†…æ ¸æ¨¡å¼è®¾ç½®ï¼ˆKMSï¼‰ ä¸­è·å–ç‰¹å®š CRTCï¼ˆCathode Ray Tube Controllerï¼‰ çš„ ä¼½é©¬æ ¡æ­£ï¼ˆGamma Correctionï¼‰ ä¿¡æ¯. è¯¦æƒ…å¦‚ä¸‹ï¼š ä¼½é©¬æ ¡æ­£æ˜¯ä»€ä¹ˆï¼Ÿ ä¼½é©¬æ ¡æ­£ æ˜¯ä¸€ç§å›¾åƒå¤„ç†æŠ€æœ¯ï¼Œç”¨äºè°ƒæ•´æ˜¾ç¤ºè®¾å¤‡çš„äº®åº¦å’Œå¯¹æ¯”åº¦ã€‚ å®ƒé€šè¿‡æ”¹å˜åƒç´ çš„äº®åº¦å€¼æ¥å®ç°ï¼Œä»¥ä¾¿æ›´å‡†ç¡®åœ°æ˜¾ç¤ºä¸åŒäº®åº¦çº§åˆ«çš„å›¾åƒã€‚ DRM_IOCTL_MODE_GETGAMMA çš„ä½œç”¨ é€šè¿‡è°ƒç”¨ DRM_IOCTL_MODE_GETGAMMAï¼Œåº”ç”¨ç¨‹åºå¯ä»¥è·å–æœ‰å…³ç‰¹å®š CRTC çš„ä¼½é©¬æ ¡æ­£ä¿¡æ¯ã€‚ è¿™äº›ä¿¡æ¯å¯èƒ½åŒ…æ‹¬ä¼½é©¬æ ¡æ­£æ›²çº¿ã€äº®åº¦å’Œå¯¹æ¯”åº¦çš„è°ƒæ•´ç­‰ã€‚ å…¶ä»– DRM IOCTL å‘½ä»¤ é™¤äº† DRM_IOCTL_MODE_GETGAMMAï¼Œè¿˜æœ‰å…¶ä»–ä¸æ˜¾ç¤ºè®¾ç½®ç›¸å…³çš„ IOCTL å‘½ä»¤ï¼Œä¾‹å¦‚ï¼š DRM_IOCTL_MODE_GETCRTCï¼šè·å–æœ‰å…³ç‰¹å®š CRTC çš„ä¿¡æ¯ã€‚ DRM_IOCTL_MODE_SETCRTCï¼šè®¾ç½® CRTC å‚æ•°ã€‚ DRM_IOCTL_MODE_ADDFBï¼šæ·»åŠ æ–°çš„å¸§ç¼“å†²åŒºå¯¹è±¡ã€‚ DRM_IOCTL_MODE_RMFBï¼šç§»é™¤å¸§ç¼“å†²åŒºå¯¹è±¡ã€‚ DRM_IOCTL_MODE_DIRTYFB ç”¨äºå®šä¹‰ä¸€ä¸ªå¸§ç¼“å†²åŒºåŒºåŸŸä¸ºâ€œè„â€ï¼ˆæ•°æ®å·²æ›´æ”¹ï¼Œå› æ­¤éœ€è¦é‡æ–°æ˜¾ç¤ºï¼‰ã€‚è¿™ä¸ª ioctl ä½¿ç”¨äº† drm_mode_fb_dirty_cmd ç»“æ„ï¼Œå…¶ä¸­åŒ…å«ä¸€ä¸ª num_clips å­—æ®µï¼ŒæŒ‡ç¤ºæ›´æ”¹çš„åŒºåŸŸæ•°é‡. å¸§ç¼“å†²åŒºæ˜¯ä»€ä¹ˆï¼Ÿ å¸§ç¼“å†²åŒº æ˜¯ä¸€ä¸ªæŠ½è±¡çš„å†…å­˜å¯¹è±¡ï¼Œç”¨äºå‘ CRTC æ‰«æè¾“å‡ºåƒç´ ã€‚ åº”ç”¨ç¨‹åºé€šè¿‡ DRM_IOCTL_MODE_ADDFBï¼ˆ2ï¼‰ioctl æ˜¾å¼è¯·æ±‚åˆ›å»ºå¸§ç¼“å†²åŒºï¼Œå¹¶æ¥æ”¶ä¸€ä¸ªä¸é€æ˜çš„å¥æŸ„ï¼Œå¯ä»¥ä¼ é€’ç»™ KMS CRTC æ§åˆ¶ã€å¹³é¢é…ç½®å’Œé¡µé¢ç¿»è½¬åŠŸèƒ½ã€‚ å¸§ç¼“å†²åŒºä¾èµ–äºåº•å±‚å†…å­˜ç®¡ç†å™¨è¿›è¡Œä½çº§å†…å­˜æ“ä½œã€‚ DRM_IOCTL_MODE_DIRTYFB çš„ä½œç”¨ é€šè¿‡è°ƒç”¨ DRM_IOCTL_MODE_DIRTYFBï¼Œåº”ç”¨ç¨‹åºå¯ä»¥å°†ç‰¹å®šå¸§ç¼“å†²åŒºåŒºåŸŸæ ‡è®°ä¸ºâ€œè„â€ã€‚ è¿™é€šå¸¸ç”¨äºé€šçŸ¥æ˜¾ç¤ºç³»ç»Ÿéœ€è¦é‡æ–°æ‰«æå’Œæ˜¾ç¤ºæ›´æ”¹çš„åƒç´ æ•°æ®ã€‚ å…¶ä»– DRM IOCTL å‘½ä»¤ é™¤äº† DRM_IOCTL_MODE_DIRTYFBï¼Œè¿˜æœ‰å…¶ä»–ä¸æ˜¾ç¤ºè®¾ç½®ç›¸å…³çš„ IOCTL å‘½ä»¤ï¼Œä¾‹å¦‚ï¼š DRM_IOCTL_MODE_GETCRTCï¼šè·å–æœ‰å…³ç‰¹å®š CRTC çš„ä¿¡æ¯ã€‚ DRM_IOCTL_MODE_SETCRTCï¼šè®¾ç½® CRTC å‚æ•°ã€‚ DRM_IOCTL_MODE_ADDFBï¼šæ·»åŠ æ–°çš„å¸§ç¼“å†²åŒºå¯¹è±¡ã€‚ DRM_IOCTL_MODE_RMFBï¼šç§»é™¤å¸§ç¼“å†²åŒºå¯¹è±¡ã€‚ DRM_IOCTL_MODE_ATOMIC ç”¨äºåœ¨ Linux å†…æ ¸æ¨¡å¼è®¾ç½®ï¼ˆKMSï¼‰ ä¸­æ‰§è¡Œ åŸå­æ“ä½œï¼ˆAtomic Operationï¼‰ã€‚è¯¦æƒ…å¦‚ä¸‹ï¼š KMS æ˜¯ä»€ä¹ˆï¼Ÿ KMSï¼ˆKernel Mode Settingï¼‰ æ˜¯ä¸€ç§å†…æ ¸çº§åˆ«çš„å›¾å½¢æ˜¾ç¤ºè®¾ç½®æœºåˆ¶ï¼Œç”¨äºç®¡ç†æ˜¾ç¤ºè®¾å¤‡çš„æ¨¡å¼å’ŒçŠ¶æ€ã€‚ å®ƒå…è®¸ç”¨æˆ·ç©ºé—´åº”ç”¨ç¨‹åºä¸å†…æ ¸äº¤äº’ï¼Œä»¥é…ç½®æ˜¾ç¤ºè¾“å‡ºã€‚ åŸå­æ“ä½œçš„æ¦‚å¿µ åœ¨å›¾å½¢æ¸²æŸ“ä¸­ï¼ŒåŸå­æ“ä½œ æ˜¯æŒ‡ä¸€ç»„çŠ¶æ€æ›´æ”¹ï¼Œè¦ä¹ˆå…¨éƒ¨æˆåŠŸåº”ç”¨ï¼Œè¦ä¹ˆå…¨éƒ¨å¤±è´¥ï¼Œä¸ä¼šå‡ºç°éƒ¨åˆ†åº”ç”¨çš„æƒ…å†µã€‚ åœ¨ KMS ä¸­ï¼ŒåŸå­æ“ä½œç”¨äºä¸€æ¬¡æ€§æ›´æ–°å¤šä¸ªæ˜¾ç¤ºå¯¹è±¡çš„çŠ¶æ€ï¼Œä¾‹å¦‚ CRTCã€å¹³é¢ã€è¿æ¥å™¨ç­‰ã€‚ DRM_IOCTL_MODE_ATOMIC çš„ä½œç”¨ é€šè¿‡è°ƒç”¨ DRM_IOCTL_MODE_ATOMICï¼Œåº”ç”¨ç¨‹åºå¯ä»¥æäº¤ä¸€ç»„åŸå­æ“ä½œï¼Œä»¥æ›´æ–°æ˜¾ç¤ºç®¡é“çš„çŠ¶æ€ã€‚ è¿™äº›æ“ä½œå¯ä»¥åŒ…æ‹¬æ›´æ”¹ CRTC æ¨¡å¼ã€å¹³é¢é…ç½®ã€è¿æ¥å™¨çŠ¶æ€ç­‰ã€‚ å…¶ä»– DRM IOCTL å‘½ä»¤ é™¤äº† DRM_IOCTL_MODE_ATOMICï¼Œè¿˜æœ‰å…¶ä»–ä¸æ˜¾ç¤ºè®¾ç½®ç›¸å…³çš„ IOCTL å‘½ä»¤ï¼Œä¾‹å¦‚ï¼š DRM_IOCTL_MODE_GETCRTCï¼šè·å–æœ‰å…³ç‰¹å®š CRTC çš„ä¿¡æ¯ã€‚ DRM_IOCTL_MODE_SETCRTCï¼šè®¾ç½® CRTC å‚æ•°ã€‚ DRM_IOCTL_MODE_ADDFBï¼šæ·»åŠ æ–°çš„å¸§ç¼“å†²åŒºå¯¹è±¡ã€‚ DRM_IOCTL_MODE_RMFBï¼šç§»é™¤å¸§ç¼“å†²åŒºå¯¹è±¡ã€‚ DRM_IOCTL_CRTC_GET_SEQUENCE ç”¨äºä» Linux å†…æ ¸æ¨¡å¼è®¾ç½®ï¼ˆKMSï¼‰ ä¸­è·å–ç‰¹å®š CRTCï¼ˆCathode Ray Tube Controllerï¼‰ çš„ å¸§åºåˆ—ï¼ˆFrame Sequenceï¼‰ ä¿¡æ¯. è¯¦æƒ…å¦‚ä¸‹ï¼š CRTC æ˜¯ä»€ä¹ˆï¼Ÿ CRTC æ˜¯æ˜¾ç¤ºæ§åˆ¶å™¨ï¼Œè´Ÿè´£å°†å›¾å½¢æ•°æ®å‘é€åˆ°æ˜¾ç¤ºè®¾å¤‡ï¼ˆä¾‹å¦‚æ˜¾ç¤ºå™¨æˆ–ç”µè§†ï¼‰ã€‚ å®ƒç®¡ç†åƒç´ æ—¶é’Ÿã€æ‰«æçº¿å’Œå¸§ç¼“å†²åŒºçš„åˆ·æ–°ã€‚ å¸§åºåˆ—æ˜¯ä»€ä¹ˆï¼Ÿ åœ¨å›¾å½¢æ¸²æŸ“ä¸­ï¼Œå¸§åºåˆ— æ˜¯æŒ‡æ˜¾ç¤ºè®¾å¤‡åˆ·æ–°å›¾åƒçš„é¡ºåºã€‚ é€šè¿‡è°ƒç”¨ DRM_IOCTL_CRTC_GET_SEQUENCEï¼Œåº”ç”¨ç¨‹åºå¯ä»¥è·å–æœ‰å…³ç‰¹å®š CRTC çš„å¸§åºåˆ—ä¿¡æ¯ï¼Œä¾‹å¦‚å½“å‰å¸§æ•°ã€å‚ç›´åŒæ­¥ä¿¡å·ç­‰ã€‚ å…¶ä»– DRM IOCTL å‘½ä»¤ é™¤äº† DRM_IOCTL_CRTC_GET_SEQUENCEï¼Œè¿˜æœ‰å…¶ä»–ä¸æ˜¾ç¤ºè®¾ç½®ç›¸å…³çš„ IOCTL å‘½ä»¤ï¼Œä¾‹å¦‚ï¼š DRM_IOCTL_MODE_GETCRTCï¼šè·å–æœ‰å…³ç‰¹å®š CRTC çš„ä¿¡æ¯ã€‚ DRM_IOCTL_MODE_SETCRTCï¼šè®¾ç½® CRTC å‚æ•°ã€‚ DRM_IOCTL_MODE_ADDFBï¼šæ·»åŠ æ–°çš„å¸§ç¼“å†²åŒºå¯¹è±¡ã€‚ DRM_IOCTL_MODE_RMFBï¼šç§»é™¤å¸§ç¼“å†²åŒºå¯¹è±¡ã€‚ DRM_IOCTL_CRTC_QUEUE_SEQUENCE ç”¨äºåœ¨ Linux å†…æ ¸æ¨¡å¼è®¾ç½®ï¼ˆKMSï¼‰ ä¸­å°†ç‰¹å®š CRTCï¼ˆCathode Ray Tube Controllerï¼‰ çš„å¸§åºåˆ—ä¿¡æ¯æ·»åŠ åˆ°é˜Ÿåˆ—ä¸­. ä»¥ä¸‹æ˜¯å…³äº DRM_IOCTL_CRTC_QUEUE_SEQUENCE çš„ä¸€äº›è¦ç‚¹ï¼š CRTC æ˜¯ä»€ä¹ˆï¼Ÿ CRTC æ˜¯æ˜¾ç¤ºæ§åˆ¶å™¨ï¼Œè´Ÿè´£å°†å›¾å½¢æ•°æ®å‘é€åˆ°æ˜¾ç¤ºè®¾å¤‡ï¼ˆä¾‹å¦‚æ˜¾ç¤ºå™¨æˆ–ç”µè§†ï¼‰ã€‚ å®ƒç®¡ç†åƒç´ æ—¶é’Ÿã€æ‰«æçº¿å’Œå¸§ç¼“å†²åŒºçš„åˆ·æ–°ã€‚ å¸§åºåˆ—æ˜¯ä»€ä¹ˆï¼Ÿ åœ¨å›¾å½¢æ¸²æŸ“ä¸­ï¼Œå¸§åºåˆ— æ˜¯æŒ‡æ˜¾ç¤ºè®¾å¤‡åˆ·æ–°å›¾åƒçš„é¡ºåºã€‚ é€šè¿‡è°ƒç”¨ DRM_IOCTL_CRTC_QUEUE_SEQUENCEï¼Œåº”ç”¨ç¨‹åºå¯ä»¥å°†ç‰¹å®š CRTC çš„å¸§åºåˆ—ä¿¡æ¯æ·»åŠ åˆ°é˜Ÿåˆ—ä¸­ã€‚ å…¶ä»– DRM IOCTL å‘½ä»¤ é™¤äº† DRM_IOCTL_CRTC_QUEUE_SEQUENCEï¼Œè¿˜æœ‰å…¶ä»–ä¸æ˜¾ç¤ºè®¾ç½®ç›¸å…³çš„ IOCTL å‘½ä»¤ï¼Œä¾‹å¦‚ï¼š DRM_IOCTL_MODE_GETCRTCï¼šè·å–æœ‰å…³ç‰¹å®š CRTC çš„ä¿¡æ¯ã€‚ DRM_IOCTL_MODE_SETCRTCï¼šè®¾ç½® CRTC å‚æ•°ã€‚ DRM_IOCTL_MODE_ADDFBï¼šæ·»åŠ æ–°çš„å¸§ç¼“å†²åŒºå¯¹è±¡ã€‚ DRM_IOCTL_MODE_RMFBï¼šç§»é™¤å¸§ç¼“å†²åŒºå¯¹è±¡ã€‚ Magic &amp; Master DRM_IOCTL_GET_MAGIC æ˜¯ä¸€å¯¹ IOCTLï¼ˆInput/Output Controlï¼‰å‘½ä»¤ã€‚è¯¦æƒ…å¦‚ä¸‹ï¼š é­”æ•°/å¹»æ•°å­—ï¼ˆMagic Numberï¼‰çš„ä½œç”¨ åœ¨å›¾å½¢è®¾å¤‡é©±åŠ¨ä¸­ï¼ŒDRM_IOCTL_GET_MAGIC ç”¨äºè®¾ç½®é­”æ•°/å¹»æ•°å­—ï¼Œä»¥è¿›è¡Œ GEM ioctl æƒé™æ£€æŸ¥ã€‚ é­”æ•°æ˜¯ä¸€ä¸ª32ä½çš„æ ‡è¯†ç¬¦ï¼Œç”¨äºéªŒè¯å¯¹å›¾å½¢èµ„æºçš„è®¿é—®æƒé™ã€‚ å…·ä½“æ“ä½œ DRM_IOCTL_GET_MAGIC å‡½æ•°ä¼šè¿”å›ä¸€ä¸ª32ä½çš„é­”æ•°ï¼Œç„¶åå°†è¯¥é­”æ•°ä¼ é€’ç»™ DRM-Masterã€‚ DRM-Master ä½¿ç”¨æ­¤é­”æ•°é€šè¿‡ DRM_IOCTL_AUTH_MAGIC ç»™å‘èµ·é‰´æƒçš„é DRM-Master åº”ç”¨ç¨‹åºæˆæƒã€‚ DRM_IOCTL_AUTH_MAGIC å®ƒç”¨äºå¯¹é DRM ä¸»ç”¨æˆ·ç©ºé—´ç¨‹åºè¿›è¡Œèº«ä»½éªŒè¯ã€‚è®©æˆ‘ä»¬è¯¦ç»†äº†è§£ä¸€ä¸‹è¿™ä¸ªæ¥å£çš„ä½œç”¨å’Œå®ç°ï¼š æ¥å£ä½œç”¨ï¼š DRM_IOCTL_AUTH_MAGIC ç”¨äºå¯¹é DRM ä¸»ç”¨æˆ·ç©ºé—´ç¨‹åºè¿›è¡Œèº«ä»½éªŒè¯ã€‚ å…·ä½“æµç¨‹å¦‚ä¸‹ï¼š é DRM ä¸»ç”¨æˆ·ç©ºé—´ç¨‹åºé€šè¿‡æ‰§è¡Œ DRM_IOCTL_GET_MAGIC ioctl ä» DRM è®¾å¤‡è·å–ä¸€ä¸ªå”¯ä¸€çš„ä»¤ç‰Œï¼ˆ32 ä½é­”æ•°ï¼‰ã€‚ ç„¶åï¼Œç”¨æˆ·ç©ºé—´ç¨‹åºå°†æ­¤ä»¤ç‰Œä¼ é€’ç»™ DRM ä¸»ï¼ˆä¾‹å¦‚é€šè¿‡ IPC æˆ– X å®¢æˆ·ç«¯ä¸­çš„ DRI2Authenticate è¯·æ±‚ï¼‰ã€‚ DRM ä¸»è¿›ç¨‹éšåä½¿ç”¨ DRM_IOCTL_AUTH_MAGIC ioctl å°†ä»¤ç‰Œå‘é€å› DRM è®¾å¤‡ã€‚ è®¾å¤‡æ ¹æ®æ¥æ”¶åˆ°çš„ä»¤ç‰Œï¼Œæˆäºˆå‘èµ·èº«ä»½éªŒè¯çš„é DRM ä¸»åº”ç”¨ç‰¹æ®Šæƒé™ã€‚ å®ç°ç»†èŠ‚ï¼š èº«ä»½éªŒè¯ä»¤ç‰Œå…è®¸é DRM ä¸»è¿›ç¨‹æ‰§è¡Œç‰¹å®šçš„ç‰¹æƒæ“ä½œã€‚ é€šè¿‡å°†ä»¤ç‰Œä¸ç›¸åº”çš„æ–‡ä»¶æè¿°ç¬¦ï¼ˆfdï¼‰å…³è”ï¼Œè®¾å¤‡æˆæƒåº”ç”¨è®¿é—®ç‰¹å®šèµ„æºæˆ–æ‰§è¡Œå—é™æ“ä½œã€‚ è¿™ç§æœºåˆ¶ç¡®ä¿åªæœ‰ç»è¿‡èº«ä»½éªŒè¯çš„è°ƒç”¨è€…æ‰èƒ½è®¿é—®ç‰¹å®šçš„ DRM åŠŸèƒ½ã€‚ DRM_IOCTL_SET_MASTER å®ƒå…è®¸ç”¨æˆ·ç©ºé—´ç¨‹åºæˆä¸ºå”¯ä¸€çš„ DRM ä¸»æ˜¾ç¤ºç®¡ç†ç¨‹åºã€‚æ‰§è¡Œæ­¤ ioctl åï¼Œè¯¥ç¨‹åºè·å¾—äº†ç‹¬å çš„æƒé™ï¼Œç”¨äºç®¡ç†ä¸æ˜¾ç¤ºç›¸å…³çš„æ“ä½œã€‚ç›¸åï¼ŒDRM_IOCTL_DROP_MASTER ioctl å¯ç”¨äºæ”¾å¼ƒ DRM ä¸»èº«ä»½ã€‚é€šå¸¸æƒ…å†µä¸‹ï¼ŒX æœåŠ¡å™¨ï¼ˆXorgï¼‰å……å½“ DRM ä¸»ã€‚ å…¶ä»–é DRM ä¸»ç”¨æˆ·ç©ºé—´ç¨‹åºå¯ä»¥é€šè¿‡ DRM-Auth è¿›è¡Œèº«ä»½éªŒè¯ã€‚å…·ä½“è¿‡ç¨‹å¦‚ä¸‹ï¼š æ‰§è¡Œ DRM_IOCTL_GET_MAGIC ioctlï¼Œä» DRM è®¾å¤‡è·å–ä¸€ä¸ªå”¯ä¸€çš„ä»¤ç‰Œï¼ˆé­”æ•°ï¼‰ã€‚ å°†æ­¤ä»¤ç‰Œä¼ é€’ç»™ DRM ä¸»ï¼ˆä¾‹å¦‚é€šè¿‡ IPC æˆ– X å®¢æˆ·ç«¯ä¸­çš„ DRI2Authenticate è¯·æ±‚ï¼‰ã€‚ DRM ä¸»è¿›ç¨‹éšåä½¿ç”¨ DRM_IOCTL_AUTH_MAGIC ioctl å°†ä»¤ç‰Œå‘é€å› DRM è®¾å¤‡ã€‚ åŸºäºæ¥æ”¶åˆ°çš„ä»¤ç‰Œï¼Œè®¾å¤‡æˆäºˆå‘èµ·èº«ä»½éªŒè¯çš„é DRM ä¸»åº”ç”¨ç‰¹æ®Šæƒé™ã€‚ è¿™ä¸ªèº«ä»½éªŒè¯ä»¤ç‰Œå…è®¸é DRM ä¸»è¿›ç¨‹æ‰§è¡Œç‰¹å®šçš„ç‰¹æƒæ“ä½œã€‚é€šè¿‡å°†ä»¤ç‰Œä¸ç›¸åº”çš„æ–‡ä»¶æè¿°ç¬¦ï¼ˆfdï¼‰å…³è”ï¼Œè®¾å¤‡æˆæƒåº”ç”¨è®¿é—®ç‰¹å®šèµ„æºæˆ–æ‰§è¡Œå—é™æ“ä½œã€‚è¿™ç§æœºåˆ¶ç¡®ä¿åªæœ‰ç»è¿‡èº«ä»½éªŒè¯çš„è°ƒç”¨è€…æ‰èƒ½è®¿é—®ç‰¹å®šçš„ DRM åŠŸèƒ½ã€‚ DRM_IOCTL_DROP_MASTER å®ƒå…è®¸ç”¨æˆ·ç©ºé—´ç¨‹åºæ”¾å¼ƒ DRM ä¸»èº«ä»½ã€‚è®©æˆ‘ä»¬è¯¦ç»†äº†è§£ä¸€ä¸‹è¿™ä¸ªæ¥å£çš„ä½œç”¨å’Œå®ç°ï¼š æ¥å£ä½œç”¨ï¼š DRM_IOCTL_DROP_MASTER å…è®¸ç”¨æˆ·ç©ºé—´ç¨‹åºæ”¾å¼ƒ DRM ä¸»èº«ä»½ã€‚ å½“ç¨‹åºæ‰§è¡Œæ­¤ ioctl æ—¶ï¼Œå®ƒä¼šå¤±å»ç‹¬å ç®¡ç†æ˜¾ç¤ºç›¸å…³æ“ä½œçš„ç‰¹æƒã€‚ ç›¸åï¼ŒDRM_IOCTL_SET_MASTER ioctl å¯ç”¨äºæˆä¸º DRM ä¸»ã€‚ å®ç°ç»†èŠ‚ï¼š é€šè¿‡æ‰§è¡Œ DRM_IOCTL_DROP_MASTERï¼Œç”¨æˆ·ç©ºé—´ç¨‹åºå¯ä»¥æ”¾å¼ƒ DRM ä¸»èº«ä»½ã€‚ è¿™åœ¨éœ€è¦åˆ‡æ¢ DRM ä¸»æ—¶å¾ˆæœ‰ç”¨ï¼Œä¾‹å¦‚åœ¨å…³é—­/æ‰“å¼€ä¸»è®¾å¤‡èŠ‚ç‚¹æ—¶ã€‚ é€šå¸¸æƒ…å†µä¸‹ï¼ŒX æœåŠ¡å™¨ï¼ˆXorgï¼‰å……å½“ DRM ä¸»ã€‚ GEM DRM_IOCTL_GEM_CLOSE å®ƒç”¨äºå…³é—­ GEM ç¼“å†²åŒºï¼ˆGraphics Execution Managerï¼‰ã€‚è®©æˆ‘ä»¬è¯¦ç»†äº†è§£ä¸€ä¸‹è¿™ä¸ªæ¥å£çš„ä½œç”¨å’Œå®ç°ï¼š æ¥å£ä½œç”¨ï¼š DRM_IOCTL_GEM_CLOSE ç”¨äºå…³é—­ GEM ç¼“å†²åŒºã€‚ åœ¨æ‰§è¡Œæ­¤ ioctl åï¼ŒGEM ç¼“å†²åŒºçš„å¥æŸ„å°†ä¸å†å¯ç”¨äºå½“å‰è¿›ç¨‹ï¼Œå¹¶ä¸”å¯èƒ½è¢« GEM API é‡æ–°ç”¨äºæ–°çš„ GEM å¯¹è±¡ã€‚ å®ç°ç»†èŠ‚ï¼š ç”¨æˆ·ç©ºé—´ç¨‹åºå¯ä»¥é€šè¿‡æ‰§è¡Œ DRM_IOCTL_GEM_CLOSE æ¥å…³é—­ GEM ç¼“å†²åŒºã€‚ è¿™åœ¨é‡Šæ”¾èµ„æºæˆ–ç®¡ç†å†…å­˜æ—¶éå¸¸æœ‰ç”¨ã€‚ è¯·æ³¨æ„ï¼ŒGEM ç¼“å†²åŒºçš„å…³é—­ä¸ä¼šç«‹å³é‡Šæ”¾å†…å­˜ï¼Œè€Œæ˜¯å°†å…¶æ ‡è®°ä¸ºä¸å†ä½¿ç”¨ï¼Œä»¥ä¾¿ç¨åè¿›è¡Œå›æ”¶ã€‚ DRM_IOCTL_GEM_FLINK å®ƒç”¨äºä¸º GEM ç¼“å†²åŒºï¼ˆGraphics Execution Managerï¼‰åˆ›å»ºä¸€ä¸ªåç§°ã€‚è®©æˆ‘ä»¬è¯¦ç»†äº†è§£ä¸€ä¸‹è¿™ä¸ªæ¥å£çš„ä½œç”¨å’Œå®ç°ï¼š æ¥å£ä½œç”¨ï¼š DRM_IOCTL_GEM_FLINK ç”¨äºä¸º GEM ç¼“å†²åŒºåˆ›å»ºä¸€ä¸ªåç§°ã€‚ åœ¨æ‰§è¡Œæ­¤ ioctl åï¼Œæ‚¨å¯ä»¥ä½¿ç”¨è¿™ä¸ªåç§°æ¥å¼•ç”¨è¯¥ GEM ç¼“å†²åŒºã€‚ å®ç°ç»†èŠ‚ï¼š ç”¨æˆ·ç©ºé—´ç¨‹åºå¯ä»¥é€šè¿‡æ‰§è¡Œ DRM_IOCTL_GEM_FLINK æ¥ä¸º GEM ç¼“å†²åŒºåˆ›å»ºä¸€ä¸ªåç§°ã€‚ è¿™åœ¨éœ€è¦åœ¨ä¸åŒè¿›ç¨‹ä¹‹é—´å¼•ç”¨ GEM å¯¹è±¡æ—¶éå¸¸æœ‰ç”¨ã€‚ è¯·æ³¨æ„ï¼Œè¿™ä¸ªåç§°ä¸èƒ½ç›´æ¥ç”¨äºåœ¨ DRM API ä¸­å¼•ç”¨å¯¹è±¡ï¼Œåº”ç”¨ç¨‹åºå¿…é¡»ä½¿ç”¨ DRM_IOCTL_GEM_FLINK å’Œ DRM_IOCTL_GEM_OPEN ioctl åˆ†åˆ«å°†å¥æŸ„è½¬æ¢ä¸ºåç§°å’Œåç§°è½¬æ¢ä¸ºå¥æŸ„ã€‚ DRM_IOCTL_GEM_OPEN å®ƒç”¨äºä¸º GEM ç¼“å†²åŒºï¼ˆGraphics Execution Managerï¼‰åˆ›å»ºä¸€ä¸ªåç§°ã€‚è®©æˆ‘ä»¬è¯¦ç»†äº†è§£ä¸€ä¸‹è¿™ä¸ªæ¥å£çš„ä½œç”¨å’Œå®ç°ï¼š æ¥å£ä½œç”¨ï¼š DRM_IOCTL_GEM_OPEN å…è®¸ç”¨æˆ·ç©ºé—´ç¨‹åºä¸º GEM ç¼“å†²åŒºåˆ›å»ºä¸€ä¸ªåç§°ã€‚ åœ¨æ‰§è¡Œæ­¤ ioctl åï¼Œæ‚¨å¯ä»¥ä½¿ç”¨è¿™ä¸ªåç§°æ¥å¼•ç”¨è¯¥ GEM ç¼“å†²åŒºã€‚ å®ç°ç»†èŠ‚ï¼š ç”¨æˆ·ç©ºé—´ç¨‹åºå¯ä»¥é€šè¿‡æ‰§è¡Œ DRM_IOCTL_GEM_OPEN æ¥ä¸º GEM ç¼“å†²åŒºåˆ›å»ºä¸€ä¸ªåç§°ã€‚ è¿™åœ¨éœ€è¦åœ¨ä¸åŒè¿›ç¨‹ä¹‹é—´å¼•ç”¨ GEM å¯¹è±¡æ—¶éå¸¸æœ‰ç”¨ã€‚ è¯·æ³¨æ„ï¼Œè¿™ä¸ªåç§°ä¸èƒ½ç›´æ¥ç”¨äºåœ¨ DRM API ä¸­å¼•ç”¨å¯¹è±¡ï¼Œåº”ç”¨ç¨‹åºå¿…é¡»ä½¿ç”¨ DRM_IOCTL_GEM_FLINK å’Œ DRM_IOCTL_GEM_OPEN ioctl åˆ†åˆ«å°†å¥æŸ„è½¬æ¢ä¸ºåç§°å’Œåç§°è½¬æ¢ä¸ºå¥æŸ„ã€‚ DRM_IOCTL_PRIME_HANDLE_TO_FD å®ƒç”¨äºå°† GEM ç¼“å†²åŒºï¼ˆGraphics Execution Managerï¼‰çš„å¥æŸ„è½¬æ¢ä¸ºæ–‡ä»¶æè¿°ç¬¦ï¼ˆfdï¼‰ã€‚è®©æˆ‘ä»¬è¯¦ç»†äº†è§£ä¸€ä¸‹è¿™ä¸ªæ¥å£çš„ä½œç”¨å’Œå®ç°ï¼š æ¥å£ä½œç”¨ï¼š DRM_IOCTL_PRIME_HANDLE_TO_FD å…è®¸ç”¨æˆ·ç©ºé—´ç¨‹åºå°† GEM ç¼“å†²åŒºçš„å¥æŸ„è½¬æ¢ä¸ºæ–‡ä»¶æè¿°ç¬¦ã€‚ è¿™åœ¨éœ€è¦åœ¨ä¸åŒè¿›ç¨‹ä¹‹é—´å…±äº« GEM ç¼“å†²åŒºæ—¶éå¸¸æœ‰ç”¨ï¼Œä¾‹å¦‚ç”¨äºè·¨è¿›ç¨‹çš„çº¹ç†å…±äº«ã€‚ å®ç°ç»†èŠ‚ï¼š ç”¨æˆ·ç©ºé—´ç¨‹åºå¯ä»¥é€šè¿‡æ‰§è¡Œ DRM_IOCTL_PRIME_HANDLE_TO_FD æ¥è·å–æ–‡ä»¶æè¿°ç¬¦ã€‚ è¿™ä¸ªæ¥å£é€šå¸¸ä¸å…¶ä»–è¿›ç¨‹ä¹‹é—´çš„ IPCï¼ˆè¿›ç¨‹é—´é€šä¿¡ï¼‰ä¸€èµ·ä½¿ç”¨ï¼Œä»¥ä¾¿å…±äº« GEM ç¼“å†²åŒºã€‚ è¯·æ³¨æ„ï¼Œè¿™ä¸ªæ¥å£çš„å®ç°å¯èƒ½å› ä¸åŒçš„ DRM é©±åŠ¨è€Œæœ‰æ‰€ä¸åŒï¼Œå…·ä½“ç»†èŠ‚å¯ä»¥æŸ¥é˜…ç‰¹å®šé©±åŠ¨çš„æ–‡æ¡£æˆ–æºä»£ç ã€‚ ç›¸å…³CMD DRM_IOCTL_PRIME_FD_TO_HANDLE Resource DRM_IOCTL_MODE_GETRESOURCES å®ƒå…è®¸ç”¨æˆ·ç©ºé—´ç¨‹åºè·å–ä¸ DRM è®¾å¤‡ç›¸å…³çš„èµ„æºä¿¡æ¯ã€‚è®©æˆ‘ä»¬è¯¦ç»†äº†è§£ä¸€ä¸‹è¿™ä¸ªæ¥å£çš„ä½œç”¨å’Œå®ç°ï¼š æ¥å£ä½œç”¨ï¼š DRM_IOCTL_MODE_GETRESOURCES ç”¨äºè·å–ä¸ DRM è®¾å¤‡ç›¸å…³çš„èµ„æºä¿¡æ¯ã€‚ è¿™ä¸ªæ¥å£é€šå¸¸ç”¨äºæŸ¥è¯¢è®¾å¤‡çš„å¸§ç¼“å†²ã€è¿æ¥å™¨ã€CRTCï¼ˆæ˜¾ç¤ºç®¡é“ï¼‰å’Œç¼–ç å™¨çš„æ•°é‡å’Œæ ‡è¯†ç¬¦ã€‚ å®ç°ç»†èŠ‚ï¼š ç”¨æˆ·ç©ºé—´ç¨‹åºå¯ä»¥é€šè¿‡æ‰§è¡Œ DRM_IOCTL_MODE_GETRESOURCES æ¥è·å–èµ„æºä¿¡æ¯ã€‚ è¿”å›çš„ç»“æ„ä½“ drm_mode_card_res åŒ…å«äº†å¸§ç¼“å†²ã€è¿æ¥å™¨ã€CRTC å’Œç¼–ç å™¨çš„æ•°é‡ä»¥åŠç›¸åº”çš„æ ‡è¯†ç¬¦ã€‚ è¿™ä¸ªæ¥å£å¯¹äºåˆå§‹åŒ–æ˜¾ç¤ºç®¡é“ã€èµ„æºç®¡ç†å’Œæ¨¡å¼è®¾ç½®éå¸¸é‡è¦ã€‚ DRM_IOCTL_MODE_GETPLANERESOURCES å®ƒç”¨äºè·å–Direct Rendering Manager (DRM)çš„èµ„æºã€‚DRMæ˜¯Linuxå†…æ ¸çš„ä¸€éƒ¨åˆ†ï¼Œè´Ÿè´£å¤„ç†å›¾å½¢ç¡¬ä»¶çš„åº•å±‚ç»†èŠ‚ã€‚ åœ¨ä½¿ç”¨DRM_IOCTL_MODE_GETPLANERESOURCESæ—¶ï¼Œä½ éœ€è¦æ‰“å¼€ä¸€ä¸ªDRMè®¾å¤‡ï¼ˆä¾‹å¦‚/dev/dri/card0ï¼‰ï¼Œç„¶åä½¿ç”¨è¿™ä¸ªioctlè°ƒç”¨æ¥è·å–èµ„æºã€‚è¿™äº›èµ„æºåŒ…æ‹¬å¸§ç¼“å†²åŒºï¼ˆframebuffersï¼‰ã€CRTCï¼ˆCathode Ray Tube Controllerï¼‰ã€è¿æ¥å™¨ï¼ˆconnectorsï¼‰å’Œç¼–ç å™¨ï¼ˆencodersï¼‰ã€‚ è¿™äº›èµ„æºçš„å«ä¹‰å¦‚ä¸‹ï¼š å¸§ç¼“å†²åŒºï¼ˆFramebuffersï¼‰ï¼šå®ƒä»¬åŒ…å«è¦æ˜¾ç¤ºçš„åƒç´ æ•°æ®ã€‚ CRTCï¼šCRTCä»£è¡¨æ•´ä¸ªæ˜¾ç¤ºç®¡é“ï¼Œå®ƒä»ä¸€ä¸ªæˆ–å¤šä¸ªå¹³é¢è·å–åƒç´ æ•°æ®è¿›è¡Œæ··åˆã€‚ è¿æ¥å™¨ï¼ˆConnectorsï¼‰ï¼šåœ¨DRMä¸­ï¼Œè¿æ¥å™¨æ˜¯æ˜¾ç¤ºæ¥æ”¶å™¨çš„ä¸€èˆ¬æŠ½è±¡ï¼ŒåŒ…æ‹¬å›ºå®šé¢æ¿æˆ–ä»»ä½•å…¶ä»–å¯ä»¥ä»¥æŸç§å½¢å¼æ˜¾ç¤ºåƒç´ çš„è®¾å¤‡ã€‚ ç¼–ç å™¨ï¼ˆEncodersï¼‰ï¼šç¼–ç å™¨ä»CRTCè·å–åƒç´ æ•°æ®ï¼Œå¹¶å°†å…¶è½¬æ¢ä¸ºä»»ä½•è¿æ¥çš„è¿æ¥å™¨å¯ä»¥æ¥å—çš„æ ¼å¼ã€‚ è¯·æ³¨æ„ï¼Œè¿™äº›èµ„æºçš„æ•°é‡å¯èƒ½ä¼šæ ¹æ®ä½ çš„ç¡¬ä»¶é…ç½®å’Œå½“å‰çš„æ˜¾ç¤ºè®¾ç½®è€Œå˜åŒ–ã€‚åœ¨ä½¿ç”¨è¿™äº›èµ„æºä¹‹å‰ï¼Œä½ å¯èƒ½éœ€è¦æ£€æŸ¥å®ƒä»¬çš„å¯ç”¨æ€§å’ŒçŠ¶æ€ã€‚ã€‚ DRM_IOCTL_MODE_GETCRTC æ˜¯ä¸€ç§ç”¨äºè·å–æœ‰å…³ç»™å®š CRTCï¼ˆCathode Ray Tube Controllerï¼‰çš„ä¿¡æ¯çš„ IOCTLï¼ˆInput/Output Controlï¼‰å‘½ä»¤ã€‚è¯¦æƒ…å¦‚ä¸‹ï¼š CRTC æ˜¯ä»€ä¹ˆï¼Ÿ CRTC æ˜¯æ˜¾ç¤ºæ§åˆ¶å™¨ï¼Œè´Ÿè´£å°†å›¾å½¢æ•°æ®å‘é€åˆ°æ˜¾ç¤ºè®¾å¤‡ï¼ˆä¾‹å¦‚æ˜¾ç¤ºå™¨æˆ–ç”µè§†ï¼‰ã€‚ å®ƒç®¡ç†åƒç´ æ—¶é’Ÿã€æ‰«æçº¿å’Œå¸§ç¼“å†²åŒºçš„åˆ·æ–°ã€‚ DRM_IOCTL_MODE_GETCRTC çš„ä½œç”¨ é€šè¿‡è°ƒç”¨ DRM_IOCTL_MODE_GETCRTCï¼Œåº”ç”¨ç¨‹åºå¯ä»¥è·å–æœ‰å…³ç‰¹å®š CRTC çš„ä¿¡æ¯ã€‚ è¿™äº›ä¿¡æ¯å¯èƒ½åŒ…æ‹¬ CRTC çš„å½“å‰æ¨¡å¼ã€åˆ†è¾¨ç‡ã€åˆ·æ–°ç‡ç­‰ã€‚ å…¶ä»– DRM IOCTL å‘½ä»¤ é™¤äº† DRM_IOCTL_MODE_GETCRTCï¼Œè¿˜æœ‰å…¶ä»–ä¸æ˜¾ç¤ºè®¾ç½®ç›¸å…³çš„ IOCTL å‘½ä»¤ï¼Œä¾‹å¦‚ï¼š DRM_IOCTL_MODE_GETOUTPUTï¼šè·å–æœ‰å…³ç‰¹å®šè¾“å‡ºçš„ä¿¡æ¯ã€‚ DRM_IOCTL_MODE_SETCRTCï¼šè®¾ç½® CRTC å‚æ•°ã€‚ DRM_IOCTL_MODE_ADDFBï¼šæ·»åŠ æ–°çš„å¸§ç¼“å†²åŒºå¯¹è±¡ã€‚ DRM_IOCTL_MODE_RMFBï¼šç§»é™¤å¸§ç¼“å†²åŒºå¯¹è±¡ã€‚ DRM_IOCTL_MODE_SETCRTC ç”¨äºåœ¨ Linux å†…æ ¸æ¨¡å¼è®¾ç½®ï¼ˆKMSï¼‰ ä¸­è®¾ç½®ç‰¹å®š CRTCï¼ˆCathode Ray Tube Controllerï¼‰ çš„å‚æ•°ã€‚è¯¦æƒ…å¦‚ä¸‹ï¼š CRTC æ˜¯ä»€ä¹ˆï¼Ÿ CRTC æ˜¯æ˜¾ç¤ºæ§åˆ¶å™¨ï¼Œè´Ÿè´£å°†å›¾å½¢æ•°æ®å‘é€åˆ°æ˜¾ç¤ºè®¾å¤‡ï¼ˆä¾‹å¦‚æ˜¾ç¤ºå™¨æˆ–ç”µè§†ï¼‰ã€‚ å®ƒç®¡ç†åƒç´ æ—¶é’Ÿã€æ‰«æçº¿å’Œå¸§ç¼“å†²åŒºçš„åˆ·æ–°ã€‚ DRM_IOCTL_MODE_SETCRTC çš„ä½œç”¨ é€šè¿‡è°ƒç”¨ DRM_IOCTL_MODE_SETCRTCï¼Œåº”ç”¨ç¨‹åºå¯ä»¥è®¾ç½®ç‰¹å®š CRTC çš„å‚æ•°ï¼Œä¾‹å¦‚åˆ†è¾¨ç‡ã€åˆ·æ–°ç‡ç­‰ã€‚ è¿™å¯¹äºé…ç½®æ˜¾ç¤ºè¾“å‡ºéå¸¸é‡è¦ã€‚ å…¶ä»– DRM IOCTL å‘½ä»¤ é™¤äº† DRM_IOCTL_MODE_SETCRTCï¼Œè¿˜æœ‰å…¶ä»–ä¸æ˜¾ç¤ºè®¾ç½®ç›¸å…³çš„ IOCTL å‘½ä»¤ï¼Œä¾‹å¦‚ï¼š DRM_IOCTL_MODE_GETCRTCï¼šè·å–æœ‰å…³ç‰¹å®š CRTC çš„ä¿¡æ¯ã€‚ DRM_IOCTL_MODE_ADDFBï¼šæ·»åŠ æ–°çš„å¸§ç¼“å†²åŒºå¯¹è±¡ã€‚ DRM_IOCTL_MODE_RMFBï¼šç§»é™¤å¸§ç¼“å†²åŒºå¯¹è±¡ã€‚ DRM_IOCTL_MODE_GETPLANE ç”¨äºä» Linux å†…æ ¸æ¨¡å¼è®¾ç½®ï¼ˆKMSï¼‰ ä¸­è·å–ç‰¹å®š å¹³é¢ï¼ˆPlaneï¼‰ çš„ä¿¡æ¯ã€‚è¯¦æƒ…å¦‚ä¸‹ï¼š DRM_IOCTL_MODE_GETPLANE çš„ä½œç”¨ é€šè¿‡è°ƒç”¨ DRM_IOCTL_MODE_GETPLANEï¼Œåº”ç”¨ç¨‹åºå¯ä»¥è·å–æœ‰å…³ç‰¹å®šå¹³é¢çš„ä¿¡æ¯ã€‚ è¿™äº›ä¿¡æ¯å¯èƒ½åŒ…æ‹¬å¹³é¢çš„å½“å‰çŠ¶æ€ã€ä½ç½®ã€å¤§å°ã€åƒç´ æ ¼å¼ç­‰ã€‚ å…¶ä»– DRM IOCTL å‘½ä»¤ é™¤äº† DRM_IOCTL_MODE_GETPLANEï¼Œè¿˜æœ‰å…¶ä»–ä¸æ˜¾ç¤ºè®¾ç½®ç›¸å…³çš„ IOCTL å‘½ä»¤ï¼Œä¾‹å¦‚ï¼š DRM_IOCTL_MODE_GETCRTCï¼šè·å–æœ‰å…³ç‰¹å®š CRTC çš„ä¿¡æ¯ã€‚ DRM_IOCTL_MODE_SETCRTCï¼šè®¾ç½® CRTC å‚æ•°ã€‚ DRM_IOCTL_MODE_ADDFBï¼šæ·»åŠ æ–°çš„å¸§ç¼“å†²åŒºå¯¹è±¡ã€‚ DRM_IOCTL_MODE_RMFBï¼šç§»é™¤å¸§ç¼“å†²åŒºå¯¹è±¡ã€‚ DRM_IOCTL_MODE_SETPLANE ç”¨äºåœ¨ Linux å†…æ ¸æ¨¡å¼è®¾ç½®ï¼ˆKMSï¼‰ ä¸­è®¾ç½®ç‰¹å®š å¹³é¢ï¼ˆPlaneï¼‰ çš„å‚æ•°ã€‚è¯¦æƒ…å¦‚ä¸‹ï¼š DRM_IOCTL_MODE_SETPLANE çš„ä½œç”¨ é€šè¿‡è°ƒç”¨ DRM_IOCTL_MODE_SETPLANEï¼Œåº”ç”¨ç¨‹åºå¯ä»¥è®¾ç½®ç‰¹å®šå¹³é¢çš„å‚æ•°ï¼Œä¾‹å¦‚åˆ†è¾¨ç‡ã€åˆ·æ–°ç‡ç­‰ã€‚ è¿™å¯¹äºé…ç½®æ˜¾ç¤ºè¾“å‡ºéå¸¸é‡è¦ã€‚ å…¶ä»– DRM IOCTL å‘½ä»¤ é™¤äº† DRM_IOCTL_MODE_SETPLANEï¼Œè¿˜æœ‰å…¶ä»–ä¸æ˜¾ç¤ºè®¾ç½®ç›¸å…³çš„ IOCTL å‘½ä»¤ï¼Œä¾‹å¦‚ï¼š DRM_IOCTL_MODE_GETCRTCï¼šè·å–æœ‰å…³ç‰¹å®š CRTC çš„ä¿¡æ¯ã€‚ DRM_IOCTL_MODE_SETCRTCï¼šè®¾ç½® CRTC å‚æ•°ã€‚ DRM_IOCTL_MODE_ADDFBï¼šæ·»åŠ æ–°çš„å¸§ç¼“å†²åŒºå¯¹è±¡ã€‚ DRM_IOCTL_MODE_RMFBï¼šç§»é™¤å¸§ç¼“å†²åŒºå¯¹è±¡ã€‚ Cursor DRM_IOCTL_MODE_CURSOR ç”¨äºæ“ä½œç‰¹å®š CRTCï¼ˆCathode Ray Tube Controllerï¼‰ çš„ å…‰æ ‡å¹³é¢ï¼ˆCursor Planeï¼‰ã€‚è¯¦æƒ…å¦‚ä¸‹ï¼š CRTC æ˜¯ä»€ä¹ˆï¼Ÿ CRTC æ˜¯æ˜¾ç¤ºæ§åˆ¶å™¨ï¼Œè´Ÿè´£å°†å›¾å½¢æ•°æ®å‘é€åˆ°æ˜¾ç¤ºè®¾å¤‡ï¼ˆä¾‹å¦‚æ˜¾ç¤ºå™¨æˆ–ç”µè§†ï¼‰ã€‚ å®ƒç®¡ç†åƒç´ æ—¶é’Ÿã€æ‰«æçº¿å’Œå¸§ç¼“å†²åŒºçš„åˆ·æ–°ã€‚ å…‰æ ‡å¹³é¢ï¼ˆCursor Planeï¼‰çš„ä½œç”¨ å…‰æ ‡å¹³é¢ æ˜¯ä¸€ç§ç‰¹æ®Šçš„æ˜¾ç¤ºå¹³é¢ï¼Œç”¨äºæ˜¾ç¤ºå…‰æ ‡æˆ–å…¶ä»–å°å‹å›¾å½¢å…ƒç´ ã€‚ é€šè¿‡è°ƒç”¨ DRM_IOCTL_MODE_CURSORï¼Œåº”ç”¨ç¨‹åºå¯ä»¥æ“ä½œå…‰æ ‡å¹³é¢ï¼Œä¾‹å¦‚è®¾ç½®å…‰æ ‡çš„ä½ç½®ã€å¤§å°ã€å›¾åƒç­‰ã€‚ å…¶ä»– DRM IOCTL å‘½ä»¤ é™¤äº† DRM_IOCTL_MODE_CURSORï¼Œè¿˜æœ‰å…¶ä»–ä¸æ˜¾ç¤ºè®¾ç½®ç›¸å…³çš„ IOCTL å‘½ä»¤ï¼Œä¾‹å¦‚ï¼š DRM_IOCTL_MODE_GETCRTCï¼šè·å–æœ‰å…³ç‰¹å®š CRTC çš„ä¿¡æ¯ã€‚ DRM_IOCTL_MODE_SETCRTCï¼šè®¾ç½® CRTC å‚æ•°ã€‚ DRM_IOCTL_MODE_ADDFBï¼šæ·»åŠ æ–°çš„å¸§ç¼“å†²åŒºå¯¹è±¡ã€‚ DRM_IOCTL_MODE_RMFBï¼šç§»é™¤å¸§ç¼“å†²åŒºå¯¹è±¡ã€‚ DRM_IOCTL_MODE_CURSOR2 ç”¨äºæ“ä½œç‰¹å®š CRTCï¼ˆCathode Ray Tube Controllerï¼‰ çš„ å…‰æ ‡å¹³é¢ï¼ˆCursor Planeï¼‰âµã€‚è¯¦æƒ…å¦‚ä¸‹ï¼š CRTC æ˜¯ä»€ä¹ˆï¼Ÿ CRTC æ˜¯æ˜¾ç¤ºæ§åˆ¶å™¨ï¼Œè´Ÿè´£å°†å›¾å½¢æ•°æ®å‘é€åˆ°æ˜¾ç¤ºè®¾å¤‡ï¼ˆä¾‹å¦‚æ˜¾ç¤ºå™¨æˆ–ç”µè§†ï¼‰ã€‚ å®ƒç®¡ç†åƒç´ æ—¶é’Ÿã€æ‰«æçº¿å’Œå¸§ç¼“å†²åŒºçš„åˆ·æ–°ã€‚ å…‰æ ‡å¹³é¢ï¼ˆCursor Planeï¼‰çš„ä½œç”¨ å…‰æ ‡å¹³é¢ æ˜¯ä¸€ç§ç‰¹æ®Šçš„æ˜¾ç¤ºå¹³é¢ï¼Œç”¨äºæ˜¾ç¤ºå…‰æ ‡æˆ–å…¶ä»–å°å‹å›¾å½¢å…ƒç´ ã€‚ é€šè¿‡è°ƒç”¨ DRM_IOCTL_MODE_CURSOR2ï¼Œåº”ç”¨ç¨‹åºå¯ä»¥æ“ä½œå…‰æ ‡å¹³é¢ï¼Œä¾‹å¦‚è®¾ç½®å…‰æ ‡çš„ä½ç½®ã€å¤§å°ã€å›¾åƒç­‰ã€‚ å…¶ä»– DRM IOCTL å‘½ä»¤ é™¤äº† DRM_IOCTL_MODE_CURSOR2ï¼Œè¿˜æœ‰å…¶ä»–ä¸æ˜¾ç¤ºè®¾ç½®ç›¸å…³çš„ IOCTL å‘½ä»¤ï¼Œä¾‹å¦‚ï¼š DRM_IOCTL_MODE_GETCRTCï¼šè·å–æœ‰å…³ç‰¹å®š CRTC çš„ä¿¡æ¯ã€‚ DRM_IOCTL_MODE_SETCRTCï¼šè®¾ç½® CRTC å‚æ•°ã€‚ DRM_IOCTL_MODE_ADDFBï¼šæ·»åŠ æ–°çš„å¸§ç¼“å†²åŒºå¯¹è±¡ã€‚ DRM_IOCTL_MODE_RMFBï¼šç§»é™¤å¸§ç¼“å†²åŒºå¯¹è±¡ã€‚ åŒºåˆ« DRM_IOCTL_MODE_CURSOR å’Œ DRM_IOCTL_MODE_CURSOR2 éƒ½æ˜¯ IOCTLï¼ˆInput/Output Controlï¼‰å‘½ä»¤ï¼Œç”¨äºæ“ä½œç‰¹å®š CRTCï¼ˆCathode Ray Tube Controllerï¼‰ çš„ å…‰æ ‡å¹³é¢ï¼ˆCursor Planeï¼‰ã€‚å®ƒä»¬ä¹‹é—´çš„åŒºåˆ«å¦‚ä¸‹ï¼š DRM_IOCTL_MODE_CURSOR DRM_IOCTL_MODE_CURSOR æ˜¯æ—§ç‰ˆæœ¬çš„å‘½ä»¤ï¼Œç”¨äºè®¾ç½®å…‰æ ‡å¹³é¢çš„å‚æ•°ï¼Œä¾‹å¦‚å…‰æ ‡çš„ä½ç½®ã€å¤§å°ã€å›¾åƒç­‰ã€‚ å®ƒéµå¾ªæ—§çš„å…‰æ ‡å¹³é¢æ“ä½œè¯­ä¹‰ã€‚ DRM_IOCTL_MODE_CURSOR2 DRM_IOCTL_MODE_CURSOR2 æ˜¯æ–°ç‰ˆæœ¬çš„å‘½ä»¤ï¼Œç”¨äºç›¸åŒçš„ç›®çš„ï¼Œä½†å¯èƒ½å…·æœ‰æ›´ä¸°å¯Œçš„åŠŸèƒ½ã€‚ å®ƒå¯èƒ½æ”¯æŒæ›´å¤šå±æ€§ï¼Œä¾‹å¦‚æ›´çµæ´»çš„å…‰æ ‡å½¢çŠ¶ã€é€æ˜åº¦ç­‰ã€‚ æ€»ä¹‹ï¼ŒDRM_IOCTL_MODE_CURSOR2 å¯èƒ½æ˜¯å¯¹ DRM_IOCTL_MODE_CURSOR çš„æ”¹è¿›æˆ–æ‰©å±•ï¼Œä»¥æä¾›æ›´å¥½çš„å…‰æ ‡å¹³é¢æ§åˆ¶ã€‚ Sync Obj DRM_IOCTL_SYNCOBJ_CREATE ç”¨äºåœ¨ Linux å†…æ ¸æ¨¡å¼è®¾ç½®ï¼ˆKMSï¼‰ ä¸­åˆ›å»º åŒæ­¥å¯¹è±¡ï¼ˆSync Objectï¼‰ã€‚è¯¦æƒ…å¦‚ä¸‹ï¼š åŒæ­¥å¯¹è±¡æ˜¯ä»€ä¹ˆï¼Ÿ åŒæ­¥å¯¹è±¡ æ˜¯ä¸€ç§ç”¨äºåè°ƒå¤šä¸ªå¹¶å‘ä»»åŠ¡ä¹‹é—´çš„åŒæ­¥æœºåˆ¶ã€‚ åœ¨å›¾å½¢æ¸²æŸ“ä¸­ï¼ŒåŒæ­¥å¯¹è±¡é€šå¸¸ç”¨äºç¡®ä¿ä¸åŒå›¾å½¢æ“ä½œçš„æ‰§è¡Œé¡ºåºæˆ–é¿å…ç«æ€æ¡ä»¶ã€‚ DRM_IOCTL_SYNCOBJ_CREATE çš„ä½œç”¨ é€šè¿‡è°ƒç”¨ DRM_IOCTL_SYNCOBJ_CREATEï¼Œåº”ç”¨ç¨‹åºå¯ä»¥åˆ›å»ºä¸€ä¸ªåŒæ­¥å¯¹è±¡ã€‚ åŒæ­¥å¯¹è±¡å¯ä»¥ç”¨äºè·Ÿè¸ªå›¾å½¢æ“ä½œçš„å®ŒæˆçŠ¶æ€ï¼Œä¾‹å¦‚ç­‰å¾…æ¸²æŸ“å®Œæˆæˆ–ç­‰å¾…å…¶ä»–äº‹ä»¶ã€‚ å…¶ä»– DRM IOCTL å‘½ä»¤ é™¤äº† DRM_IOCTL_SYNCOBJ_CREATEï¼Œè¿˜æœ‰å…¶ä»–ä¸æ˜¾ç¤ºè®¾ç½®ç›¸å…³çš„ IOCTL å‘½ä»¤ï¼Œä¾‹å¦‚ï¼š DRM_IOCTL_MODE_GETCRTCï¼šè·å–æœ‰å…³ç‰¹å®š CRTC çš„ä¿¡æ¯ã€‚ DRM_IOCTL_MODE_SETCRTCï¼šè®¾ç½® CRTC å‚æ•°ã€‚ DRM_IOCTL_MODE_ADDFBï¼šæ·»åŠ æ–°çš„å¸§ç¼“å†²åŒºå¯¹è±¡ã€‚ DRM_IOCTL_MODE_RMFBï¼šç§»é™¤å¸§ç¼“å†²åŒºå¯¹è±¡ã€‚ DRM_IOCTL_SYNCOBJ_HANDLE_TO_FD ç”¨äºåœ¨ Linux å†…æ ¸æ¨¡å¼è®¾ç½®ï¼ˆKMSï¼‰ ä¸­å°†ç‰¹å®š åŒæ­¥å¯¹è±¡ï¼ˆSync Objectï¼‰ çš„å¥æŸ„è½¬æ¢ä¸ºæ–‡ä»¶æè¿°ç¬¦ï¼ˆFile Descriptorï¼‰ã€‚ è¯¦æƒ…å¦‚ä¸‹ï¼š åŒæ­¥å¯¹è±¡æ˜¯ä»€ä¹ˆï¼Ÿ åŒæ­¥å¯¹è±¡ æ˜¯ä¸€ç§ç”¨äºåè°ƒå¤šä¸ªå¹¶å‘ä»»åŠ¡ä¹‹é—´çš„åŒæ­¥æœºåˆ¶ã€‚ åœ¨å›¾å½¢æ¸²æŸ“ä¸­ï¼ŒåŒæ­¥å¯¹è±¡é€šå¸¸ç”¨äºç¡®ä¿ä¸åŒå›¾å½¢æ“ä½œçš„æ‰§è¡Œé¡ºåºæˆ–é¿å…ç«æ€æ¡ä»¶ã€‚ DRM_IOCTL_SYNCOBJ_HANDLE_TO_FD çš„ä½œç”¨ é€šè¿‡è°ƒç”¨ DRM_IOCTL_SYNCOBJ_HANDLE_TO_FDï¼Œåº”ç”¨ç¨‹åºå¯ä»¥å°†åŒæ­¥å¯¹è±¡çš„å¥æŸ„è½¬æ¢ä¸ºæ–‡ä»¶æè¿°ç¬¦ã€‚ æ–‡ä»¶æè¿°ç¬¦æ˜¯ä¸€ç§ç”¨äºåœ¨è¿›ç¨‹ä¹‹é—´ä¼ é€’å¥æŸ„çš„æœºåˆ¶ã€‚è¿™äº›æ–‡ä»¶æè¿°ç¬¦æ˜¯ä¸é€æ˜çš„ï¼Œåªèƒ½ç”¨äºä¼ é€’åŒæ­¥å¯¹è±¡å¥æŸ„ã€‚ å…¶ä»– DRM IOCTL å‘½ä»¤ é™¤äº† DRM_IOCTL_SYNCOBJ_HANDLE_TO_FDï¼Œè¿˜æœ‰å…¶ä»–ä¸æ˜¾ç¤ºè®¾ç½®ç›¸å…³çš„ IOCTL å‘½ä»¤ï¼Œä¾‹å¦‚ï¼š DRM_IOCTL_MODE_GETCRTCï¼šè·å–æœ‰å…³ç‰¹å®š CRTC çš„ä¿¡æ¯ã€‚ DRM_IOCTL_MODE_SETCRTCï¼šè®¾ç½® CRTC å‚æ•°ã€‚ DRM_IOCTL_MODE_ADDFBï¼šæ·»åŠ æ–°çš„å¸§ç¼“å†²åŒºå¯¹è±¡ã€‚ DRM_IOCTL_MODE_RMFBï¼šç§»é™¤å¸§ç¼“å†²åŒºå¯¹è±¡ã€‚ DRM_IOCTL_SYNCOBJ_SIGNAL ç”¨äºåœ¨ Linux å†…æ ¸æ¨¡å¼è®¾ç½®ï¼ˆKMSï¼‰ ä¸­ç›´æ¥è§¦å‘ç‰¹å®š åŒæ­¥å¯¹è±¡ï¼ˆSync Objectï¼‰ã€‚è¿™ä¸ªå‘½ä»¤æä¾›äº†ä¸€ç§ç”¨æˆ·ç©ºé—´æ‰‹åŠ¨è§¦å‘åŒæ­¥å¯¹è±¡çš„æœºåˆ¶ã€‚ ä»¥ä¸‹æ˜¯å…³äº DRM_IOCTL_SYNCOBJ_SIGNAL çš„ä¸€äº›è¦ç‚¹ï¼š åŒæ­¥å¯¹è±¡æ˜¯ä»€ä¹ˆï¼Ÿ åŒæ­¥å¯¹è±¡ æ˜¯ä¸€ç§ç”¨äºåè°ƒå¤šä¸ªå¹¶å‘ä»»åŠ¡ä¹‹é—´çš„åŒæ­¥æœºåˆ¶ã€‚ åœ¨å›¾å½¢æ¸²æŸ“ä¸­ï¼ŒåŒæ­¥å¯¹è±¡é€šå¸¸ç”¨äºç¡®ä¿ä¸åŒå›¾å½¢æ“ä½œçš„æ‰§è¡Œé¡ºåºæˆ–é¿å…ç«æ€æ¡ä»¶ã€‚ DRM_IOCTL_SYNCOBJ_SIGNAL çš„ä½œç”¨ é€šè¿‡è°ƒç”¨ DRM_IOCTL_SYNCOBJ_SIGNALï¼Œç”¨æˆ·ç©ºé—´å¯ä»¥ç›´æ¥è§¦å‘ç‰¹å®šåŒæ­¥å¯¹è±¡ã€‚ è¿™å¯¹äºæ‰‹åŠ¨è§¦å‘åŒæ­¥å¯¹è±¡éå¸¸æœ‰ç”¨ã€‚ å…¶ä»– DRM IOCTL å‘½ä»¤ é™¤äº† DRM_IOCTL_SYNCOBJ_SIGNALï¼Œè¿˜æœ‰å…¶ä»–ä¸æ˜¾ç¤ºè®¾ç½®ç›¸å…³çš„ IOCTL å‘½ä»¤ï¼Œä¾‹å¦‚ï¼š DRM_IOCTL_MODE_GETCRTCï¼šè·å–æœ‰å…³ç‰¹å®š CRTC çš„ä¿¡æ¯ã€‚ DRM_IOCTL_MODE_SETCRTCï¼šè®¾ç½® CRTC å‚æ•°ã€‚ DRM_IOCTL_MODE_ADDFBï¼šæ·»åŠ æ–°çš„å¸§ç¼“å†²åŒºå¯¹è±¡ã€‚ DRM_IOCTL_MODE_RMFBï¼šç§»é™¤å¸§ç¼“å†²åŒºå¯¹è±¡ã€‚ Lease DRM_IOCTL_MODE_CREATE_LEASE ç”¨äºåœ¨ Linux å†…æ ¸æ¨¡å¼è®¾ç½®ï¼ˆKMSï¼‰ ä¸­åˆ›å»º ç§Ÿçº¦ï¼ˆLeaseï¼‰ã€‚è¯¦æƒ…å¦‚ä¸‹ï¼š ç§Ÿçº¦æ˜¯ä»€ä¹ˆï¼Ÿ ç§Ÿçº¦ æ˜¯ä¸€ç§æœºåˆ¶ï¼Œç”¨äºç®¡ç†å›¾å½¢èµ„æºçš„å…±äº«å’Œè®¿é—®æƒé™ã€‚ åœ¨å¤šä¸ªå›¾å½¢å®¢æˆ·ç«¯ä¹‹é—´ï¼Œç§Ÿçº¦å…è®¸æ§åˆ¶å¯¹ç‰¹å®šèµ„æºï¼ˆä¾‹å¦‚å¸§ç¼“å†²åŒºã€å¹³é¢ã€è¿æ¥å™¨ç­‰ï¼‰çš„è®¿é—®ã€‚ DRM_IOCTL_MODE_CREATE_LEASE çš„ä½œç”¨ é€šè¿‡è°ƒç”¨ DRM_IOCTL_MODE_CREATE_LEASEï¼Œåº”ç”¨ç¨‹åºå¯ä»¥åˆ›å»ºä¸€ä¸ªç§Ÿçº¦ã€‚ ç§Ÿçº¦å¯ä»¥ç”¨äºåè°ƒå¤šä¸ªå›¾å½¢å®¢æˆ·ç«¯ä¹‹é—´çš„èµ„æºå…±äº«ï¼Œä»¥ç¡®ä¿èµ„æºçš„æ­£ç¡®ä½¿ç”¨å’Œè®¿é—®æƒé™ã€‚ å…¶ä»– DRM IOCTL å‘½ä»¤ é™¤äº† DRM_IOCTL_MODE_CREATE_LEASEï¼Œè¿˜æœ‰å…¶ä»–ä¸æ˜¾ç¤ºè®¾ç½®ç›¸å…³çš„ IOCTL å‘½ä»¤ï¼Œä¾‹å¦‚ï¼š DRM_IOCTL_MODE_GETCRTCï¼šè·å–æœ‰å…³ç‰¹å®š CRTC çš„ä¿¡æ¯ã€‚ DRM_IOCTL_MODE_SETCRTCï¼šè®¾ç½® CRTC å‚æ•°ã€‚ DRM_IOCTL_MODE_ADDFBï¼šæ·»åŠ æ–°çš„å¸§ç¼“å†²åŒºå¯¹è±¡ã€‚ DRM_IOCTL_MODE_RMFBï¼šç§»é™¤å¸§ç¼“å†²åŒºå¯¹è±¡ã€‚ DRM_IOCTL_MODE_LIST_LESSEES ç”¨äºä» Linux å†…æ ¸æ¨¡å¼è®¾ç½®ï¼ˆKMSï¼‰ ä¸­è·å–ç‰¹å®š ç§Ÿçº¦ï¼ˆLeaseï¼‰ æ‰€æœ‰ç§Ÿæˆ·ï¼ˆlesseesï¼‰çš„æ ‡è¯†ç¬¦ï¼ˆidentifiersï¼‰ã€‚ ä»¥ä¸‹æ˜¯å…³äº DRM_IOCTL_MODE_LIST_LESSEES çš„ä¸€äº›è¦ç‚¹ï¼š ç§Ÿçº¦æ˜¯ä»€ä¹ˆï¼Ÿ ç§Ÿçº¦ æ˜¯ä¸€ç§æœºåˆ¶ï¼Œç”¨äºç®¡ç†å›¾å½¢èµ„æºçš„å…±äº«å’Œè®¿é—®æƒé™ã€‚ åœ¨å¤šä¸ªå›¾å½¢å®¢æˆ·ç«¯ä¹‹é—´ï¼Œç§Ÿçº¦å…è®¸æ§åˆ¶å¯¹ç‰¹å®šèµ„æºï¼ˆä¾‹å¦‚å¸§ç¼“å†²åŒºã€å¹³é¢ã€è¿æ¥å™¨ç­‰ï¼‰çš„è®¿é—®ã€‚ DRM_IOCTL_MODE_LIST_LESSEES çš„ä½œç”¨ é€šè¿‡è°ƒç”¨ DRM_IOCTL_MODE_LIST_LESSEESï¼Œåº”ç”¨ç¨‹åºå¯ä»¥è·å–ç‰¹å®šç§Ÿçº¦çš„æ‰€æœ‰ç§Ÿæˆ·çš„æ ‡è¯†ç¬¦ã€‚ è¿™å¯¹äºäº†è§£ç§Ÿçº¦çš„ä½¿ç”¨æƒ…å†µä»¥åŠèµ„æºå…±äº«éå¸¸æœ‰ç”¨ã€‚ å…¶ä»– DRM IOCTL å‘½ä»¤ é™¤äº† DRM_IOCTL_MODE_LIST_LESSEESï¼Œè¿˜æœ‰å…¶ä»–ä¸æ˜¾ç¤ºè®¾ç½®ç›¸å…³çš„ IOCTL å‘½ä»¤ï¼Œä¾‹å¦‚ï¼š DRM_IOCTL_MODE_GETCRTCï¼šè·å–æœ‰å…³ç‰¹å®š CRTC çš„ä¿¡æ¯ã€‚ DRM_IOCTL_MODE_SETCRTCï¼šè®¾ç½® CRTC å‚æ•°ã€‚ DRM_IOCTL_MODE_ADDFBï¼šæ·»åŠ æ–°çš„å¸§ç¼“å†²åŒºå¯¹è±¡ã€‚ DRM_IOCTL_MODE_RMFBï¼šç§»é™¤å¸§ç¼“å†²åŒºå¯¹è±¡ã€‚ DRM_IOCTL_MODE_GET_LEASE ç”¨äºä» Linux å†…æ ¸æ¨¡å¼è®¾ç½®ï¼ˆKMSï¼‰ ä¸­è·å–ç‰¹å®š ç§Ÿçº¦ï¼ˆLeaseï¼‰ çš„ä¿¡æ¯ã€‚è¯¦æƒ…å¦‚ä¸‹ï¼š ç§Ÿçº¦æ˜¯ä»€ä¹ˆï¼Ÿ ç§Ÿçº¦ æ˜¯ä¸€ç§æœºåˆ¶ï¼Œç”¨äºç®¡ç†å›¾å½¢èµ„æºçš„å…±äº«å’Œè®¿é—®æƒé™ã€‚ åœ¨å¤šä¸ªå›¾å½¢å®¢æˆ·ç«¯ä¹‹é—´ï¼Œç§Ÿçº¦å…è®¸æ§åˆ¶å¯¹ç‰¹å®šèµ„æºï¼ˆä¾‹å¦‚å¸§ç¼“å†²åŒºã€å¹³é¢ã€è¿æ¥å™¨ç­‰ï¼‰çš„è®¿é—®ã€‚ DRM_IOCTL_MODE_GET_LEASE çš„ä½œç”¨ é€šè¿‡è°ƒç”¨ DRM_IOCTL_MODE_GET_LEASEï¼Œåº”ç”¨ç¨‹åºå¯ä»¥è·å–æœ‰å…³ç‰¹å®šç§Ÿçº¦çš„ä¿¡æ¯ã€‚ è¿™äº›ä¿¡æ¯å¯èƒ½åŒ…æ‹¬ç§Ÿçº¦çš„çŠ¶æ€ã€ç§Ÿçº¦çš„èµ„æºåˆ—è¡¨ã€ç§Ÿçº¦çš„æŒæœ‰è€…ç­‰ã€‚ å…¶ä»– DRM IOCTL å‘½ä»¤ é™¤äº† DRM_IOCTL_MODE_GET_LEASEï¼Œè¿˜æœ‰å…¶ä»–ä¸æ˜¾ç¤ºè®¾ç½®ç›¸å…³çš„ IOCTL å‘½ä»¤ï¼Œä¾‹å¦‚ï¼š DRM_IOCTL_MODE_CREATE_LEASEï¼šåˆ›å»ºç§Ÿçº¦ã€‚ DRM_IOCTL_MODE_LIST_LESSEESï¼šåˆ—å‡ºç§Ÿçº¦çš„æ‰€æœ‰ç§Ÿæˆ·ã€‚ DRM_IOCTL_MODE_REVOKE_LEASE ç”¨äºåœ¨ Linux å†…æ ¸æ¨¡å¼è®¾ç½®ï¼ˆKMSï¼‰ ä¸­æ’¤é”€ç‰¹å®š ç§Ÿçº¦ï¼ˆLeaseï¼‰ çš„æƒé™ã€‚ ä»¥ä¸‹æ˜¯å…³äº DRM_IOCTL_MODE_REVOKE_LEASE çš„ä¸€äº›è¦ç‚¹ï¼š ç§Ÿçº¦æ˜¯ä»€ä¹ˆï¼Ÿ ç§Ÿçº¦ æ˜¯ä¸€ç§æœºåˆ¶ï¼Œç”¨äºç®¡ç†å›¾å½¢èµ„æºçš„å…±äº«å’Œè®¿é—®æƒé™ã€‚ åœ¨å¤šä¸ªå›¾å½¢å®¢æˆ·ç«¯ä¹‹é—´ï¼Œç§Ÿçº¦å…è®¸æ§åˆ¶å¯¹ç‰¹å®šèµ„æºï¼ˆä¾‹å¦‚å¸§ç¼“å†²åŒºã€å¹³é¢ã€è¿æ¥å™¨ç­‰ï¼‰çš„è®¿é—®ã€‚ DRM_IOCTL_MODE_REVOKE_LEASE çš„ä½œç”¨ é€šè¿‡è°ƒç”¨ DRM_IOCTL_MODE_REVOKE_LEASEï¼Œåº”ç”¨ç¨‹åºå¯ä»¥æ’¤é”€ç‰¹å®šç§Ÿçº¦çš„æƒé™ã€‚ è¿™å¯¹äºé™åˆ¶èµ„æºçš„è®¿é—®æˆ–æ›´æ”¹ç§Ÿçº¦çš„çŠ¶æ€éå¸¸æœ‰ç”¨ã€‚ å…¶ä»– DRM IOCTL å‘½ä»¤ é™¤äº† DRM_IOCTL_MODE_REVOKE_LEASEï¼Œè¿˜æœ‰å…¶ä»–ä¸æ˜¾ç¤ºè®¾ç½®ç›¸å…³çš„ IOCTL å‘½ä»¤ï¼Œä¾‹å¦‚ï¼š DRM_IOCTL_MODE_CREATE_LEASEï¼šåˆ›å»ºç§Ÿçº¦ã€‚ DRM_IOCTL_MODE_LIST_LESSEESï¼šåˆ—å‡ºç§Ÿçº¦çš„æ‰€æœ‰ç§Ÿæˆ·ã€‚"
  },"/blog/jekyll/2000-04-27-linux_grpahic_architecture.html": {
    "title": "Linux graphic arch",
    "keywords": "Jekyll",
    "url": "/blog/jekyll/2000-04-27-linux_grpahic_architecture.html",
    "body": ""
  }}
