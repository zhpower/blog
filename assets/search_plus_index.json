{"/blog/pages/about/": {
    "title": "About",
    "keywords": "Jekyll",
    "url": "/blog/pages/about/",
    "body": "日常工作的学习笔记"
  },"/blog/pages/contact/": {
    "title": "Contact",
    "keywords": "Jekyll",
    "url": "/blog/pages/contact/",
    "body": "zh_power@hotmail.com"
  },"/blog/pages/design/draft/": {
    "title": "Design Draft",
    "keywords": "Jekyll",
    "url": "/blog/pages/design/draft/",
    "body": "This is an draft page."
  },"/blog/jekyll/2023-04-27-bit.html": {
    "title": "位运算",
    "keywords": "Jekyll",
    "url": "/blog/jekyll/2023-04-27-bit.html",
    "body": "1.位运算概述 从现代计算机中所有的数据二进制的形式存储在设备中。即 0、1 两种状态，计算机对二进制数据进行的运算(+、-、*、/)都是叫位运算，即将符号位共同参与运算的运算。 口说无凭，举一个简单的例子来看下 CPU 是如何进行计算的，比如这行代码： int a = 35; int b = 47; int c = a + b; 计算两个数的和，因为在计算机中都是以二进制来进行运算，所以上面我们所给的 int 变量会在机器内部先转换为二进制在进行相加： 35: 0 0 1 0 0 0 1 1 47: 0 0 1 0 1 1 1 1 ———————————————————— 82: 0 1 0 1 0 0 1 0 所以，相比在代码中直接使用(+、-、*、/ )运算符，合理的运用位运算更能显著提高代码在机器上的执行效率。 2.位运算概览 ![[image-20230313173955848.png]] 3.按位与运算符（&amp;） 定义：参加运算的两个数据，按二进制位进行”与”运算。 3.1 运算规则： 0&amp;0=0 0&amp;1=0 1&amp;0=0 1&amp;1=1 总结：两位同时为1，结果才为1，否则结果为0。 例如：3&amp;5 即 0000 0011&amp; 0000 0101 = 0000 0001，因此 3&amp;5 的值得1。 注意：负数按补码形式参加按位与运算。 3.2 与运算的用途： 1）清零 如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。 2）取一个数的指定位 比如取数 X=1010 1110 的低4位，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位与运算（X&amp;Y=0000 1110）即可得到X的指定位。 3）判断奇偶 只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((a &amp; 1) == 0)代替if (a % 2 == 0)来判断a是不是偶数。 4. 按位或运算符（|） 定义：参加运算的两个对象，按二进制位进行”或”运算。 4.1 运算规则： 0 0=0 0 1=1 1 0=1 1 1=1 总结：参加运算的两个对象只要有一个为1，其值为1。 例如：3 5即 0000 0011 0000 0101 = 0000 0111，因此，3 5的值得7。　 注意：负数按补码形式参加按位或运算。 4.2 或运算的用途： 1）常用来对一个数据的某些位设置为1 比如将数 X=1010 1110 的低4位设置为1，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位或运算（X Y=1010 1111）即可得到。 5.异或运算符（^） 定义：参加运算的两个数据，按二进制位进行”异或”运算。 5.1 运算规则： 0^0=0 0^1=1 1^0=1 1^1=0 总结：参加运算的两个对象，如果两个相应位相同为0，相异为1。 异或的几条性质: 1、交换律 2、结合律 (a^b)^c == a^(b^c) 3、对于任何数x，都有 x^x=0，x^0=x 4、自反性: a^b^b=a^0=a; 5.2 异或运算的用途： 1）翻转指定位 比如将数 X=1010 1110 的低4位进行翻转，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行异或运算（X^Y=1010 0001）即可得到。 2）与0相异或值不变 例如：1010 1110 ^ 0000 0000 = 1010 1110 3）交换两个数 void Swap(int &amp;a, int &amp;b){     if (a != b){         a ^= b;         b ^= a;         a ^= b;     } } 6.取反运算符 (~) 定义：参加运算的一个数据，按二进制进行”取反”运算。 6.1 运算规则：　 ~1=0 ~0=1 总结：对一个二进制数按位取反，即将0变1，1变0。 6.2 取反运算符的用途： 1）使一个数的最低位为零 使a的最低位为0，可以表示为：a &amp; ~1。~1的值为 1111 1111 1111 1110，再按”与”运算，最低位一定为0。因为” ~”运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。 7.左移运算符（«） 定义：将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。 设 a=1010 1110，a = a« 2 将a的二进制位左移2位、右补0，即得a=1011 1000。 7.1 «1 左移 1位 相当于乘2 若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。 8.右移运算符（»） 定义：将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 例如：a=a»2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。 8.1 »1 右移一位相当于除2 操作数每右移一位，相当于该数除以2。 9.复合赋值运算符 位运算符与赋值运算符结合，组成新的复合赋值运算符，它们是： &amp;= 例：a&amp;=b 相当于 a=a&amp;b = 例：a =b 相当于 a=a b &gt;&gt;= 例：a»=b 相当于 a=a»b «= 例：a«=b 相当于 a=a« b ^= 例：a^=b 相当于 a=a^b 运算规则：和前面讲的复合赋值运算符的运算规则相似。 不同长度的数据进行位运算：如果两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算。 以”与运算”为例说明如下：我们知道在C语言中long型占4个字节，int型占2个字节，如果一个long型数据与一个int型数据进行”与运算”，右端对齐后，左边不足的位依下面三种情况补足， 1）如果整型数据为正数，左边补16个0。 2）如果整型数据为负数，左边补16个1。 3）如果整形数据为无符号数，左边也补16个0。 如：long a=123；int b=1；计算a&amp; b。 如：long a=123；int b=-1；计算a&amp; b。 如：long a=123；unsigned intb=1；计算a &amp; b。"
  },"/blog/jekyll/2022-04-27-ffmpeg.html": {
    "title": "ffmpeg命令",
    "keywords": "Jekyll",
    "url": "/blog/jekyll/2022-04-27-ffmpeg.html",
    "body": "01. 视频分割 ffmpeg -ss 00:00:00 -i input.mp4 -c copy -t 60 output.mp4 -ss 表示视频分割的起始时间，-t 表示分割时长，同时也可以用 00:01:00表示 ==注意== ：-ss 要放在 -i 之前 02. 视频区域裁剪： ffmpeg -i 3.mkv -filter_complex crop=1024:50:0:550 -y 4.mkv 03. 视频预览 ffplay 3.mkv -vf crop=1024:50:0:550 04. 视频放大,缩小 ffmpeg -i 2.mp4 -vf \"scale=1280:64\" 4.mp4 ==scale== =w:h 表示放大后的大小 05. 列出所有format // list all pix format ffmpeg -pix_fmts 06. 图片转换 ffmpeg -i temp.jpg -s 1024x680 -pix_fmt yuvj420p 9.yuv ffmpeg.exe -i agf-dog-1280x960.jpg -vf scale=1920:1080 agf-dog-1920x1080.jpg 07. 视频format转换 YUV -&gt; RGB ffmpeg -s 360x270 -pix_fmt yuv420p -i  2_test_360x270_50.yuv -pix_fmt rgb24  aaaa.rgb ffmpeg -s 640x480 -pix_fmt nv12 -i 640x480_1.jpg -vf scale=640:480,setsar=1:1 640x480_1_nv12.yuv -hide_banner 08. 视频叠加 ffmpeg -i input1 -i input2 -filter_complex overlay=x:y output 09. 视频旋转 //mp4向左旋转90度 ffmpeg -i input.mp4 -metadata:s:v rotate=”90” -codec copy outut.mp4 //mp4向右旋转90度 ffmpeg -i input.mp4 -metadata:s:v rotate=”-90” -codec copy outut.mp4 10. 视频镜像 //mp4左右镜像翻转 ffmpeg -i input.mp4 -vf \"hflip\" outut.mp4 //mp4上下镜像翻转 ffmpeg -i input.mp4 -vf \"vflip\" outut.mp4 10. 图片旋转 //图片向右旋转90度 ffmpeg -i input.png -vf rotate='90*PI/180' -y rotate60.png //图片向右旋转90度 ffmpeg -i input.png -vf rotate='-90*PI/180' -y rotate_90.png //图片像左旋转90度 ffmpeg -i input.png -vf transpose=2 -y transpose2.png //图片像右旋转90度 ffmpeg -i input.png -vf transpose=1 -y transpose2.png //逆时针(向左)旋转90°，然后垂直（上下）翻转 ffmpeg -i input.png -vf transpose=0 -y transpose0.png 11. 图片镜像 //图片左右镜像翻转 ffmpeg -i input.png -vf hflip -y hflip.png //图片上下镜像翻转 ffmpeg -i input.png -vf vflip -y vflip.png //yuv数据左右镜像翻转 ffmpeg -s 1920x1080 -pix_fmt nv12 -i nv12_1.yuv -vf hflip -y hflip_nv12.yuv //播放左右翻转后的yuv数据 ffplay -video_size 1920x1080 -pixel_format nv12 hflip_nv12.yuv 12. 音频音量调节大小 //音量翻倍，写在滤镜里 ffmpeg -i input.wav -af volume=2 -y output.wav //音量翻倍，不写在滤镜中 ffmpeg -i input.wav -vol 2000 -y output.wav 13. 调节播放速度 ffmpeg -i test1.mp4 -vf \"setpts=0.25*PTS\" test2.mp4 四倍慢速： ffmpeg -i test1.mp4 -vf \"setpts=4*PTS\" test2.mp4"
  },"/blog/jekyll/2021-04-27-Weston.html": {
    "title": "weston",
    "keywords": "Jekyll",
    "url": "/blog/jekyll/2021-04-27-Weston.html",
    "body": "一. 启动Weston 1.1 实现内容 解析cmdline 初始化log系统 创建wl_display对象，并侦听client接入 创建weston_compositor对象，从而创建global resource compositor 和 shm， 以前其他资源 load backend， 默认为drm_backend, 在drm_backend初始化的过程中会load gl_renderer load shell, 默认为desktop-shell.so 调用wl_display_run( ) 循环等待event的发生 1.2 伪代码 int wet_main(int argc, char *argv[], const struct weston_testsuite_data *test_data){ // 初始化 layoutput_list wl_list_init(&amp;wet.layoutput_list); ... // parse command line ... // init log system ... // 调用wayland提供的函数wl_display_create() // 创建 wl_display 对象 display = wl_display_create(); ... // 创建 weston_compositor 对象 // --&gt; 创建 global resource compositor and shm 以及其他resource weston_compositor_create( ); // 读取config for compositor ... // load backend，通用的为load_drm_backend( ) // 最终调用 对应backend实现的weston_backend_init( ) // 在backend 初始化的过程中会装载 gl_renderer load_backend(compositor, backend) ... // 创建socket， 侦听client的连接请求 weston_create_listening_socket(display, socket_name) ... // load shell, 默认为 desktop-shell.so wet_load_shell(compositor, shell, ...) ... // loop, 循环等待event的发生 wl_display_run(display) ... // 退出流程，资源的释放 } 1.3 backend, renderer, shell的作用 结构图 ![[image-20230209140244854.png]] backend {    destroy()    repaint_begin()     //composite之前调用    repaint_cancel()   // 中途取消    repaint_flush()     // composite 完成后调用， 可用于实现提交到display    create_output()    // 创建weston_output    device_changed()    can_scanout_dmabuf() }Weston_backend, Compositor-&gt;backend renderer: renderer接口供backend内部使用，外部通过调用backend接口触发 { display_create() output_window_create() output_pbuffer_create() output_destroy() output_set_border() create_fence_fd() } gl_renderer_interface 二. Client 动作 2.1 Client的接入和global资源代理的创建 流程 连接display 获得registry，注册listener，用于处理weston资源变化时的callback 根据资源变化的callback， 创建各类资源的proxy 进入loop，不断调用wl_display_dispatch( )，使得wayland内部循环处理各类event 伪代码 static void global_resource_found(void* data, struct wl_registry* registry, uint32_t name, const char* interface, uint32_t version) { // 通过字符串interface 判断是什么resource， // 通过wl_registry_bind() 创建对应的 resource proxy if (strcmp(interface, \"wl_compositor\") == 0) { // 构建了 compositor 的 proxy compositor = wl_registry_bind(registry, name, &amp;wl_compositor_interface, 4)); }else if (strcmp(interface, \"wl_shm\") == 0) { // 构建了 shm 的proxy shm = wl_registry_bind(registry, name, &amp;wl_shm_interface, 1); } ... } // 当weston的global resoure发生变化时，通过如下回调函数通知到client wl_registry_listener registry_listener = { // 发现新global resource的回调函数 global_resource_found, // global resource remove的回调函数 global_resource_remove } int main(int argc, char** argv) { // 1. 调用wayland提供的 wl_display_connect( ), 连接到weston( wayland server) // 对应到weston启动中的weston_create_listening_socket() display = wl_display_connect(NULL); ... // 2. 获取 wl_registry, 并侦听它的callback registry= wl_display_get_registry(display); wl_registry_add_listener(registry, &amp;registry_listener, display); ... // 3. 循环等待， // 调用wl_display_dispatch( )，由wayland处理weston发来的event while(ret != -1){ ret = wl_display_dispatch( ); } } 2.2 内部weston - client 通讯机制 ==request==: Client –&gt; Server ==event== : Server –&gt; Client 术语上，Wayland 中把 Client 发给 Server 的跨进程函数调用称为 request，反方向的跨进程函数调用称为 event。 本质上，它们处理的方式是类似的。 要让两个进程通过 socket 进行函数调用，首先需要将调用抽象成数据流的形式。这个数据流应该包含函数名、参数等信息。 RPC 函数的接口定义是应该同时包含在 Client 和 Server 端的库中的，其中包含了接口对象所支持的 request 和 event 的函数签名。因此这部分不用传输，只要传输目标对象 id，方法 id 和参数列表这些信息就可以了。 这些信息会通过 wl_closure_marshal()写入 wl_closure 结构，再由 serialize_closure()变成数据流。 等到了目标进程后， 会从数据流通过 wl_connection_demarshal()转回 wl_closure。 RPC 图示 ![[image-20230210145327279.png]] object RPC 机制 这个过程类似于 Android 中的 Parcel 机制。那么 问题来了，参数中的整形，字符串什么的都好搞，拷贝就行。但如果参数中包含对象，我们不能把整个对象 拷贝过去，也不能传引用过去。那么需要一种机制来作同一对象在 Server 和 Client 端的映射，这是通过 wl_map 实现的。 wl_map 在 Client 和 Server 端各有一个，它们分别存了 wl_proxy 和 wl_resource 的数组，且是 一一对应的。这些对象在这个数组中的索引作为它们的 id。这样，参数中的对象只要传 id，这个 id 被传到目 的地后会通过查找这个 wl_map 表来得到本地相应的对象。在功能上类似于 Android 中的 BpXXX 和 BnXXX。 wl_proxy 和 wl_resource 都包含 wl_object 对象。这个 wl_object 和面向对象语言里的对象概念类似，它有 interface 成员描述了这个对象所实现的接口，implementation 是这些接口的实现函数的函数指针数组，id 就是 在 wl_map 结构里数组中的索引。 前面所说的 Client 绑定 Server 端资源的过程就是在 Client 端创建 wl_proxy， 在 Server 端创建 wl_resource。然后 Client 就可以通过 wl_proxy 调用 Server 端对应 wl_resource 的 request， Server 端就可以通过 wl_resource 调用 Client 端对应 wl_proxy 的 event。 这个映射过程如下图所示(以 wl_registry 为例) 2.3 Client 创建各类资源proxy 主要资源proxy // wl_surface wl_surface = wl_compositor_create_surface(compositor) // wl_buffer wl_shm_pool = wl_shm_create_pool( ) wl_buffer = wl_shm_pool_create_buffer( ) // attach buffer to surface wl_surface_attach(wl_surface, wl_buffer) /* 以下与窗口的管理\\显示相关 */ // xdg_surface // xdg_wm_base 它也是一个global resouce，对应到 desktop-shell xdg_surface = xdg_wm_base_get_xdg_surface(xdg_wm_base, wl_surface) // xdg_toplevel xdg_toplevel = xdg_surface_get_toplevel(xdg_toplevel) // wl_keyboard // wl_seat 是一个global resource // 通过wl_keyboard 创建一个listener就可接收按键 wl_keyboard = wl_seat_get_keyboard(wl_seat) wl_keyboard_add_listener(wl_keyboard, keyboard_listener) // wl_pointer 鼠标指针 // 通过wl_pointer 创建一个listener可以接收鼠标的移动信息 wl_pointre = wl_seat_get_pointer(wl_weat) wl_pointer_add_listener（wl_pointer, pointer_listener) ... ... 2.4 Client 渲染 伪代码 simple-egl.c /*-------------------- egl 初始化工作 ------------------------*/ // egl lib 应该要支持wayland。 // 这样在调用一些egl接口时，在其内部会调用wayland接口与Wayland server交换信息 // 如函数：eglGetDisplay( ) , eglCreateWindowSurface( )， eglSwapBuffers 等 // 1. 获取egl_display egl_display = weston_platform_get_egl_display(EGL_PLATFORM_WAYLAND_KHR, wl_display, ...) or egl_display = eglGetDisplay(wl_display) // 2. 初始化 egl eglInitialize(egl_display) // 3. 通用elg 配置 eglGetConfigs() eglChooseConfig( ) eglCreateContext( ) /* ----------------------gl 准备工作------------------------------*/ // 1.创建 shader glCreateShader( ) // 2.创建 Program glCreateProgram( ) // 3. attach shader to program glAttachShader( ) // 4. Link program glLinkProgram( ) // 5. 使用program glUseProgram( ) /*-------------------------wl_surface 关联egl_surface----------------*/ wl_egl_window-&gt;surface = wl_surface; wl_egl_window-&gt;width = width; wl_egl_window-&gt;height = height; eglCreateWindowSurface(egl_display, ... , wl_egl_window) /*------------------------------------------------------------------*/ gl 绘制图形 /*-------------------------------------------------------------------*/ // 内部实现应该调用wayland接口来swap buffer eglSwapBuffers(egl_display, egl_surface) ... 2.5. Client 提交渲染好的surface 提交函数 wl_surface_commit( ) 三. Weston 合成各个App的surface并呈现 流程 compositor遍历每个weston_output 发起repaint。weston_output_schedule_repaint( ) 通知weston_output具体实现–backend_output, 开始repaint的前期准备工作, 对应函数start_repaint_loop( )， drm实现暂无内容 backend_output通知compositor可以开始output repaint compositor 调用weston_output相关backend的repaint_begin( )，drm_backend 创建了pending_state compoistor 调用weston_output_repaint(), 开始repaint。 调用weston_compositor_build_view_list( ) 构建view_list, 得到output的一个paint_node_z_order_list 调用drm_backend assign_planes( ) 设置输出plane 调用drm_backend drm_output_repaint( ), 最终指向gl_renderer_repaint_output( ) 依据paint_node_z_order_list, OpenGL依次建立shader，texture等进行渲染 全部完成后，提交呈现 sequenceDiagram participant C as Compositor participant O as Weston_output participant B as Backend loop 遍历weston_output_list C -&gt;&gt; O: 要开始repaint_loop &lt;br /&gt;call backend_output start_repaint_loop( ) C -&gt;&gt; B: repaint_begin( ) Note right of B: 创建 pending_state C -&gt;&gt; O: 通知output repaint O -&gt;&gt; C: 构建view_list, build_view_list( ) Note left of C:构建paint_node_z_order_list C -&gt;&gt; B: assign_planes( ),设置输出plane C -&gt;&gt; B: drm_output_repaint( ) Note right of B: 调用OpenGL API &lt;br/&gt;结合paint_node_z_order_list&lt;br/&gt;进行渲染 end"
  },"/blog/jekyll/2018-04-27-test.html": {
    "title": "only test",
    "keywords": "Jekyll",
    "url": "/blog/jekyll/2018-04-27-test.html",
    "body": "only for test new txt"
  },"/blog/jekyll/2018-02-27-interrupte.html": {
    "title": "硬中断",
    "keywords": "Jekyll",
    "url": "/blog/jekyll/2018-02-27-interrupte.html",
    "body": "本来想写内核如何接收一个网络包这个过程，但发现把整个过程捋顺了，还是很难的。 推导整个过程的起点是中断，包括硬中断和软中断。 而这个过程要是讲清楚吧，感觉在整个网络包接收原理的大流程中有点喧宾夺主。但要是一笔带过吧，那对于这块有困惑的人就很难受，一切的起点没整明白在心里总是个疙瘩。所以，单拎出来一个主题中断，给大家把这个问题搞明白了。 另外，整个操作系统就是一个中断驱动的死循环，操作系统原理如果用一行代码解释，下面这样再合适不过了。 while(true) { doNothing(); } 其他所有事情都是由操作系统提前注册的中断机制和其对应的中断处理函数完成，我们点击一下鼠标，敲击一下键盘，执行一个程序，都是用中断的方式来通知操作系统帮我们处理这些事件，当没有任何需要操作系统处理的事件时，它就乖乖停在死循环里不出来。 所以，中断，非常重要，它也是理解整个操作系统的根基，掌握它，不亏！ 那我们开始吧。 五花八门的中断分类 关于中断的分类，教科书上和网上有很多”标准”答案了，如果你用搜索引擎去寻找答案，可能会找出很多不一样的分类结果。 所以我打算直接在 Intel 手册上找个最官方的标准答案。 在 Intel 手册 Volume 1 Chapter 6.4 Interrupts and Exception 给出。 翻译过来就是，中断可以分为中断和异常，异常又可以分为故障、陷阱、中止。 第一句话有点奇怪，啥叫中断分为中断和异常呢？你看好多文章的时候也是这么写的，不知道你有没有曾疑惑过。 但其实原文的意思准确说是，CPU 提供了两种中断程序执行的机制，中断和异常。第一个中断是个动词，第二个中断才是真正的机制种类。 好吧，我感觉原文也挺奇怪的，但人家就这么叫，没辙。 接下来我只需要翻译一下就好了，再夹杂点自己的解读。 An interrupt is an asynchronous event that is typically triggered by an I/O device. 先说第一个机制中断（interrupt），中断是一个异步事件，通常由 IO 设备触发。比如点击一下鼠标、敲击一下键盘等。 An exception is a synchronous event that is generated when the processor detects one or more predefined conditions while executing an instruction. 再说第二个机制异常（exception），异常是一个同步事件，是 CPU 在执行指令时检测到的反常条件。比如除法异常、错误指令异常，缺页异常等。 这两个机制，殊途同归，都是让 CPU 收到一个中断号，至于 CPU 收到这个中断号之后干嘛，我们暂且不管。 我们先看看收到中断号之前，具体就是中断和异常到底是怎么做到给 CPU 一个中断号的。 先说中断，别眨眼。 有一个设备叫做可编程中断控制器，它有很多的 IRQ 引脚线，接入了一堆能发出中断请求的硬件设备，当这些硬件设备给 IRQ 引脚线发一个信号时，由于可编程中断控制器提前被设置好了 IRQ 与中断号的对应关系，所以就转化成了对应的中断号，把这个中断号存储在自己的一个端口上，然后给 CPU 的 INTR 引脚发送一个信号，CPU 收到 INTR 引脚信号后去刚刚的那个端口读取到这个中断号的值。 估计你被绕晕了，但读我的文章有个好处，太复杂就上动图，来吧。 ![[image-20230320094930185.png]] 你看，最终的目标，就是让 CPU 知道，有中断了，并且也知道中断号是多少。 比如上图中按下了键盘，最终到 CPU 那里的反应就是，得到了一个中断号 0x21。 那异常的机制就更简单了，是 CPU 自己执行指令时检测到的一些反常情况，然后自己给自己一个中断号即可，无需外界给。 比如 CPU 执行到了一个无效的指令，则自己给自己一个中断号 0x06，这个中断号是 Intel 的 CPU 提前就规定好写死了的硬布线逻辑。 好了，到目前为止，我们知道了无论是中断还是异常，最终都是通过各种方式，让 CPU 得到一个中断号。只不过中断是通过外部设备给 CPU 的 INTR 引脚发信号，异常是 CPU 自己执行指令的时候发现特殊情况触发的，自己给自己一个中断号。 还有一种方式可以给到 CPU 一个中断号，但 Intel 手册写在了后面，Chapter 6.4.4 INT n，就是大名鼎鼎的 INT 指令。 ![[image-20230320095004648.png]] INT 指令后面跟一个数字，就相当于直接用指令的形式，告诉 CPU 一个中断号。 比如 INT 0x80，就是告诉 CPU 中断号是 0x80。Linux 内核提供的系统调用，就是用了 INT 0x80 这种指令。 那我们上面的图又丰富了起来。 ![[image-20230320095040034.png]] 有的地方喜欢把他们做一些区分，把 INT n 这种方式叫做软件中断，因为他是由软件程序主动触发的。相应的把上面的中断和异常叫做硬件中断，因为他们都是硬件自动触发的。 但我觉得大可不必，一共就这么几个分类，干嘛还要增加一层理解的成本呢，记三个方式不好么？ 好了，总结一下，给 CPU 一个中断号有三种方式，而这也是中断分类的依据。 1. 通过中断控制器给 CPU 的 INTR 引脚发送信号，并且允许 CPU 从中断控制器的一个端口上读取中断号，比如按下键盘的一个按键，最终会给到 CPU 一个 0x21 中断号。 2. CPU 执行某条指令发现了异常，会自己触发并给自己一个中断号，比如执行到了无效指令，CPU 会给自己一个 0x06 的中断号。 3. 执行 INT n 指令，会直接给 CPU 一个中断号 n，比如触发了 Linux 的系统调用，实际上就是执行了 INT 0x80 指令，那么 CPU 收到的就是一个 0x80 中断号。 再往后，CPU 以各种不同的方式收到的这些 0x21 0x06 0x80，都会一视同仁，做同样的后续处理流程，所以从现在开始，前面的事情就不用再管了，这也体现了分层的好处。 收到中断号之后 CPU 干嘛？ 那 CPU 收到中断号后，如何处理呢？ 先用一句不太准确的话总结，CPU 收到一个中断号 n 后，会去中断向量表中寻找第 n 个中断描述符，从中断描述符中找到中断处理程序的地址，然后跳过去执行。 为什么说不准确呢？因为从中断描述符中找到的，并不直接是程序的地址，而是段选择子和段内偏移地址。然后段选择子又会去全局描述符表中寻找段描述符，从中取出段基址。之后段基址 + 段内偏移地址，才是最终处理程序的入口地址。 当然这个入口地址，还不是最终的物理地址，如果开启了分页，又要经历分页机制的转换，就像下面这样。 不过不要担心，这不是中断的主流程，因为分段机制和分页机制是所有地址转换过程的必经之路，并不是中断这个流程所特有的。 所以我们简单的把中断描述符表中存储的地址，直接当做 CPU 可以跳过去执行的中断处理程序的入口地址，就好了，不影响理解他们。 你看，这是不是简单很多。 那接下来的问题就很简单了，这里出现了两个名词，那就分别对他们进行发问。 1. 中断描述符表是啥？ 2. 中断描述符是啥？ 3. 去哪里找他们？ 分别回答即可 中断描述符表是啥？ 就是一个在内存中的数组而已，操作系统初始化过程中，有很多结构都称之为 XXX 表，其实就是个数组罢了。 以 linux-2.6.0 源码为例，就很直观了。 struct desc_struct idt_table[256] = { {0, 0}, }; 你看，是一个大小为 256 的数组。idt_table 这个名字就是 Interrupt Descriptor Table，逐字翻译过来确实就是中断描述符表。 中断描述符是啥？ 就是中断描述符表这个数组里的存储的数据结构，通过刚刚的源码也可以看出来，是一个叫 desc_struct 的结构。 struct desc_struct {    unsigned long a,b;}; 好家伙，Linux 源码里就这么简单粗暴表示，一个中断描述符的大小为 64 位，也就是 8 个字节，具体里面存的啥通过这个源码看不出来。 翻一下 Intel 手册，在 Volumn 3 Chapter 5.11 IDT Descriptors 中找到了一张图。 可以看到，中断描述符具体还分成好几个种类，有： Task Gate：任务门描述符 Interrupt Gate：中断门描述符 Trap Gate：陷阱门描述符 不要慌，其中任务门描述符 Linux 中几乎没有用到。 中断门描述符和陷阱门描述符的区别仅仅是是否允许中断嵌套，实现方式非常简单粗暴，就是 CPU 如果收到的中断号对应的是一个中断门描述符，就修改 IF 标志位（就是一个寄存器中一位的值），修改了这个值后就屏蔽了中断，也就防止了中断的嵌套。而陷阱门没有改这个标志位，也就允许了中断的嵌套。 所以简单理解的话，你把他们当做同样一个描述符就好了，先别管这些细节，他们的结构几乎完全一样，只是差了一个类型标识罢了。 那这个中断描述符的结构长什么样呢？我们可以清晰地看到，里面有段选择子和段内偏移地址。 回顾下刚刚说的中断处理流程。 没骗你吧。 但以上这些如果你都搞不明白，还是那句话，记这个最简单的流程就好了，不影响理解。 好了，现在我们直观地看到了中断描述符表这个 256 大小的数组，以及它里面存的中断描述符长什么样子，最终的目的，还是帮助 CPU 找到一个程序的入口地址，然后跳转过去。 OK，下一个问题，就是 CPU 怎么寻找到这个中断描述符表的位置呢？它是在内存中一个固定的位置么？ CPU 怎么找到中断描述符表 答案是否定的，中断描述符表在哪里，全凭各个操作系统的喜好，想放在哪里就放在哪里，但需要通过某种方式告诉 CPU，即可。 怎么告诉呢？CPU 提前预留了一个寄存器叫 IDTR 寄存器，这里面存放的就是中断描述符表的起始地址，以及中断描述符表的大小。 在 Volumn 3 Chapter 5.10 Interrupt Descriptor Table 中告诉了我们 IDTR 寄存器的结构。 操作系统的代码可以通过 LIDT 指令，将中断描述符表的地址放在这个寄存器里。 还记得刚刚看的源码么？中断描述符表就是这个。 struct desc_struct idt_table[256] = { {0, 0}, }; 然后操作系统把这个的地址用 LIDT 指令放在 IDTR 寄存器就行了。IDTR 寄存器里的值一共 48 位，前 16 位是中断描述符表大小（字节数），后 32 位是中断描述符表的起始内存地址，就是这个 idt_table 的位置。 Linux-2.6.0 源码中是这样构造这个结构的，简单粗暴。 idt_descr:    .word 256 * 8 - 1    .long idt_table 紧接着，一个 LIDT 指令把这个结构放到 IDTR 寄存器中。 lidt idt_descr 整个过程一气呵成，呵得我连代码格式都懒得调了，是不是很清晰明了。 这样，CPU 收到一个中断号后，中断描述符表的起始位置从 IDTR 寄存器中可以知道，而且里面的每个中断描述符都是 64 位大小，也就是 8 个字节，那自然就可以找到这个中断号对应的中断描述符。 接下来的问题就是，这个中断描述符表是谁来提前写好的？又是怎么写的？ 谁把中断描述符表这个结构写在内存的 很简单，操作系统呗。 在 Linux-2.6.0 内核源码的 traps.c 文件中，有这样一段代码。 void __init trap_init(void) {    set_trap_gate(0, &amp;divide_error);    ...    set_trap_gate(6, &amp;invalid_op);    ...    set_intr_gate(14, &amp;page_fault);    ...    set_system_gate(0x80, &amp;system_call);} 你看，我们刚刚提到的除法异常、非法指令异常、缺页异常，以及之后可能通过 INT 0x80 触发系统调用的中断处理函数 system_call，就是这样被写到了中断描述符表里。 经过这样一番操作后，我们的中断描述符表里的值就丰富了起来。 好了，现在只剩下最后一个问题了，CPU 在找到一个中断描述符后，如何跳过去执行？ 找到中断描述符后，干嘛 现在这个问题可以再问得大一些了，就是 CPU 在收到一个中断号并且找到了中断描述符之后，究竟做了哪些事？ 当然，最简单的办法就是，直接把中断描述符里的中断程序地址取出来，放在自己的 CS:IP 寄存器中，因为这里存的值就是下一跳指令的地址，只要放进去了，到下一个 CPU 指令周期时，就会去那里继续执行了。 但 CPU 并没有这样简单粗暴，而是帮助我们程序员做了好多额外的事情，这增加了我们的学习和理解成本，但方便了写操作系统的程序员，拿到一些中断的信息，以及中断程序结束后的返回工作。 但其实，就是做了一些压栈操作。 1. 如果发生了特权级转移，压入之前的堆栈段寄存器 SS 及栈顶指针 ESP 保存到栈中，并将堆栈切换为 TSS 中的堆栈。 2. 压入标志寄存器 EFLAGS。 3. 压入之前的代码段寄存器 CS 和指令寄存器 EIP，相当于压入返回地址。 4. 如果此中断有错误码的，压入错误码 ERROR_CODE 5. 结束（之后就跳转到中断程序了） 压栈操作结束后，栈就变成了这个样子。 特权级的转移需要切换栈，所以提前将之前的栈指针压入。错误码可以方便中断处理程序做一些工作，如果需要，从栈顶拿到就好了。 抛开这两者不说，剩下的就只有标志寄存器和中断发生前的代码地址，被压入了栈，这很好理解，就是方便中断程序结束后，返回原来的代码嘛~ 具体的压栈工作，以及如何利用这些栈的信息达到结束中断并返回原程序的效果，Intel 手册中也写得很清楚。 Volumn 3A System Programming Guide  Chapter 5.12.1Exception- or Interrupt-Handler Procedures 看下面的话，通过配合 IRET 或 IRETD 指令返回。 由于后续版本的 Linux 自己的玩法比较多，已经不用 Intel 提供的现成指令了，所以这回我们从 Linux-0.11 版源码中寻找答案。 比如除法异常的中断处理函数，在 asm.s 中。 _divide_error: push dword ptr _do_divide_error ;no_error_code: ; xchg [esp],eax ; push ebx push ecx push edx push edi push esi push ebp push ds ; push es push fs push 0 ; lea edx,[esp+44] ; push edx mov edx,10h ; mov ds,dx mov es,dx mov fs,dx call eax ; add esp,8 ; pop fs pop es pop ds pop ebp pop esi pop edi pop edx pop ecx pop ebx pop eax ;// 弹出原来eax 中的内容。 iretd 只看最后一行，确实用了 iretd 指令。 这个指令会依次弹出栈顶的三个元素，把它们分别赋值给 EIP，CS 和 EFLAGS，而栈顶的三个元素，又恰好是 EIP，CS 和 EFLAGS 这样的顺序，你说这巧不巧？ 当然不巧，人家 CPU 执行中断函数前做了压栈操作，然后又提供了 iret 指令做弹栈操作，当然是给你配套使用的！ 你看，中断是如何切到中断处理程序的？就是靠中断描述符表中记录的地址。那中断又如何回到原来的代码继续执行呢？是通过 CPU 帮我们把中断发生前的地址压入了栈中，然后我们程序自己利用他们去返回，当然也可以不返回。 这就是 CPU 和操作系统配合的结果，把中断这个事给解决了。 总结 所以总结起来就是，理解中断，只要回答了这几个问题就好。 如何给 CPU 一个中断号？ 外部设备通过 INTR 引脚，或者 CPU 执行指令的过程中自己触发，或者由软件通过 INT n 指令强行触发。 同样中断也是这样进行分类的。 CPU 收到中断号后如何寻找到中断程序的入口地址？ 通过 IDTR 寄存器找到中断描述符表，通过中断描述符表和中断号定位到中断描述符，取出中断描述符表中存储的程序入口地址。 中断描述符表是谁写的？ 操作系统代码写上去的。 找到程序入口地址之后，CPU 做了什么？ 简单说，实际上做的事情就是压栈，并跳转到入口地址处执行代码。而压栈的目的，就是保护现场（原来的程序地址、原来的程序堆栈、原来的标志位）和传递信息（错误码） 好了，中断讲完了，如果再往后扩大一点点概念，以上说的中断，统统都是硬中断。注意，不叫硬件中断哦。 为什么叫硬中断呢？因为这是 Intel CPU 这个硬件实现的中断机制，注意这里是实现机制，并不是触发机制，因为触发可以通过外部硬件，也可以通过软件的 INT 指令。 那与硬中断对应的还有软中断，这个概念网上好多地方都讲错了，把软中断和 INT 指令这种软件中断混淆了，所以我觉得软件中断最好称其为，由软件触发的中断，而软中断称其为软件实现的中断。 软中断是纯粹由软件实现的一种类似中断的机制，实际上它就是模仿硬件，在内存中有一个地方存储着软中断的标志位，然后由内核的一个线程不断轮询这些标志位，如果有哪个标志位有效，则再去另一个地方寻找这个软中断对应的中断处理程序。 软中断是 Linux 实现中断的下半部的一种非常常见的方式，之后我讲 Linux 内核如何接受网络包这个事情的时候也可以看到，软中断是研究整个过程的一个突破口。 EOF - 推荐阅读  点击标题可跳转 1、10 分钟看懂 Docker 和 K8S 2、这才是中国被卡脖子最严重的软件！ 3、如果让你来设计网络，你会把它弄成啥样？ 看完本文有收获？请分享给更多人 推荐关注「Linux 爱好者」，提升Linux技能 Linux爱好者 点击获取《每天一个Linux命令》系列和精选Linux技术资源。「Linux爱好者」日常分享 Linux/Unix 相关内容，包括：工具资源、使用技巧、课程书籍等。 75篇原创内容 公众号 点赞和在看就是最大的支持❤️ 分享收藏 微信扫一扫 关注该公众号"
  }}
