<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/blog/" rel="alternate" type="text/html" /><updated>2024-04-03T16:40:54+08:00</updated><id>http://localhost:4000/blog/feed.xml</id><title type="html">学习笔记</title><subtitle>Build Jekyll site with the GitBook style.
</subtitle><author><name>kevin_zh</name></author><entry><title type="html">位运算</title><link href="http://localhost:4000/blog/jekyll/2023-04-27-bit.html" rel="alternate" type="text/html" title="位运算" /><published>2023-04-27T00:00:00+08:00</published><updated>2023-04-27T00:00:00+08:00</updated><id>http://localhost:4000/blog/jekyll/bit</id><content type="html" xml:base="http://localhost:4000/blog/jekyll/2023-04-27-bit.html"><![CDATA[<h1 id="1位运算概述">1.位运算概述</h1>

<p>从现代计算机中所有的数据二进制的形式存储在设备中。即 0、1 两种状态，计算机对二进制数据进行的运算(+、-、*、\/)都是叫位运算，即将符号位共同参与运算的运算。</p>

<p>口说无凭，举一个简单的例子来看下 CPU 是如何进行计算的，比如这行代码：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">35</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">47</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
</code></pre></div></div>
<p>计算两个数的和，因为在计算机中都是以二进制来进行运算，所以上面我们所给的 int 变量会在机器内部先转换为二进制在进行相加：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>35:  0 0 1 0 0 0 1 1
47:  0 0 1 0 1 1 1 1
————————————————————
82:  0 1 0 1 0 0 1 0
</code></pre></div></div>

<p>所以，相比在代码中直接使用(<code class="language-plaintext highlighter-rouge">+、-、*、/ </code>)运算符，合理的运用位运算更能显著提高代码在机器上的执行效率。</p>

<h1 id="2位运算概览">2.位运算概览</h1>

<p>![[image-20230313173955848.png]]</p>

<h1 id="3与运算符">3.与运算符&amp;</h1>

<p>定义：参加运算的两个数据，按二进制位进行”与”运算。</p>

<h2 id="31-运算规则">3.1 运算规则：</h2>

<p><code class="language-plaintext highlighter-rouge">0&amp;0=0  0&amp;1=0  1&amp;0=0  1&amp;1=1</code></p>

<p>总结：两位同时为1，结果才为1，否则结果为0。</p>

<p>例如：3&amp;5 即 0000 0011&amp; 0000 0101 = 0000 0001，因此 3&amp;5 的值得1。</p>

<p>注意：负数按补码形式参加按位与运算。</p>

<h2 id="32-与运算符用途">3.2 与运算符用途</h2>

<h3 id="321清零">3.2.1清零</h3>

<p>如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。</p>

<h3 id="322取一个数的指定位">3.2.2取一个数的指定位</h3>

<p>比如取数 X=1010 1110 的低4位，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位与运算（X&amp;Y=0000 1110）即可得到X的指定位。</p>

<h3 id="323判断奇偶">3.2.3判断奇偶</h3>

<p>只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((a \&amp; 1) == 0)代替if (a \% 2 == 0)来判断a是不是偶数。</p>

<h1 id="4-或运算符">4 或运算符|</h1>

<p>定义：参加运算的两个对象，按二进制位进行”或”运算。</p>

<h2 id="41运算规则">4.1运算规则：</h2>

<table>
  <tbody>
    <tr>
      <td>0</td>
      <td>0=0  0</td>
      <td>1=1  1</td>
      <td>0=1  1</td>
      <td>1=1</td>
    </tr>
  </tbody>
</table>

<p>总结：参加运算的两个对象只要有一个为1，其值为1。</p>

<table>
  <tbody>
    <tr>
      <td>例如：3</td>
      <td>5即 0000 0011</td>
      <td>0000 0101 = 0000 0111，因此，3</td>
      <td>5的值得7。　</td>
    </tr>
  </tbody>
</table>

<p>注意：负数按补码形式参加按位或运算。</p>

<h2 id="42或运算的用途">4.2或运算的用途：</h2>

<h3 id="421常用来对一个数据的某些位设置为1">4.2.1常用来对一个数据的某些位设置为1</h3>

<table>
  <tbody>
    <tr>
      <td>比如将数 X=1010 1110 的低4位设置为1，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位或运算（X</td>
      <td>Y=1010 1111）即可得到。</td>
    </tr>
  </tbody>
</table>

<h1 id="5异或运算符">5异或运算符^</h1>

<p>定义：参加运算的两个数据，按二进制位进行”异或”运算。</p>

<h2 id="51-运算规则">5.1 运算规则：</h2>

<p>0^0=0  0^1=1  1^0=1  1^1=0</p>

<p>总结：参加运算的两个对象，如果两个相应位相同为0，相异为1。</p>

<p>异或的几条性质:</p>

<ul>
  <li>1、交换律</li>
  <li>2、结合律 (a^b)^c == a^(b^c)</li>
  <li>3、对于任何数x，都有 x^x=0，x^0=x</li>
  <li>4、自反性: a^b^b=a^0=a;</li>
</ul>

<h2 id="52-异或运算的用途">5.2 异或运算的用途：</h2>

<h3 id="521翻转指定位">5.2.1翻转指定位</h3>

<p>比如将数 X=1010 1110 的低4位进行翻转，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行异或运算（X^Y=1010 0001）即可得到。</p>

<h3 id="522与0相异或值不变">5.2.2与0相异或值不变</h3>

<p>例如：1010 1110 ^ 0000 0000 = 1010 1110</p>

<h3 id="523交换两个数">5.2.3交换两个数</h3>

<pre><code class="language-C">void Swap(int &amp;a, int &amp;b){  
    if (a != b){  
        a ^= b;  
        b ^= a;  
        a ^= b;  
    }  
}  
</code></pre>

<h1 id="6取反运算符">6取反运算符~</h1>

<p>定义：参加运算的一个数据，按二进制进行”取反”运算。</p>

<h2 id="61-运算规则">6.1 运算规则：　</h2>

<p>~1=0
~0=1</p>

<p>总结：对一个二进制数按位取反，即将0变1，1变0。</p>

<h2 id="62-取反运算符的用途">6.2 取反运算符的用途：</h2>

<h3 id="621使一个数的最低位为零">6.2.1使一个数的最低位为零</h3>

<p>使a的最低位为0，可以表示为：a &amp; ~1。~1的值为 1111 1111 1111 1110，再按”与”运算，最低位一定为0。因为” ~”运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。</p>

<h1 id="7左移运算符">7.左移运算符«</h1>

<p>定义：将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。</p>

<p>设 a=1010 1110，a = a« 2 将a的二进制位左移2位、右补0，即得a=1011 1000。</p>

<h2 id="71-1-左移-1位-相当于乘2">7.1 «1 左移 1位 相当于乘2</h2>
<p>若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。</p>

<h1 id="8右移运算符">8右移运算符»</h1>

<p>定义：将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</p>

<p>例如：a=a»2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。</p>

<h2 id="811-右移一位相当于除2">8.1 »1 右移一位相当于除2</h2>
<p>操作数每右移一位，相当于该数除以2。</p>

<h1 id="9复合赋值运算符">9复合赋值运算符</h1>

<p>位运算符与赋值运算符结合，组成新的复合赋值运算符，它们是：</p>

<p>&amp;=        例：a&amp;=b    相当于     a=a&amp;b</p>

<table>
  <tbody>
    <tr>
      <td>=        例：a</td>
      <td>=b    相当于     a=a</td>
      <td>b</td>
    </tr>
  </tbody>
</table>

<p>&gt;&gt;=      例：a»=b   相当于     a=a»b</p>

<p>«=      例：a«=b     相当于      a=a« b</p>

<p>^=        例：a^=b    相当于   a=a^b</p>

<p>运算规则：和前面讲的复合赋值运算符的运算规则相似。</p>

<p>不同长度的数据进行位运算：如果两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算。</p>

<p>以”与运算”为例说明如下：我们知道在C语言中long型占4个字节，int型占2个字节，如果一个long型数据与一个int型数据进行”与运算”，右端对齐后，左边不足的位依下面三种情况补足，</p>

<ul>
  <li>1）如果整型数据为正数，左边补16个0。</li>
  <li>2）如果整型数据为负数，左边补16个1。</li>
  <li>3）如果整形数据为无符号数，左边也补16个0。
如：long a=123；int b=1；计算a&amp; b。</li>
</ul>

<p>如：long a=123；int b=-1；计算a&amp; b。</p>

<p>如：long a=123；unsigned intb=1；计算a &amp; b。</p>]]></content><author><name>kevin_zh</name></author><category term="Jekyll" /><summary type="html"><![CDATA[1.位运算概述]]></summary></entry><entry><title type="html">ffmpeg命令</title><link href="http://localhost:4000/blog/jekyll/2022-04-27-ffmpeg.html" rel="alternate" type="text/html" title="ffmpeg命令" /><published>2022-04-27T00:00:00+08:00</published><updated>2022-04-27T00:00:00+08:00</updated><id>http://localhost:4000/blog/jekyll/ffmpeg</id><content type="html" xml:base="http://localhost:4000/blog/jekyll/2022-04-27-ffmpeg.html"><![CDATA[<h3 id="01-视频分割">01. 视频分割</h3>
<pre><code class="language-cobol">ffmpeg -ss 00:00:00 -i input.mp4 -c copy -t 60 output.mp4
</code></pre>
<p>-ss 表示视频分割的起始时间，-t 表示分割时长，同时也可以用 00:01:00表示</p>

<p>==<em>注意</em>== ：-ss 要放在 -i 之前</p>

<h3 id="02-视频区域裁剪">02. 视频区域裁剪：</h3>
<pre><code class="language-cobol">ffmpeg -i 3.mkv -filter_complex crop=1024:50:0:550 -y 4.mkv  
</code></pre>
<h3 id="03-视频预览">03. 视频预览</h3>
<p>ffplay 3.mkv -vf crop=1024:50:0:550</p>

<h3 id="04-视频放大缩小">04. 视频放大,缩小</h3>
<pre><code class="language-cobol">ffmpeg  -i 2.mp4 -vf "scale=1280:64" 4.mp4
</code></pre>
<p>==scale== =w:h 表示放大后的大小</p>

<h3 id="05-列出所有format">05. 列出所有format</h3>
<p>// list all pix format</p>
<pre><code class="language-cobol">ffmpeg -pix_fmts 
</code></pre>
<h3 id="06-图片转换">06. 图片转换</h3>
<pre><code class="language-cobol">ffmpeg -i temp.jpg -s 1024x680 -pix_fmt yuvj420p 9.yuv
ffmpeg.exe -i agf-dog-1280x960.jpg  -vf scale=1920:1080 agf-dog-1920x1080.jpg
</code></pre>
<h3 id="07-视频format转换">07. 视频format转换</h3>

<p>YUV -&gt; RGB</p>

<pre><code class="language-cobol">ffmpeg -s 360x270 -pix_fmt yuv420p -i  2_test_360x270_50.yuv -pix_fmt rgb24  aaaa.rgb  
</code></pre>
<pre><code class="language-cobol">ffmpeg -s 640x480 -pix_fmt nv12 -i 640x480_1.jpg -vf scale=640:480,setsar=1:1 640x480_1_nv12.yuv -hide_banner  
</code></pre>
<h3 id="08-视频叠加">08. 视频叠加</h3>
<pre><code class="language-cobol"> ffmpeg -i input1 -i input2 -filter_complex overlay=x:y output
</code></pre>
<h3 id="09-视频旋转">09. 视频旋转</h3>

<p>//mp4向左旋转90度
 ffmpeg -i input.mp4 -metadata:s:v rotate=”90” -codec copy outut.mp4</p>

<p>//mp4向右旋转90度
 ffmpeg -i input.mp4 -metadata:s:v rotate=”-90” -codec copy outut.mp4</p>

<h3 id="10-视频镜像">10. 视频镜像</h3>
<p>//mp4左右镜像翻转</p>
<pre><code class="language-cobol"> ffmpeg -i input.mp4 -vf "hflip" outut.mp4
</code></pre>
<p>//mp4上下镜像翻转</p>
<pre><code class="language-cobol"> ffmpeg -i input.mp4 -vf "vflip" outut.mp4
</code></pre>

<h3 id="10-图片旋转">10. 图片旋转</h3>
<p>//图片向右旋转90度</p>
<pre><code class="language-cobol"> ffmpeg -i input.png -vf rotate='90*PI/180' -y rotate60.png
</code></pre>
<p>//图片向右旋转90度</p>
<pre><code class="language-cobol"> ffmpeg -i input.png -vf rotate='-90*PI/180' -y rotate_90.png
</code></pre>
<p>//图片像左旋转90度</p>
<pre><code class="language-cobol"> ffmpeg -i input.png -vf transpose=2 -y transpose2.png
</code></pre>
<p>//图片像右旋转90度</p>
<pre><code class="language-cobol"> ffmpeg -i input.png -vf transpose=1 -y transpose2.png
</code></pre>
<p>//逆时针(向左)旋转90°，然后垂直（上下）翻转</p>
<pre><code class="language-cobol"> ffmpeg -i input.png -vf transpose=0 -y transpose0.png
</code></pre>
<h3 id="11--图片镜像">11.  图片镜像</h3>
<p>//图片左右镜像翻转</p>
<pre><code class="language-cobol"> ffmpeg -i input.png -vf hflip -y hflip.png
</code></pre>
<p>//图片上下镜像翻转</p>
<pre><code class="language-cobol"> ffmpeg -i input.png -vf vflip -y vflip.png
</code></pre>
<p>//yuv数据左右镜像翻转</p>
<pre><code class="language-cobol"> ffmpeg -s 1920x1080 -pix_fmt nv12 -i nv12_1.yuv -vf hflip -y hflip_nv12.yuv
</code></pre>
<p>//播放左右翻转后的yuv数据</p>
<pre><code class="language-cobol"> ffplay -video_size 1920x1080 -pixel_format nv12 hflip_nv12.yuv
</code></pre>

<h3 id="12-音频音量调节大小">12. 音频音量调节大小</h3>
<p>//音量翻倍，写在滤镜里</p>
<pre><code class="language-cobol"> ffmpeg -i input.wav -af volume=2 -y output.wav
</code></pre>
<p>//音量翻倍，不写在滤镜中</p>
<pre><code class="language-cobol">ffmpeg -i input.wav -vol 2000 -y output.wav
</code></pre>
<h3 id="13-调节播放速度">13. 调节播放速度</h3>

<pre><code class="language-cobol">ffmpeg -i test1.mp4 -vf  "setpts=0.25*PTS" test2.mp4
</code></pre>

<p>四倍慢速：</p>

<pre><code class="language-cobol">ffmpeg -i test1.mp4 -vf  "setpts=4*PTS" test2.mp4
</code></pre>]]></content><author><name>Tao He</name></author><category term="Jekyll" /><summary type="html"><![CDATA[01. 视频分割 ffmpeg -ss 00:00:00 -i input.mp4 -c copy -t 60 output.mp4 -ss 表示视频分割的起始时间，-t 表示分割时长，同时也可以用 00:01:00表示]]></summary></entry><entry><title type="html">weston</title><link href="http://localhost:4000/blog/jekyll/2021-04-27-Weston.html" rel="alternate" type="text/html" title="weston" /><published>2021-04-27T00:00:00+08:00</published><updated>2021-04-27T00:00:00+08:00</updated><id>http://localhost:4000/blog/jekyll/Weston</id><content type="html" xml:base="http://localhost:4000/blog/jekyll/2021-04-27-Weston.html"><![CDATA[<h1 id="一-启动weston">一. 启动Weston</h1>

<h2 id="11-实现内容">1.1 实现内容</h2>

<ol>
  <li>解析cmdline</li>
  <li>初始化log系统</li>
  <li>创建wl_display对象，并<strong>侦听client接入</strong></li>
  <li>创建weston_compositor对象，从而创建global resource <strong>compositor</strong> 和 <strong>shm</strong>， 以前其他资源</li>
  <li><strong>load backend</strong>， 默认为drm_backend, 在drm_backend初始化的过程中会<strong>load gl_renderer</strong></li>
  <li><strong>load shell</strong>, 默认为desktop-shell.so</li>
  <li>调用wl_display_run( ) <strong>循环等待event的发生</strong></li>
</ol>

<h2 id="12-伪代码">1.2 伪代码</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">wet_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[],</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">weston_testsuite_data</span> <span class="o">*</span><span class="n">test_data</span><span class="p">){</span>

    <span class="c1">// 初始化 layoutput_list</span>
    <span class="n">wl_list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wet</span><span class="p">.</span><span class="n">layoutput_list</span><span class="p">);</span>
    <span class="p">...</span>
    <span class="c1">//  parse command line</span>
    <span class="p">...</span>
    <span class="c1">//  init log system</span>
    <span class="p">...</span>
    
    <span class="c1">// 调用wayland提供的函数wl_display_create()</span>
    <span class="c1">// 创建 wl_display 对象</span>
    <span class="n">display</span> <span class="o">=</span> <span class="n">wl_display_create</span><span class="p">();</span>
    <span class="p">...</span>
    
    <span class="c1">// 创建 weston_compositor 对象  </span>
    <span class="c1">// --&gt; 创建 global resource compositor and shm 以及其他resource</span>
    <span class="n">weston_compositor_create</span><span class="p">(</span> <span class="p">);</span>    
    <span class="c1">// 读取config for compositor</span>
    <span class="p">...</span>
    
    <span class="c1">// load backend，通用的为load_drm_backend( )</span>
    <span class="c1">// 最终调用 对应backend实现的weston_backend_init( )</span>
    <span class="c1">// 在backend 初始化的过程中会装载 gl_renderer</span>
    <span class="n">load_backend</span><span class="p">(</span><span class="n">compositor</span><span class="p">,</span> <span class="n">backend</span><span class="p">)</span>
    <span class="p">...</span>
    
    <span class="c1">// 创建socket， 侦听client的连接请求</span>
    <span class="n">weston_create_listening_socket</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">socket_name</span><span class="p">)</span>
    <span class="p">...</span>
    <span class="c1">// load shell, 默认为 desktop-shell.so</span>
    <span class="n">wet_load_shell</span><span class="p">(</span><span class="n">compositor</span><span class="p">,</span> <span class="n">shell</span><span class="p">,</span> <span class="p">...)</span>
    <span class="p">...</span>
    <span class="c1">// loop, 循环等待event的发生</span>
    <span class="n">wl_display_run</span><span class="p">(</span><span class="n">display</span><span class="p">)</span>
    <span class="p">...</span>
    <span class="c1">// 退出流程，资源的释放</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="13-backend-renderer-shell的作用">1.3 backend, renderer, shell的作用</h2>

<p>结构图</p>

<p><img src="/blog/assets/wayland/image-20230209140244854.png" alt="image" /></p>

<p>backend</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
 <span class="n">destroy</span><span class="p">()</span>
 <span class="n">repaint_begin</span><span class="p">()</span>   <span class="c1">//composite之前调用</span>
 <span class="n">repaint_cancel</span><span class="p">()</span>  <span class="c1">// 中途取消</span>
 <span class="n">repaint_flush</span><span class="p">()</span>   <span class="c1">// composite 完成后调用， 可用于实现提交到display</span>
 <span class="n">create_output</span><span class="p">()</span>   <span class="c1">// 创建weston_output</span>
 <span class="n">device_changed</span><span class="p">()</span>
 <span class="n">can_scanout_dmabuf</span><span class="p">()</span>
<span class="p">}</span><span class="n">Weston_backend</span><span class="p">,</span> <span class="n">Compositor</span><span class="o">-&gt;</span><span class="n">backend</span>

</code></pre></div></div>

<p>renderer: 
renderer接口供backend内部使用，外部通过调用backend接口触发</p>
<pre><code class="language-C">{
   display_create()
   output_window_create()
   output_pbuffer_create()
   output_destroy()
   output_set_border()
   create_fence_fd()
} gl_renderer_interface
</code></pre>

<h1 id="二-client-动作">二. Client 动作</h1>

<h2 id="21-client的接入和global资源代理的创建">2.1 Client的接入和global资源代理的创建</h2>

<h3 id="流程">流程</h3>
<ol>
  <li>连接display</li>
  <li>获得registry，注册listener，用于处理weston资源变化时的callback</li>
  <li>根据资源变化的callback， 创建各类资源的proxy</li>
  <li>进入loop，不断调用wl_display_dispatch( )，使得wayland内部循环处理各类event</li>
</ol>

<h3 id="伪代码">伪代码</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">global_resource_found</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wl_registry</span><span class="o">*</span> <span class="n">registry</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">interface</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">version</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// 通过字符串interface 判断是什么resource，</span>
    <span class="c1">// 通过wl_registry_bind() 创建对应的 resource proxy</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span> <span class="s">"wl_compositor"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 构建了 compositor 的 proxy    </span>
        <span class="n">compositor</span> <span class="o">=</span> <span class="n">wl_registry_bind</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wl_compositor_interface</span><span class="p">,</span> <span class="mi">4</span><span class="p">));</span>
        
    <span class="p">}</span><span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span> <span class="s">"wl_shm"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 构建了 shm 的proxy</span>
        <span class="n">shm</span> <span class="o">=</span> <span class="n">wl_registry_bind</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wl_shm_interface</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="p">...</span>

<span class="p">}</span>

<span class="c1">// 当weston的global resoure发生变化时，通过如下回调函数通知到client</span>
<span class="n">wl_registry_listener</span> <span class="n">registry_listener</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1">// 发现新global resource的回调函数</span>
    <span class="n">global_resource_found</span><span class="p">,</span>
    <span class="c1">// global resource remove的回调函数</span>
    <span class="n">global_resource_remove</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 1. 调用wayland提供的 wl_display_connect( ), 连接到weston( wayland server)</span>
    <span class="c1">//    对应到weston启动中的weston_create_listening_socket()</span>
    <span class="n">display</span> <span class="o">=</span> <span class="n">wl_display_connect</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="p">...</span>
    
    <span class="c1">// 2. 获取 wl_registry, 并侦听它的callback</span>
    <span class="n">registry</span><span class="o">=</span> <span class="n">wl_display_get_registry</span><span class="p">(</span><span class="n">display</span><span class="p">);</span>
    <span class="n">wl_registry_add_listener</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">registry_listener</span><span class="p">,</span> <span class="n">display</span><span class="p">);</span>
    <span class="p">...</span>
    
    <span class="c1">// 3. 循环等待，</span>
    <span class="c1">//    调用wl_display_dispatch( )，由wayland处理weston发来的event</span>
    <span class="k">while</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">wl_display_dispatch</span><span class="p">(</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="22-内部weston---client-通讯机制">2.2 内部weston - client 通讯机制</h2>

<p><mark>request</mark>:  Client –&gt; Server</p>

<p><mark>event</mark>  :  Server –&gt; Client</p>

<p>术语上，Wayland 中把 Client 发给 Server 的跨进程函数调用称为 request，反方向的跨进程函数调用称为 event。 本质上，它们处理的方式是类似的。</p>

<p>要让两个进程通过 socket 进行函数调用，首先需要将调用抽象成数据流的形式。这个数据流应该包含函数名、参数等信息。</p>

<p>RPC 函数的接口定义是应该同时包含在 Client 和 Server 端的库中的，其中包含了接口对象所支持的 request 和 event 的函数签名。因此这部分不用传输，只要传输目标<strong>对象 id</strong>，<strong>方法 id</strong> 和<strong>参数列表</strong>这些信息就可以了。</p>

<p>这些信息会通过 wl_closure_marshal()写入 wl_closure 结构，再由 serialize_closure()变成数据流。</p>

<p>等到了目标进程后， 会从数据流通过 wl_connection_demarshal()转回 wl_closure。</p>

<h4 id="rpc-图示">RPC 图示</h4>
<p><img src="/blog/assets/wayland/image-20230210145327279.png" alt="image-20230210145327279.png" /></p>

<h4 id="object-rpc-机制">object RPC 机制</h4>

<p>这个过程类似于 Android 中的 Parcel 机制。那么 问题来了，参数中的整形，字符串什么的都好搞，拷贝就行。但如果参数中包含对象，我们不能把整个对象 拷贝过去，也不能传引用过去。那么需要一种机制来作<strong>同一对象在 Server 和 Client 端的映射</strong>，这是通过 wl_map 实现的。</p>

<p>wl_map 在 Client 和 Server 端各有一个，它们分别存了 wl_proxy 和 wl_resource 的数组，且是 一一对应的。这些对象在这个数组中的索引作为它们的 id。这样，参数中的对象只要传 id，这个 id 被传到目 的地后会通过查找这个 wl_map 表来得到本地相应的对象。在功能上类似于 Android 中的 BpXXX 和 BnXXX。</p>

<p>wl_proxy 和 wl_resource 都包含 wl_object 对象。这个 wl_object 和面向对象语言里的对象概念类似，它有 interface 成员描述了这个对象所实现的接口，implementation 是这些接口的实现函数的函数指针数组，id 就是 在 wl_map 结构里数组中的索引。</p>

<p>前面所说的 Client 绑定 Server 端资源的过程就是在 Client 端创建 wl_proxy， 在 Server 端创建 wl_resource。然后 Client 就可以通过 wl_proxy 调用 Server 端对应 wl_resource 的 request， Server 端就可以通过 wl_resource 调用 Client 端对应 wl_proxy 的 event。</p>

<p>这个映射过程如下图所示(以 wl_registry 为例)</p>

<p><img src="/blog/assets/wayland/20141019204223671.png" alt="image" /></p>

<h3 id="23-client-创建各类资源proxy">2.3 Client 创建各类资源proxy</h3>

<h4 id="主要资源proxy">主要资源proxy</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// wl_surface</span>
<span class="n">wl_surface</span> <span class="o">=</span> <span class="n">wl_compositor_create_surface</span><span class="p">(</span><span class="n">compositor</span><span class="p">)</span>

<span class="c1">// wl_buffer</span>
<span class="n">wl_shm_pool</span> <span class="o">=</span> <span class="n">wl_shm_create_pool</span><span class="p">(</span> <span class="p">)</span>
<span class="n">wl_buffer</span> <span class="o">=</span> <span class="n">wl_shm_pool_create_buffer</span><span class="p">(</span> <span class="p">)</span>

<span class="c1">// attach buffer to surface</span>
<span class="n">wl_surface_attach</span><span class="p">(</span><span class="n">wl_surface</span><span class="p">,</span> <span class="n">wl_buffer</span><span class="p">)</span>

<span class="cm">/* 以下与窗口的管理\显示相关 */</span>

<span class="c1">// xdg_surface</span>
<span class="c1">// xdg_wm_base 它也是一个global resouce，对应到 desktop-shell</span>
<span class="n">xdg_surface</span> <span class="o">=</span> <span class="n">xdg_wm_base_get_xdg_surface</span><span class="p">(</span><span class="n">xdg_wm_base</span><span class="p">,</span> <span class="n">wl_surface</span><span class="p">)</span>

<span class="c1">// xdg_toplevel</span>
<span class="n">xdg_toplevel</span> <span class="o">=</span> <span class="n">xdg_surface_get_toplevel</span><span class="p">(</span><span class="n">xdg_toplevel</span><span class="p">)</span>

<span class="c1">// wl_keyboard</span>
<span class="c1">// wl_seat 是一个global resource</span>
<span class="c1">// 通过wl_keyboard 创建一个listener就可接收按键</span>
<span class="n">wl_keyboard</span> <span class="o">=</span> <span class="n">wl_seat_get_keyboard</span><span class="p">(</span><span class="n">wl_seat</span><span class="p">)</span>
<span class="n">wl_keyboard_add_listener</span><span class="p">(</span><span class="n">wl_keyboard</span><span class="p">,</span> <span class="n">keyboard_listener</span><span class="p">)</span>

<span class="c1">// wl_pointer 鼠标指针</span>
<span class="c1">// 通过wl_pointer 创建一个listener可以接收鼠标的移动信息</span>
<span class="n">wl_pointre</span> <span class="o">=</span> <span class="n">wl_seat_get_pointer</span><span class="p">(</span><span class="n">wl_weat</span><span class="p">)</span>
<span class="n">wl_pointer_add_listener</span><span class="err">（</span><span class="n">wl_pointer</span><span class="p">,</span> <span class="n">pointer_listener</span><span class="p">)</span>

<span class="p">...</span> <span class="p">...</span>

</code></pre></div></div>

<h3 id="24-client-渲染">2.4 Client 渲染</h3>

<h4 id="伪代码-1">伪代码</h4>
<p>simple-egl.c</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*-------------------- egl 初始化工作 ------------------------*/</span>

<span class="c1">// egl lib 应该要支持wayland。</span>
<span class="c1">// 这样在调用一些egl接口时，在其内部会调用wayland接口与Wayland server交换信息</span>
<span class="c1">// 如函数：eglGetDisplay( ) , eglCreateWindowSurface( )， eglSwapBuffers 等</span>

<span class="c1">// 1. 获取egl_display</span>
<span class="n">egl_display</span> <span class="o">=</span> <span class="n">weston_platform_get_egl_display</span><span class="p">(</span><span class="n">EGL_PLATFORM_WAYLAND_KHR</span><span class="p">,</span> <span class="n">wl_display</span><span class="p">,</span> <span class="p">...)</span>
<span class="n">or</span>
<span class="n">egl_display</span> <span class="o">=</span> <span class="n">eglGetDisplay</span><span class="p">(</span><span class="n">wl_display</span><span class="p">)</span>

<span class="c1">// 2. 初始化 egl</span>
<span class="n">eglInitialize</span><span class="p">(</span><span class="n">egl_display</span><span class="p">)</span>

<span class="c1">// 3. 通用elg 配置</span>
<span class="n">eglGetConfigs</span><span class="p">()</span>
<span class="n">eglChooseConfig</span><span class="p">(</span> <span class="p">)</span>
<span class="n">eglCreateContext</span><span class="p">(</span> <span class="p">)</span>


<span class="cm">/* ----------------------gl 准备工作------------------------------*/</span>

<span class="c1">// 1.创建 shader</span>
<span class="n">glCreateShader</span><span class="p">(</span> <span class="p">)</span>
<span class="c1">// 2.创建 Program</span>
<span class="n">glCreateProgram</span><span class="p">(</span> <span class="p">)</span>
<span class="c1">// 3. attach shader to program</span>
<span class="n">glAttachShader</span><span class="p">(</span> <span class="p">)</span>
<span class="c1">// 4. Link program</span>
<span class="n">glLinkProgram</span><span class="p">(</span> <span class="p">)</span>
<span class="c1">// 5. 使用program</span>
<span class="n">glUseProgram</span><span class="p">(</span> <span class="p">)</span>

<span class="cm">/*-------------------------wl_surface 关联egl_surface----------------*/</span>
<span class="n">wl_egl_window</span><span class="o">-&gt;</span><span class="n">surface</span> <span class="o">=</span> <span class="n">wl_surface</span><span class="p">;</span>
<span class="n">wl_egl_window</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
<span class="n">wl_egl_window</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span><span class="p">;</span>
<span class="n">eglCreateWindowSurface</span><span class="p">(</span><span class="n">egl_display</span><span class="p">,</span> <span class="p">...</span> <span class="p">,</span> <span class="n">wl_egl_window</span><span class="p">)</span>

<span class="cm">/*------------------------------------------------------------------*/</span>
<span class="n">gl</span> <span class="err">绘制图形</span>
<span class="cm">/*-------------------------------------------------------------------*/</span>

<span class="c1">// 内部实现应该调用wayland接口来swap buffer</span>
<span class="n">eglSwapBuffers</span><span class="p">(</span><span class="n">egl_display</span><span class="p">,</span> <span class="n">egl_surface</span><span class="p">)</span>
<span class="p">...</span>
</code></pre></div></div>

<h3 id="25-client-提交渲染好的surface">2.5. Client 提交渲染好的surface</h3>

<h4 id="提交函数">提交函数</h4>
<p>wl_surface_commit( )</p>

<h1 id="三-weston-合成各个app的surface并呈现">三. Weston 合成各个App的surface并呈现</h1>

<h2 id="流程-1">流程</h2>
<ol>
  <li>compositor遍历每个weston_output 发起repaint。weston_output_schedule_repaint( )</li>
  <li>通知weston_output具体实现–backend_output, 开始repaint的前期准备工作, 对应函数start_repaint_loop( )， drm实现暂无内容</li>
  <li>backend_output通知compositor可以开始output repaint</li>
  <li>compositor 调用weston_output相关backend的repaint_begin( )，drm_backend 创建了pending_state</li>
  <li>compoistor 调用weston_output_repaint(), 开始repaint。
 调用weston_compositor_build_view_list( ) 构建view_list, 得到output的一个paint_node_z_order_list</li>
  <li>调用drm_backend  assign_planes( ) 设置输出plane</li>
  <li>调用drm_backend  drm_output_repaint( ), 最终指向gl_renderer_repaint_output( )</li>
  <li>依据paint_node_z_order_list, OpenGL依次建立shader，texture等进行渲染</li>
  <li>全部完成后，提交呈现</li>
</ol>

<pre><code class="language-mermaid">sequenceDiagram
participant C as Compositor
participant O as Weston_output
participant B as Backend

loop 遍历weston_output_list
    C -&gt;&gt; O: 要开始repaint_loop &lt;br /&gt;call backend_output start_repaint_loop( )    
    C -&gt;&gt; B: repaint_begin( )
    Note right of B: 创建 pending_state
    C -&gt;&gt; O: 通知output repaint
    O -&gt;&gt; C: 构建view_list, build_view_list( )
    Note left of C:构建paint_node_z_order_list

    C -&gt;&gt; B: assign_planes( ),设置输出plane
    C -&gt;&gt; B: drm_output_repaint( )
    Note right of B: 调用OpenGL API &lt;br/&gt;结合paint_node_z_order_list&lt;br/&gt;进行渲染
end
</code></pre>]]></content><author><name>Tao He</name></author><category term="Jekyll" /><summary type="html"><![CDATA[一. 启动Weston]]></summary></entry><entry><title type="html">Wayland</title><link href="http://localhost:4000/blog/jekyll/2020-03-15-Wayland.html" rel="alternate" type="text/html" title="Wayland" /><published>2020-03-15T00:00:00+08:00</published><updated>2020-03-15T00:00:00+08:00</updated><id>http://localhost:4000/blog/jekyll/Wayland</id><content type="html" xml:base="http://localhost:4000/blog/jekyll/2020-03-15-Wayland.html"><![CDATA[<h1 id="编译">编译</h1>

<h2 id="wayland编译">Wayland编译</h2>

<ul>
  <li>预设环境</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$export</span> <span class="nv">WLD</span><span class="o">=</span>“~/xxxxxxxxx”  //定义一个wayland目录，编译生成到这里
apt <span class="nb">install </span>meson
apt <span class="nb">install </span>some_depenced_libs
</code></pre></div></div>

<ul>
  <li>Wayland</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git clone https://gitlab.freedesktop.org/wayland/wayland.git 
<span class="nv">$ </span><span class="nb">cd </span>wayland 
<span class="nv">$ </span>meson build/ <span class="nt">--prefix</span><span class="o">=</span><span class="nv">$WLD</span> 
<span class="nv">$ </span>ninja <span class="nt">-C</span> build/ <span class="nb">install</span> 
<span class="nv">$ </span><span class="nb">cd</span> .. 
</code></pre></div></div>

<ul>
  <li>Wayland protocols</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git clone https://gitlab.freedesktop.org/wayland/wayland-protocols.git
<span class="nv">$ </span><span class="nb">cd </span>wayland-protocols
<span class="nv">$ </span>meson build/ <span class="nt">--prefix</span><span class="o">=</span><span class="nv">$WLD</span>
<span class="nv">$ </span>ninja <span class="nt">-C</span> build/ <span class="nb">install</span>
<span class="nv">$ </span><span class="nb">cd</span> ..
</code></pre></div></div>

<ul>
  <li>Weston</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git clone https://gitlab.freedesktop.org/wayland/weston.git
<span class="nv">$ </span><span class="nb">cd </span>weston
<span class="nv">$ </span>meson build/ <span class="nt">--prefix</span><span class="o">=</span><span class="nv">$WLD</span>
<span class="nv">$ </span>ninja <span class="nt">-C</span> build/ <span class="nb">install</span>
<span class="nv">$ </span><span class="nb">cd</span> ..
</code></pre></div></div>

<ul>
  <li>
    <p>第三方依赖库的编译</p>

    <p>需要的第三方库</p>
  </li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Libxml2-dev
Libexpat-dev
Libffi-dev
Libinput-dev
Libdrm-dev
Libxkbcommon-dev
libpixman-1-dev
libcairo2-dev
libudev
</code></pre></div></div>
<p>它们可能通过configure 配置然后make， 也可能通过mesa ninja编译.  需要注意设置正确的PKG_CONFIG_PATH，使的pkg-config可以找到相关的库信息。
如果是mesa，留意目录下是否有meson_options.txt, 其中就定义了编译选项，可对它进行修改。</p>

<ul>
  <li>meson</li>
</ul>

<p><strong>交叉编译</strong></p>

<p>在meson系统中进行交叉编译，需要为meson中添加参数 <code class="language-plaintext highlighter-rouge">–cross-file  xxx_filename</code>, 在xxx_filename中定义gcc等的路径路径</p>

<p>下面是一个示例</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>binaries]
c <span class="o">=</span> <span class="s1">'/opt/cross-arm/bin/arm-linux-gnueabihf-gcc'</span>
cpp <span class="o">=</span> <span class="s1">'/opt/cross-arm/bin/arm-linux-gnueabihf-g++'</span>
ld <span class="o">=</span><span class="s1">'/opt/cross-arm/bin/arm-linux-gnueabihf-ld'</span>
<span class="nv">strip</span><span class="o">=</span> <span class="s1">'/opt/cross-arm/bin/arm-linux-gnueabihf-strip'</span>
pkgconfig <span class="o">=</span><span class="s1">'/usr/bin/pkg-config'</span>

<span class="o">[</span>host_machine]
system <span class="o">=</span> <span class="s1">'linux'</span>
cpu_family <span class="o">=</span> <span class="s1">'aarch64'</span>
cpu <span class="o">=</span> <span class="s1">'cortex-a73'</span>
endian <span class="o">=</span> <span class="s1">'little
</span></code></pre></div></div>
<p>在configure系统中，则是export GCC CFLAG 等环境变量</p>

<p><strong>指定输入输出</strong></p>

<blockquote>
  <p>meson  build_dir/  sourc_code_dir/</p>
</blockquote>

<h1 id="weston的输入管理">weston的输入管理</h1>

<p><strong>libinput</strong></p>

<p>为了提高输入管理部分的模块性，Weston将对输入设备(键盘，鼠标，触摸屏等)的处理分离到一个单独的库，也就是libinput 中。具体地，它提供了<strong>设备检测</strong>，<strong>设备处理</strong>，<strong>输入事件处理</strong>等基本功能，类似于Android 中的EventHub。此外它还有<strong>pointer acceleration</strong>, <strong>touchpad support</strong> 及<strong>gesture recognition</strong>等功能。</p>

<p>libinput更像是一个框架，它将几个更底层的库的功能整合起来。它主要依赖于以下几个库:</p>

<ol>
  <li>mtdev: Multi-touch 设备处理，比如它会将不带tracking ID的protocol A转化为 protocol B。</li>
  <li>libevdev: 与kernel中evdev 模块对接。</li>
  <li>libudev:主要用于和 udevd的通信，从而获取设备的增加删除事件。也可从kernel获取。</li>
</ol>

<p>Weston 中的输入管理模块与libinput对接，它实现了两大部分的功能:</p>

<ul>
  <li>对输入设备的维护，</li>
  <li>对输入事件的处理。</li>
</ul>

<p>对于输入事件既会在Weston中做处理，也会传给相应的 client。</p>

<p>从事件处理模型上来看，libinput主循环监听udev monitor fd，它主要用于监听设备的添加删除事件。如果有设备添加，会打开该设备并把fd加入到libinput的主循环上。另一方面，Weston中会将 libinput 的 epoll fd加入主循环。这样形成级联的epoll，无论是 udev monitor 还是input device的fd有事件来，都会通知到Weston和libinput的主循环。</p>

<p>Weston中支持三种输入设备，分别是键盘，触摸和鼠标。一套输入设备属于一个seat(严格来说，seat中包括一套输入输出设备)。因此，weston_seat 中包含weston_keyboard,weston_pointer 和weston_touch三个结构。系统中可以有多个seat,它们的结构被串在weston_compositor 的 seat_list链表中。</p>

<p>可以看到，对于焦点处理，每个设备有自己的focus,它指向焦点窗口，用于拖拽和输入等。成员focus_resource_list 中包含了焦点窗口所在client中输入设备 proxy对应的 resource 对象。在这个 list 中意味着可以接收到相应的事件。</p>

<h1 id="run-weston">Run Weston</h1>

<ul>
  <li>
    <p>configure file</p>

    <p><code class="language-plaintext highlighter-rouge">copy weston.ini to ~/.config/</code></p>
  </li>
  <li>run weston.
    <ol>
      <li>login as root</li>
      <li>./weston –tty=2</li>
      <li>Ctrl+Alt+Backspace –&gt; 退出Weston界面</li>
    </ol>
  </li>
  <li>run weston-client test
    <ol>
      <li>login as root</li>
      <li>export WAYLAND_DISPLAY=wayland-1</li>
    </ol>
  </li>
</ul>

<p>示例1, 指定backend 和shell</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Server: ./weston <span class="nt">--tty</span><span class="o">=</span>2 <span class="nt">--shell</span><span class="o">=</span>fullscreen-shell.so <span class="nt">--backend</span><span class="o">=</span> drm-backend.so
Client: weston-simple-dmabuf-egl
</code></pre></div></div>

<p>示例2</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Server：./weston <span class="nt">--tty</span><span class="o">=</span>2 <span class="nt">--shell</span><span class="o">=</span>fullscreen-shell.so <span class="nt">--backend</span><span class="o">=</span>fbdev-backend.so
Client./weston-simple-damage
</code></pre></div></div>

<h1 id="wayland-理解">Wayland 理解</h1>

<ul>
  <li>Wayland提供了Protocol的定义方式。</li>
</ul>

<p>在路径protocol文件夹下，以xml的形式定义了Wayland的核心协议。
如wl_display: 用于获取display全局对象。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;interface</span> <span class="na">name=</span><span class="s">"wl_display"</span> <span class="na">version=</span><span class="s">"1"</span><span class="nt">&gt;</span>  
       <span class="nt">&lt;description</span> <span class="na">summary=</span><span class="s">"core global object"</span><span class="nt">&gt;</span>
              The core global object.  This is a special singleton object.  
              It is used for internal Wayland protocol features.   
       <span class="nt">&lt;/description&gt;</span>
    .....
<span class="nt">&lt;/interface&gt;</span>

</code></pre></div></div>

<ul>
  <li>
    <p>wayland源码中，除了协议部分。剩下的主要内容，就是实现了一个高效率的 Server+Client通信模式</p>

    <ul>
      <li>
        <p>Server端，主要是使用epoll+socket监听Client端事件，并对收到的消息反序列化。</p>

        <p><img src="/blog/assets/wayland/server_epoll.png" alt="server_epoll" /></p>
      </li>
      <li>
        <p>Client端：wayland-client提供了已实现的序列化接口</p>

        <p><img src="/blog/assets/wayland/client_epoll.png" alt="client_epoll" /></p>
      </li>
    </ul>
  </li>
</ul>

<p>总结：官方提供的Wayland源码，主要包括协议的定义、协议到代码的生成工具，以及一套实现好的通信模型</p>

<h1 id="wayland-全局对象">wayland 全局对象</h1>

<p>几乎所有的Wayland API都需要Wayland全局对象作为参数。</p>

<table>
  <thead>
    <tr>
      <th>名称</th>
      <th>作用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>wl_display</td>
      <td>表示与服务器的连接。</td>
    </tr>
    <tr>
      <td>wl_registry</td>
      <td>全局对象注册表，全局对象需要通过它获取。</td>
    </tr>
    <tr>
      <td>wl_compositor</td>
      <td>窗口合成器，也是服务器。</td>
    </tr>
    <tr>
      <td>wl_shm</td>
      <td>内存管理器，与窗口合成器共享内存用。</td>
    </tr>
    <tr>
      <td>wl_shell</td>
      <td>支持窗口操作功能。</td>
    </tr>
    <tr>
      <td>wl_seat</td>
      <td>输入设备管理器。</td>
    </tr>
    <tr>
      <td>wl_pointer</td>
      <td>代表鼠标设备。</td>
    </tr>
    <tr>
      <td>wl_keyboard</td>
      <td>代表键盘设备。</td>
    </tr>
  </tbody>
</table>

<p>Wayland没有提供Get函数来获取以上全局对象，只能通过wl_registry获取全局对象</p>

<p><img src="/blog/assets/wayland/weston_object.png" alt="weston_object" /></p>

<p><img src="/blog/assets/wayland/weston_architecture.png" alt="weston_architecture" /></p>

<h3 id="client端global-object-resouce-object-的使用">Client端global object ，Resouce object 的使用</h3>

<p>Wayland 中 server提供给client使用的对象可以归为 global object和 resource object。 Global 也是一中resource。</p>

<p>Global object如 wl_display, wl_compositor, wl_seat 等。 它们在client端是通过bind来获取到一个client 对应对象，然后就可以对它进行操作</p>

<p>Resource object  在client端是通过Global object 来创建的， 如 wl_surface, wl_shell_surface 等。</p>

<p><img src="/blog/assets/wayland/client_object.png" alt="client_object" /></p>

<p>Listener 是server –&gt; client 的通知方式. Client 注册listener 给server，有监听事件发生，server发信息给client.</p>

<p>Server侧发生通知的函数命名特征:   xxxx_send_xxxx( )</p>

<h3 id="server端-global-object-resouce-object-的实现">Server端 global object ，Resouce object 的实现</h3>

<p><strong>Global 资源的创建</strong>：</p>
<ol>
  <li>wl_global_create( ….,  bind_xxx_function )</li>
  <li>bind_xxx_function     // 在client中调用wl_registry_bind函数时被call
    <ul>
      <li>wl_resource_create( )     //  wayland protocal 提供的接口， 登记资源</li>
      <li>wl_resource_set_implementation( )   // 设定资源接口的实现</li>
    </ul>
  </li>
</ol>

<p><strong>普通 Resource 的创建</strong>：<br />
   应该是由某些 对global 资源的操作触发</p>
<ol>
  <li>wl_resource_create()</li>
  <li>wl_resource_set_implementation( )</li>
</ol>

<p><img src="/blog/assets/wayland/object_generation.png" alt="object_generation" /></p>

<p><img src="/blog/assets/wayland/client_server_create_object.png" alt="client_server_create_object" /></p>

<p><img src="/blog/assets/wayland/client_server_create_shell.png" alt="client_server_create_shell" /></p>

<p><img src="/blog/assets/wayland/client_server_create_buffer.png" alt="client_server_create_buffer" /></p>

<p><img src="/blog/assets/wayland/client_server_surface_attach.png" alt="client_server_surface_attach" /></p>

<p><img src="/blog/assets/wayland/client_server_surface_commit.png" alt="client_server_surface_commit" /></p>

<p><img src="/blog/assets/wayland/simple_wayland_app.png" alt="simple_wayland_app" /></p>

<p><img src="/blog/assets/wayland/compositor_create_surface.svg" alt="compositor_create_surface" /></p>

<p><img src="/blog/assets/wayland/create_shm_buffer.svg" alt="create_shm_buffer" /></p>

<h1 id="weston-简介">Weston 简介</h1>

<p>Weston是基于wayland协议，实现的Compositor。</p>

<p>Weston的入口在（这里以10.0.0为例）:</p>

<p>weston-10.0.0./compositor/main.c</p>

<p>weston-10.0.0./compositor/executable.c</p>

<p>实现的基本流程：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">wet_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="c1">// 创建全局Display，并最终调用到wl_os_epoll_create_cloexec</span>
    <span class="n">display</span> <span class="o">=</span> <span class="n">wl_display_create</span><span class="p">();</span>

    <span class="c1">// 创建Compositor</span>
    <span class="n">ec</span> <span class="o">=</span> <span class="n">weston_compositor_create</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">user_data</span><span class="p">);</span>

    <span class="c1">// 创建Shell</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">wet_load_shell</span><span class="p">(</span><span class="n">ec</span><span class="p">,</span> <span class="n">shell</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

    <span class="c1">// while循环</span>
    <span class="n">wl_display_run</span><span class="p">(</span><span class="n">display</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Weston中有四个主要部分：Shell、Compositor、Render、Input</p>

<ul>
  <li>
    <p>Shell：窗口管理器，画面层级、窗口信息、窗口生命周期、Focus窗口等等一些偏向于业务层的处理。默认的shell为desktop-shell，同时提供了其他shell实现（如ivi-shell）</p>
  </li>
  <li>
    <p>Compositor：负责画面的合成，使用DRM连接output，将画面输出到实际显示设备。</p>
  </li>
  <li>
    <p>Render：负责渲染，比如gl-render，做一些纹理贴图操作。</p>
  </li>
  <li>
    <p>Input：libinput模块，与evdev、uvdev模块交互，从底层设备节点接收touch、key等输入</p>
  </li>
</ul>

<h2 id="backend">backend</h2>

<p><img src="/blog/assets/wayland/weston_backend.png" alt="weston_backend" /></p>

<h2 id="shell">shell</h2>

<p><img src="/blog/assets/wayland/weston_shell.png" alt="weston_shell" /></p>

<h2 id="head-and-output">head and output</h2>

<p>weston_head 和 weston_output 是libweston中的两个关键概念，用于管理显示输出和图像呈现。</p>

<p><strong>weston_head（头部）</strong></p>
<ul>
  <li>weston_head 表示一个连接器或监视器。</li>
  <li>在硬件驱动中，头部通常指的是一个显示器，但它也可以是另一个窗口系统中的窗口，或者是一个虚拟概念。</li>
  <li>头部是一个可以呈现图像的位置。</li>
  <li>weston_head 负责以下任务：
    <ul>
      <li>管理帧缓冲区。</li>
      <li>跟踪损坏区域。</li>
      <li>处理显示时序。</li>
      <li>管理重绘状态机。</li>
    </ul>
  </li>
  <li>在显示硬件中，weston_head 表示一个CRTC（显示控制器），但仅在成功启用后才会如此。在头部的生命周期内，CRTC 可能会切换到另一个。</li>
  <li>weston_head 的生命周期由libweston用户控制。</li>
  <li>您可以通过将至少一个weston_head 附加到weston_output 来构建一个可供合成器使用的weston_output 对象，然后使用 weston_output_enable() 启用该输出。已启用的输出无法重新配置，但这在未来可能会发生变化。您可以使用 weston_output_disable() 来禁用一个输出，然后重新配置它，但这会导致可见的故障。</li>
</ul>

<p><strong>weston_output（输出）</strong></p>
<ul>
  <li>weston_output 决定了全局合成器坐标空间的哪一部分将被合成成图像以及何时进行合成。</li>
  <li>该图像在附加的头部上呈现。</li>
  <li>weston_output 负责以下任务：
    <ul>
      <li>帧缓冲区管理。</li>
      <li>损坏区域跟踪。</li>
      <li>显示时序。</li>
      <li>重绘状态机。</li>
      <li>视频模式、输出比例和输出变换是输出的属性。</li>
      <li>在显示硬件中，weston_output 表示一个CRTC，但仅在成功启用后才会如此。CRTC 可能会在输出的生命周期内切换到另一个。</li>
      <li>weston_output 的生命周期由libweston用户控制。</li>
    </ul>
  </li>
</ul>

<p><img src="/blog/assets/wayland/head_output.png" alt="head_output" /></p>

<p>Heads are being created on compositor start-up with a backend that manages head lifetimes completely on its own</p>

<p><img src="/blog/assets/wayland/create_head.png" alt="create_head" /></p>

<p>A compositor handles libweston notification of something with heads having changed. 
This happens on both compositor start-up and later due to hotplug
<img src="/blog/assets/wayland/change_on_head.png" alt="change_on_head" /></p>

<p>A compositor creates and configures an output for a head or heads it wants to light up.</p>

<p><img src="/blog/assets/wayland/create_output.png" alt="create_output" /></p>

<p>A compositor finds out a head has been disconnected and proceeds to destroy the corresponding output.</p>

<p><img src="/blog/assets/wayland/disconnect_head.png" alt="disconnect_head" /></p>

<p>The backend realises that a piece of hardware has disappeared and needs to destroy the corresponding head. 
The head is released, and even when the compositor is not listening for head destroy signal, 
the output gets automatically disabled, though not destroyed.</p>

<p><img src="/blog/assets/wayland/disable_output.png" alt="disable_output" /></p>

<h2 id="weston_backend_init">weston_backend_init</h2>

<p><img src="/blog/assets/wayland/weston_backend_init.svg" alt="weston_backend_init" /></p>

<h1 id="基本流程">基本流程</h1>

<h2 id="创建简单窗口">创建简单窗口</h2>

<p><img src="/blog/assets/wayland/simple_create_window.png" alt="simple_create_window" /></p>

<h2 id="创建egl窗口">创建egl窗口</h2>

<p><img src="/blog/assets/wayland/create_egl_window.png" alt="create_egl_window" /></p>

<h1 id="调用的backtrace">调用的backtrace</h1>

<p><strong>Client eglSwapBuffers</strong></p>

<p>Client App 调用eglSwapBuffers 提交buffer给compositor的堆栈</p>

<p><img src="/blog/assets/wayland/client_eglSwapBuffers.png" alt="client_eglSwapBuffers" /></p>

<p><strong>wl_output global的创建</strong></p>

<p><img src="/blog/assets/wayland/wl_output_create.png" alt="wl_output_create" /></p>

<p><strong>wl_surface_commit</strong></p>

<p>wl_surface_commit() 触发的后继操作</p>

<p><img src="/blog/assets/wayland/wl_surface_commit.png" alt="wl_surface_commit" /></p>

<p><strong>drm_output_repaint()</strong></p>

<p>drm_output_repaint() 的调用栈</p>

<p><img src="/blog/assets/wayland/drm_output_repaint.png" alt="drm_output_repaint" /></p>

<p><strong>repaint_views</strong></p>

<p>repaint_views() 的调用栈</p>

<p><img src="/blog/assets/wayland/repaint_views.png" alt="repaint_views" /></p>

<p><strong>第一次repaint的触发</strong></p>

<p><img src="/blog/assets/wayland/first_repaint.png" alt="first_repaint" /></p>

<p><strong>送显的backtrace</strong></p>

<p><img src="/blog/assets/wayland/shown_on_display.png" alt="shown_on_display" /></p>

<p><strong>weston-desktop-shell</strong></p>

<p><img src="/blog/assets/wayland/weston_desktop_shell.png" alt="weston_desktop_shell" /></p>

<p><strong>Weston_keyboard 进程的创建</strong></p>

<p>在weston.ini中的【input-method】设置 <code class="language-plaintext highlighter-rouge">path= 空</code> 来不创建它, 函数launch_input_method() 会检查<code class="language-plaintext highlighter-rouge">path</code>.</p>

<p><img src="/blog/assets/wayland/keyboard.png" alt="keyboard" /></p>

<p><strong>key的处理</strong>
<img src="/blog/assets/wayland/handle_key.png" alt="handle_key" /></p>

<h1 id="weston-event-loop">weston event loop</h1>

<p><img src="/blog/assets/wayland/weston_event_loop.png" alt="weston_event_loop" /></p>

<h1 id="weston-idle-处理">weston idle 处理</h1>

<p><img src="/blog/assets/wayland/weston_idle_handler.png" alt="weston_idle_handler" /></p>

<h1 id="drm-backend">drm-backend</h1>

<p><img src="/blog/assets/wayland/drm_backend.png" alt="drm_backend" /></p>

<h1 id="layer-view-surface">layer, view, surface</h1>

<p><img src="/blog/assets/wayland/layer_view_surface.png" alt="layer_view_surface" /></p>

<h1 id="weston-misc">weston misc</h1>

<p><strong>定时器函数</strong></p>

<ol>
  <li>创建定时器：wl_event_loop_add_timer()</li>
  <li>Enable 定时器：wl_event_source_timer_update( source,  ms_delay)
              // ms_delay ==0  disable</li>
</ol>

<p><strong>wayland signal</strong></p>

<ul>
  <li>wl_signal_add( , ) 添加一个listener到 listerner_list 链表</li>
  <li>wl_signal_emit( , ) 触发一个signal, 从listener_list中调用每个listener notify</li>
</ul>

<p><strong>libwayland-egl.so.xxx</strong></p>
<ol>
  <li>由 wayland-1.20.0/egl下文件编译生成</li>
  <li>主要功能生成/销毁wl_egl_window， 并获取它的大小属性</li>
  <li>使用: client/backend-wayland 可以利用它来生成wl_egl_window,  然后传给eglCreateWindowSurface( )</li>
  <li>示例：./clients/simple-egl.c</li>
  <li>好像不需要再分配buffer attch到 wl_surface,  参考simple-egl-window.c</li>
</ol>

<p><strong>weston_client_start()</strong></p>

<p>在weston里定义， Weston call 它来 发起一个client 进程, 它会调用weston_client_launch()</p>

<p><strong>weston-screenshooter</strong></p>

<p>截屏进程， 被desktop-shell 进程call screenshooter_create( )创建</p>

<p><strong>显示一帧的过程</strong></p>

<ol>
  <li>epoll收到event</li>
  <li>构建compositor View_list， 含有order信息</li>
  <li>backend call gl_renderer set current surface</li>
  <li>依次根据各个view的信息构建纹理，进行渲染</li>
  <li>eglswapbuffer（）</li>
  <li>遍历各个output，完成1～4</li>
  <li>repaint_flash()  -&gt; drm 上屏</li>
</ol>

<p><strong>repaint_timer_triger</strong>
<img src="/blog/assets/wayland/repaint_timer_triger.png" alt="repaint_timer_triger" /></p>

<p><strong>Compositor sleep 相关</strong></p>
<ol>
  <li>In weston.init,  相关配置 idle-time， 单位sec</li>
  <li>在函数weston_compositor_wake()设置 多长时间无操作进入sleep状态</li>
  <li>定时器compositor-&gt;idle_source， 在weston_compositor_create()中创建</li>
  <li>在weston_compositor_offscreen() , weston_compositor_sleep() 中关闭定时器</li>
</ol>

<p><strong>surface与buffer</strong></p>

<ul>
  <li>
    <p>Surface：</p>

    <ul>
      <li>Surface 是 DRM 中的一个概念，用于描述一个可绘制的区域。它是一个抽象的图形表面，可以用于绘制图像、文本或其他内容。</li>
      <li>Surface 可以是屏幕上的一部分，也可以是一个窗口、一个图像或其他可视元素。</li>
      <li>应用程序可以将图形绘制到 Surface 上，然后由 DRM 管理其显示。</li>
      <li>例如，在 DRM 中，一个窗口可以有多个关联的 Surface，每个 Surface 对应一个缓冲区。</li>
    </ul>
  </li>
  <li>Buffer：
    <ul>
      <li>Buffer 是一块内存区域，用于存储像素数据。在 DRM 中，它通常与 Surface 关联。</li>
      <li>Buffer 可以是帧缓冲区、纹理、渲染缓冲区等。</li>
      <li>Buffer 存储着图像的像素值，可以直接访问和操作。</li>
      <li>例如，当应用程序绘制图像时，它将像素数据写入 Buffer，然后由 DRM 将其显示在屏幕上。</li>
    </ul>
  </li>
  <li>总结：</li>
  <li>Surface 是一个抽象的图形表面，用于绘制图像。</li>
  <li>Buffer 是实际存储像素数据的内存区域，与 Surface 关联。</li>
</ul>

<p><strong>drm_virtual_output</strong></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>drm_backend_init_virtual_output_api <span class="o">()</span> &lt;- <span class="c">#ifdef BUILD_DRM_VIRTUAL </span>
                 &lt;- /libweston/backend-drm/meson.build
                     &lt;- remoting or pipewire  <span class="k">in </span>configure

</code></pre></div></div>
<p>drm_virtual_output 用于 remoting or pipewire 场景， 在meson_options.txt 里配置</p>

<p><strong>explicit-synchronization</strong></p>

<p><img src="/blog/assets/wayland/explicit_sync.png" alt="explicit_sync" /></p>

<h1 id="wayland-log">Wayland log</h1>

<p>需设置环境变量： <code class="language-plaintext highlighter-rouge">export WAYLAND_DEBUG=1</code></p>

<p><img src="/blog/assets/wayland/wayland_log.png" alt="wayland_log" /></p>]]></content><author><name>Kevin zhang</name></author><category term="Jekyll" /><summary type="html"><![CDATA[编译]]></summary></entry><entry><title type="html">设备资源管理模块</title><link href="http://localhost:4000/blog/linux/2018-08-01-DeviceResourceManage.html" rel="alternate" type="text/html" title="设备资源管理模块" /><published>2018-08-01T00:00:00+08:00</published><updated>2018-08-01T00:00:00+08:00</updated><id>http://localhost:4000/blog/linux/DeviceResourceManage</id><content type="html" xml:base="http://localhost:4000/blog/linux/2018-08-01-DeviceResourceManage.html"><![CDATA[<h1 id="1解决的问题">1.解决的问题</h1>

<p>相信每一个写过Linux driver的工程师，都在probe函数中遇到过上面的困惑：在顺序申请多种资源（IRQ、Clock、memory、regions、ioremap、dma、等等）的过程中，只要任意一种资源申请失败，就要回滚释放之前申请的所有资源。 于是在函数的最后，就一定会出现很多的goto标签，用于释放不同的资源（如上面的exit_free_irq、exit_free_dma、等等）。 在申请资源出错时，小心翼翼的goto到正确的标签上，以便释放已申请资源。</p>

<p>这样在代码中，整个函数被大段的、重复的如下代码充斥。</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">condition</span><span class="p">)</span> 
<span class="p">{</span> 
    <span class="n">err</span> <span class="o">=</span> <span class="n">xxx</span><span class="p">;</span> 
    <span class="k">goto</span> <span class="n">xxx</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></div>
<p>既浪费精力容易出错，也不美观。 有困惑，就有改善的办法。 方法就是Linux设备模型中的device resource management（设备资源管理）。</p>

<h1 id="2解决的思路">2.解决的思路</h1>

<p>devres提供了一种机制，<font style="background:#8EE5EE">用资源节点的形式记录它申请的资源，并在系统中为设备分配一个链表，当申请某个资源时，就构建一个资源节点，然后把它加入到这个链表中，对应的释放函数也会被记录，以便在driver detach的时候，自动释放。</font></p>

<p>为了使用devres机制，资源要对各自的资源分配函数重新封装，加入资源节点的申请、添加和释放，一般新函数名改成了<font color="#ff0000">devm_xxx()</font>的形式。driver作者只管调用这些devm_xxx()接口来申请资源，不用考虑释放，设备模型会在适当的时候释放它们。</p>

<p>device resource management位于“drivers/base/devres.c”中，它实现了上述机制。
<img src="/blog/assets/DeviceResourceManagement/1.png" alt="1.png" /></p>

<h1 id="3提供的接口">3.提供的接口</h1>

<p>以下是devres提供的几个基本接口</p>

<table>
  <thead>
    <tr>
      <th>interface</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>devres_alloc( )</td>
      <td>// 分配资源节点</td>
    </tr>
    <tr>
      <td>devres_free( )</td>
      <td>// 释放资源节点</td>
    </tr>
    <tr>
      <td>devres_add( )</td>
      <td>// 添加资源节点到链表</td>
    </tr>
    <tr>
      <td>devres_destroy( )</td>
      <td>// 释放资源</td>
    </tr>
    <tr>
      <td>devres_release_all()</td>
      <td>//释放所有资源</td>
    </tr>
  </tbody>
</table>

<h1 id="4接口的使用">4.接口的使用</h1>

<p>其他资源模块，可以通过调用devres提供的接口，利用devres机制实现资源的自动释放。</p>

<h2 id="41-资源节点函数的应用举例">4.1 资源节点函数的应用举例</h2>

<p>下面的代码是利用devres机制实现分配中断资源函数 devm_request_threaded_irq( ), 上层模块可以调用它来分配中断资源，在出错时，不必考虑对该资源的释放，系统会自动释放。</p>

<p>主要涉及到devres_alloc()、devres_free()和devres_add()</p>

<p><img src="/blog/assets/DeviceResourceManagement/2.png" alt="2.png" /></p>

<h2 id="42-资源释放函数的应用举例">4.2 资源释放函数的应用举例</h2>

<p>资源释放函数devres_destroy()的使用举例，资源模块可以用它来封装资源释放函数。</p>

<p><img src="/blog/assets/DeviceResourceManagement/3.png" alt="3.png" width="500px" /></p>

<h1 id="5-函数的内部实现">5. 函数的内部实现</h1>

<h2 id="51-devres_alloc">5.1 devres_alloc()</h2>

<p>devrs_alloc()函数的实现，主要调用了内部函数alloc_dr(), 它会分配<font color="#ff0000">size+sizeof(struct devres)</font>的内存大小, struct devres用于存储资源节点信息，并记录release 函数。</p>

<p><img src="/blog/assets/DeviceResourceManagement/4.png" alt="4.png" /></p>

<h2 id="52-devres_add">5.2 devres_add()</h2>

<p>devres_add()主要实现把资源节点添加到设备的资源链表中。</p>

<p><img src="/blog/assets/DeviceResourceManagement/5.png" alt="5.png" width="550px" /></p>

<h2 id="53-devres_destroy">5.3 devres_destroy()</h2>

<p>devres_destroy()主要涉及到以下几个内部函数：</p>
<ul>
  <li>devres_remove()   //查找到资源节点，并从链表中删除</li>
  <li>find_dr()         //根据release函数指针、match函数查找资源节点</li>
  <li>devres_free()     //释放资源节点</li>
</ul>

<p>可以结合上面它的使用实例来学习。</p>

<p><img src="/blog/assets/DeviceResourceManagement/6.png" alt="6.png" /></p>

<h2 id="54-devers_release_all">5.4 devers_release_all()</h2>

<p>devers_release_all()的调用会释放所有资源。它的被调用时机有两个：</p>
<ul>
  <li>really_probe()失败</li>
  <li>设备与驱动分离时, deriver_dettach时 就是driver_remove时。</li>
</ul>

<p><img src="/blog/assets/DeviceResourceManagement/7.png" alt="7.png" /></p>]]></content><author><name>kevin</name></author><category term="linux" /><summary type="html"><![CDATA[1.解决的问题]]></summary></entry><entry><title type="html">misc</title><link href="http://localhost:4000/blog/jekyll/2018-06-22-misc.html" rel="alternate" type="text/html" title="misc" /><published>2018-06-22T00:00:00+08:00</published><updated>2018-06-22T00:00:00+08:00</updated><id>http://localhost:4000/blog/jekyll/misc</id><content type="html" xml:base="http://localhost:4000/blog/jekyll/2018-06-22-misc.html"><![CDATA[<h1 id="kref">kref</h1>

<p>kref_init 是一个用于初始化内核对象引用计数器（krefs）的函数。它允许你为你的对象添加引用计数，确保在多个地方使用和传递对象时，代码的正确性。以下是关于 kref_init 的一些重要信息：</p>

<ul>
  <li>初始化：</li>
</ul>

<p>在分配内存并创建对象后，你需要调用 kref_init 来初始化引用计数器。例如：</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">my_data</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
</code></pre></div></div>

<p>这将在 kref 中的 refcount 设置为 1。</p>

<ul>
  <li>使用规则：</li>
</ul>

<p>在对指针进行非临时拷贝（尤其是传递给另一个执行线程）之前，必须使用 kref_get 增加引用计数。
在完成对指针的处理后，必须调用 kref_put。如果这是对指针的最后一次引用，释放程序将被调用。</p>

<ul>
  <li>示例：</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">data_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">ref</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">my_data</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">my_data</span><span class="p">,</span> <span class="n">refcount</span><span class="p">);</span>
    <span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">more_data_handling</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">my_data</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">cb_data</span><span class="p">;</span>
    <span class="c1">// 处理 data</span>
    <span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="n">data_release</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">my_data_handler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">rv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">my_data</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
    <span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
    <span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
    <span class="c1">// 创建线程处理数据</span>
    <span class="c1">// ...</span>
    <span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="n">data_release</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>在上述示例中，两个线程处理数据的顺序并不重要，kref_put 会在数据不再被引用时释放它。
请注意，遵循这些规则可以确保正确管理内核对象的引用计数，避免内存泄漏和悬挂指针。</p>

<h1 id="idrid-range">IDR(ID Range)</h1>

<p>IDR 是一种用于管理连续整数范围的数据结构，通常用于内核中需要为对象分配唯一标识符的场景。
idr_alloc 函数用于在 Linux 内核中分配 IDR（ID Range）对象中的未使用的 ID。</p>

<p>以下是 idr_alloc 函数的用法：</p>

<ol>
  <li>首先，您需要初始化一个 IDR。对于静态分配的 IDR，您可以使用 DEFINE_IDR() 宏；对于动态分配的 IDR，您可以使用 idr_init() 函数。</li>
  <li>调用 idr_alloc() 来分配一个未使用的 ID。</li>
  <li>使用 idr_find() 查询与该 ID 相关的指针。</li>
  <li>使用 idr_remove() 释放该 ID。</li>
</ol>

<p>如果需要更改与某个 ID 相关联的指针，您可以调用 idr_replace()。这通常用于保留 ID，通过将 NULL 指针传递给分配函数，然后使用保留的 ID 初始化对象，最后将初始化的对象插入 IDR。</p>

<p>到目前为止，所有用户都满足了 UINT_MAX 的限制，因此他们使用 idr_alloc_u32()。</p>

<p>如果需要按顺序分配 ID，您可以使用 idr_alloc_cyclic()。请注意，处理较大数量的 ID 时，IDR 的效率会降低，因此使用这个函数会有一些代价。</p>

<p>当您使用完 IDR 后，可以调用 idr_destroy() 来释放 IDR 占用的内存。这不会释放 IDR 指向的对象；如果您想这样做，请使用其中一个迭代器来执行此操作。</p>

<p>您可以使用 idr_is_empty() 来查看当前是否分配了任何 ID。</p>

<p>如果在从 IDR 分配一个新 ID 时需要带锁，您可能需要传递一组限制性的 GFP 标志，但这可能导致 IDR 无法分配内存。为了解决该问题，您可以在获取锁之前调用 idr_preload()，然后在分配之后调用 idr_preload_end()。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;linux/idr.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">idr</span> <span class="n">my_idr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">id1</span><span class="p">,</span> <span class="n">id2</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">ptr1</span><span class="p">,</span> <span class="o">*</span><span class="n">ptr2</span><span class="p">;</span>

    <span class="c1">// Initialize the IDR</span>
    <span class="n">idr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_idr</span><span class="p">);</span>

    <span class="c1">// Allocate two unused IDs</span>
    <span class="n">id1</span> <span class="o">=</span> <span class="n">idr_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_idr</span><span class="p">,</span> <span class="s">"sample1"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
    <span class="n">id2</span> <span class="o">=</span> <span class="n">idr_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_idr</span><span class="p">,</span> <span class="s">"sample2"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

    <span class="c1">// Associate pointers with the IDs</span>
    <span class="n">ptr1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mh">0xdeadbeef</span><span class="p">;</span>
    <span class="n">ptr2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mh">0xcafebabe</span><span class="p">;</span>
    <span class="n">idr_replace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_idr</span><span class="p">,</span> <span class="n">ptr1</span><span class="p">,</span> <span class="n">id1</span><span class="p">);</span>
    <span class="n">idr_replace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_idr</span><span class="p">,</span> <span class="n">ptr2</span><span class="p">,</span> <span class="n">id2</span><span class="p">);</span>

    <span class="c1">// Look up pointers by ID</span>
    <span class="n">ptr1</span> <span class="o">=</span> <span class="n">idr_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_idr</span><span class="p">,</span> <span class="n">id1</span><span class="p">);</span>
    <span class="n">ptr2</span> <span class="o">=</span> <span class="n">idr_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_idr</span><span class="p">,</span> <span class="n">id2</span><span class="p">);</span>

    <span class="c1">// Free the IDs</span>
    <span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_idr</span><span class="p">,</span> <span class="n">id1</span><span class="p">);</span>
    <span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_idr</span><span class="p">,</span> <span class="n">id2</span><span class="p">);</span>

    <span class="c1">// Destroy the IDR</span>
    <span class="n">idr_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_idr</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<h1 id="非一致性内存-和一致性">非一致性内存 和一致性</h1>

<h2 id="dma_alloc_noncoherent">dma_alloc_noncoherent</h2>

<p>它是Linux内核中的一个DMA内存分配函数，用于分配一段物理内存，使其可以被DMA硬件访问12. 这个函数的作用是在非一致性内存（non-coherent memory）上分配一块区域，以便设备可以使用它作为DMA的源或目标地址。让我详细解释一下这个函数的用途和参数。</p>

<p>dma_alloc_noncoherent函数的原型如下：</p>

<p><code class="language-plaintext highlighter-rouge">void *dma_alloc_noncoherent(struct device *dev, size_t size, dma_addr_t *dma_handle, gfp_t flag);</code></p>

<ul>
  <li>dev: 指向设备结构的指针，表示要为哪个设备分配内存。</li>
  <li>size: 要分配的内存大小（以字节为单位）。</li>
  <li>dma_handle: 用于返回DMA地址的指针。这个地址可以转换为与总线宽度相同的无符号整数，并传递给设备作为分配区域的DMA地址基址。</li>
  <li>flag: 用于指定内存分配的GFP_标志（类似于kmalloc()中的标志）。例如，可以使用GFP_KERNEL来分配普通内核内存。
非一致性内存是一种特殊类型的内存，写入它的数据可以立即被处理器或设备读取，而无需考虑缓存效应。需要注意的是，CPU不能直接引用dma_addr_t，因为物理地址空间和DMA地址空间之间可能存在转换。</li>
</ul>

<p>使用dma_alloc_noncoherent分配的内存区域不保证一致性，因此在使用之前，可能需要手动刷新处理器的写缓冲区，以确保设备可以正确读取该内存。
释放由dma_alloc_noncoherent分配的内存时，应使用dma_free_noncoherent函数：</p>

<p><code class="language-plaintext highlighter-rouge">void dma_free_noncoherent(struct device *dev, size_t size, void *cpu_addr, dma_addr_t dma_handle);</code></p>

<p>dev、size和dma_handle参数必须与传递给dma_alloc_noncoherent的相同。
cpu_addr是由dma_alloc_noncoherent返回的虚拟地址。
请注意，与其他内存分配函数不同，这些函数只能在启用IRQ的情况下调用。</p>

<p>如果你的驱动程序需要大量较小的DMA一致性内存区域，你可以使用DMA池（dma_pool）来分配和管理这些区域，而不是使用dma_alloc_coherent()。DMA池类似于kmem_cache，但它使用dma_alloc_coherent()而不是__get_free_pages()</p>

<h2 id="dma_alloc_wc">dma_alloc_wc</h2>
<p>这个函数允许驱动程序申请带缓存一致性的DMA内存。缓存一致性是指确保CPU和DMA设备之间的数据一致性，以避免数据不一致的问题。使用dma_alloc_wc分配的内存区域旨在在CPU和DMA设备之间保持一致，以便数据正确传输。</p>

<p>释放由dma_alloc_wc分配的内存时，应使用dma_free_wc函数：</p>

<p><code class="language-plaintext highlighter-rouge">void dma_free_wc(struct device *dev, size_t size, void *cpu_addr, dma_addr_t dma_handle);</code></p>

<ul>
  <li>dev、size和dma_handle参数必须与传递给dma_alloc_wc的相同。</li>
  <li>cpu_addr是由dma_alloc_wc返回的虚拟地址。</li>
</ul>

<p><u>adf</u></p>
<h1 id="timer_setup">timer_setup</h1>

<p>它是Linux内核中用于初始化定时器的函数。它能够方便地设置和初始化一个计时器，并通过设置参数来灵活地控制计时器的行为1. 合理使用timer_setup函数可以让我们更好地处理时间相关的任务，提高操作系统的性能和可靠性。</p>

<p>在Linux内核中，定时器通常使用timer_list结构体来表示。下面是timer_list结构体的一些关键字段：</p>

<ul>
  <li>entry: 定时器列表元素，用于将定时器挂载在内核定时器链表上。</li>
  <li>expires: 定时器定时时间。</li>
  <li>function: 定时器回调函数，定时器时间到时执行该函数。</li>
  <li>flags: 标志位，用于设置定时器的属性。</li>
</ul>

<p>在旧版本的内核中，我们使用init_timer函数来初始化定时器。而在新版本中，这个函数变成了timer_setup函数。下面是timer_setup函数的定义：</p>

<p><code class="language-plaintext highlighter-rouge">void timer_setup(struct timer_list *timer, void (*callback)(struct timer_list *), unsigned int flags);</code></p>

<p>使用timer_setup函数时，我们需要传入以下参数：</p>

<ul>
  <li>timer: 要初始化的定时器。</li>
  <li>callback: 定时器的回调函数，此函数的形参是当前定时器的变量。</li>
  <li>flags: 标志位，可以设置定时器的属性。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;linux/kernel.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/timer.h&gt;</span><span class="cp">
</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">"GPL"</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">timer_list</span> <span class="n">my_timer</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">my_timer_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">"This line is printed after 5 seconds.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_module_with_timer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">"Initializing a module with timer.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="c1">// Setup the timer for initial use</span>
    <span class="n">timer_setup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_timer</span><span class="p">,</span> <span class="n">my_timer_callback</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// Set the timer interval to 5000 milliseconds (5 seconds)</span>
    <span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">5000</span><span class="p">));</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">exit_module_with_timer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">"Goodbye, cruel world!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">init_module_with_timer</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">exit_module_with_timer</span><span class="p">);</span>

</code></pre></div></div>

<h1 id="kthread_create_worker">kthread_create_worker</h1>

<p>函数是Linux内核中用于创建内核线程的一个函数。通过设置标志参数和格式化字符串，可以指定创建内核线程的行为和名称。它分配并初始化了一个kthread_worker结构体，并使用它来创建内核线程12.</p>

<p>以下是kthread_create_worker函数的一些关键参数：</p>

<ul>
  <li>cpu: 如果大于等于0，将创建特定于某个CPU的工作线程；如果不想创建特定于CPU的工作线程，可以将CPU域赋值为-1。</li>
  <li>flags: 可以设置一些标志位，根据需要来控制内核线程的行为。</li>
  <li>namefmt: 一个格式化字符串，用于指定内核线程的名称。</li>
</ul>

<p>这个函数会分配内存并初始化kthread_worker结构，然后返回指向该结构的指针。您可以根据具体需求使用这个函数来创建和管理内核线程。</p>

<p>如果您需要一个示例代码，以下是一个简单的例子，展示了如何在模块初始化时创建一个内核线程，以及如何在卸载模块时关闭该内核线程：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/kthread.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/delay.h&gt;</span><span class="cp">
</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">"GPL"</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">demo_thr</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">msleep_interruptible</span><span class="p">(</span><span class="mi">2000</span><span class="p">);</span>
        <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"Thread is running...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">thr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kthread_demo_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">thr</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">demo_thr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">"kthread-demo"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">thr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">"Failed to create kthread</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kthread_demo_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">thr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">kthread_stop</span><span class="p">(</span><span class="n">thr</span><span class="p">);</span>
        <span class="n">thr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">kthread_demo_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">kthread_demo_exit</span><span class="p">);</span>
</code></pre></div></div>
<p>在这个示例中，我们使用kthread_run函数创建一个名为kthread-demo的内核线程，它每隔2秒打印一条信息。在卸载模块时，我们使用kthread_stop来关闭该内核线程。</p>

<h1 id="schedule_work">schedule_work</h1>

<p>函数是Linux内核中的一个重要函数，用于将一个工作项（work）添加到工作队列（workqueue）中。这个函数的作用是在后台执行一些延迟较长的任务，而不会阻塞主线程的执行。</p>

<p>以下是关于schedule_work函数的一些要点：</p>

<ul>
  <li>功能：将工作项添加到默认的工作队列（通常是system_wq）中，以便稍后执行。</li>
  <li>调用方式：schedule_work(&amp;my_work);，其中my_work是一个已经初始化的工作项。</li>
  <li>工作队列：工作队列是一种异步执行机制，用于处理延迟的或非实时的任务。</li>
  <li>延迟执行：schedule_work会将工作项添加到工作队列中，等待系统调度执行。这样，主线程可以继续执行其他任务，而不必等待工作项完成。</li>
  <li>工作项回调函数：工作项的实际执行逻辑由回调函数定义。当工作项被调度执行时，会调用这个回调函数。</li>
</ul>

<p>以下是一个简单的示例代码，展示了如何使用INIT_WORK和schedule_work来创建和调度一个工作项：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;linux/init.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/kernel.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/workqueue.h&gt;</span><span class="cp">
</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">"GPL"</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">my_workqueue</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">work_struct</span> <span class="n">my_work</span><span class="p">;</span>

<span class="c1">// 工作项的回调函数</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">my_work_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"My work handler is running...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="c1">// 在这里执行您的工作逻辑</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_my_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"Initializing my kernel module with workqueue...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="c1">// 创建工作队列</span>
    <span class="n">my_workqueue</span> <span class="o">=</span> <span class="n">create_singlethread_workqueue</span><span class="p">(</span><span class="s">"my_workqueue"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">my_workqueue</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">"Failed to create workqueue</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 初始化工作项</span>
    <span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_work</span><span class="p">,</span> <span class="n">my_work_handler</span><span class="p">);</span>

    <span class="c1">// 将工作项添加到工作队列</span>
    <span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_work</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cleanup_my_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"Cleaning up my kernel module...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="c1">// 销毁工作队列</span>
    <span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">my_workqueue</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">init_my_module</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">cleanup_my_module</span><span class="p">);</span>
</code></pre></div></div>
<p>在这个示例中，我们首先定义了一个名为my_workqueue的工作队列结构体，以及一个名为my_work的工作项。然后，在init_my_module函数中使用create_singlethread_workqueue来创建一个名为my_workqueue的工作队列。接着，我们使用INIT_WORK来初始化工作项，并使用schedule_work来调度它。</p>

<h1 id="drm-blob">DRM Blob</h1>

<p>当涉及到 DRM（Direct Rendering Manager）中的“blob”时，我们实际上在讨论一种特定类型的属性。让我详细解释一下：</p>

<ol>
  <li>什么是 Blob？</li>
</ol>

<ul>
  <li>在 DRM 中，Blob 是一种特殊的属性，用于存储自定义数据块。它允许用户空间应用程序将自定义结构体数据传递给内核空间。</li>
  <li>Blob 通常用于存储一些不适合使用标准属性的数据，例如模式信息、LUT（查找表）数据、校准数据等。</li>
</ul>

<ol>
  <li>Blob 的结构和用法：</li>
</ol>

<ul>
  <li>
    <p>Blob 由两部分组成：</p>

    <ul>
      <li>
        <p>Blob ID：每个 Blob 都有一个唯一的 ID，用于在内核中标识该 Blob。</p>
      </li>
      <li>
        <p>Blob 数据：这是一个自定义长度的内存块，可以存储任何类型的数据。</p>
      </li>
    </ul>
  </li>
  <li>
    <p>Blob 可以存储各种信息，例如显示模式（mode）的详细信息、颜色校准数据、Gamma 表等。</p>
  </li>
</ul>

<ol>
  <li>Blob 的示例用途：</li>
</ol>

<ul>
  <li>
    <p>模式信息（Mode Information）：Blob 可以存储显示模式的详细信息，例如分辨率、刷新率、像素格式等。</p>
  </li>
  <li>
    <p>颜色校准数据：如果您需要在显示设备上进行颜色校准，可以使用 Blob 存储校准数据。</p>
  </li>
  <li>
    <p>Gamma 表：Gamma 表用于调整显示设备的亮度和对比度。这些数据可以存储在 Blob 中。</p>
  </li>
</ul>

<ol>
  <li>如何操作 Blob？</li>
</ol>

<ul>
  <li>
    <p>用户空间应用程序可以通过 DRM 接口来创建、获取和设置 Blob。</p>
  </li>
  <li>
    <p>创建 Blob：使用 drmModeCreatePropertyBlob 函数来创建一个 Blob，并将自定义数据传递给内核。</p>
  </li>
  <li>
    <p>获取 Blob 数据：使用 drmModeGetPropertyBlob 函数来获取 Blob 中存储的数据。</p>
  </li>
  <li>
    <p>设置 Blob 数据：使用 drmModeAtomicAddProperty 函数将 Blob ID 添加到 Atomic 请求中，从而修改 Blob 数据。</p>
  </li>
</ul>

<p>总之，Blob 是一种用于存储自定义数据的特殊属性，允许用户空间应用程序与内核交换非标准化的信息。它在 DRM 中的应用范围很广，例如显示模式、颜色校准和 Gamma 表等。</p>]]></content><author><name>kevin</name></author><category term="Jekyll" /><summary type="html"><![CDATA[kref]]></summary></entry><entry><title type="html">进程内存检查</title><link href="http://localhost:4000/blog/jekyll/2018-05-20-memory_check.html" rel="alternate" type="text/html" title="进程内存检查" /><published>2018-05-20T00:00:00+08:00</published><updated>2018-05-20T00:00:00+08:00</updated><id>http://localhost:4000/blog/jekyll/memory_check</id><content type="html" xml:base="http://localhost:4000/blog/jekyll/2018-05-20-memory_check.html"><![CDATA[<h1 id="1进程内存映射文件smaps">1.进程内存映射文件smaps</h1>

<p>在内核的数据结构中，进程、进程使用内存、虚拟内存块和一个二进制程序文件的对应关系图如下。</p>

<p><img src="/blog/assets/memory_check/vm_area.png" alt="vm_area" /></p>

<p>查看<code class="language-plaintext highlighter-rouge">/proc/${PID}/smaps</code>，可以得到每一个vm_area_node的详细信息。</p>

<p>下图是一个具体的<strong>vm_area_node</strong>信息。</p>

<p><img src="/blog/assets/memory_check/smap_file.png" alt="smaps" /></p>

<h2 id="11-两种映射">1.1 两种映射</h2>

<p>下面两种映射的介绍，是为了下一节解释各字段含义做准备。</p>

<ul>
  <li>文件映射</li>
</ul>

<p>就是存储介质(比如：磁盘)中的数据通过文件系统映射到内存再通过文件映射映射到虚拟空间，这样，用户就可以在用户空间通过 open, read, write 等函数区操作文件内容。代码中函数open(), read(), write(), close(), mmap(fd，…)… 操作的虚拟地址都属于文件映射。</p>

<ul>
  <li>匿名映射</li>
</ul>

<p>就是用户空间要求内核分配一定的物理内存来存储数据，这部分内存不属于任何文件。内核就使用匿名映射将内存中的某段物理地址与用户空间一一映射，这样用户就可用直接操作虚拟地址来范围这段物理内存。比如使用malloc(), mmap(NULL，…)申请内存。</p>

<h2 id="12-各字段含义">1.2 各字段含义</h2>

<ul>
  <li><span style="background-color: yellow">第一行</span></li>
</ul>

<p><img src="/blog/assets/memory_check/vm_area_node_head.png" alt="smaps_head" /></p>

<blockquote>
  <ol>
    <li><span style="color:hotpink;">08048000-080bc000</span>: 该虚拟内存段的开始和结束位置</li>
    <li><span style="color:orange">r-xp</span>:内存段的权限，分别是可读、可写、可运行、私有或共享，最后一位p代表私有，s代表共享(如共享的内存， shm). 如果有”w”，表示是库的数据区.</li>
    <li><span style="color:green">00000000</span>: 虚拟内存段起始地址在对应的映射文件中以页为单位的偏移量，
对匿名映射，它等于0或者vm_start/PAGE_SIZE</li>
    <li><span style="color:orangered;">03:02</span>: 文件的主设备号和次设备号。
对有名映射来说，是映射的文件所在设备的设备号
对匿名映射来说，因为没有文件在磁盘上，所以没有设备号，始终为00:00。</li>
    <li><span style="color:blue;">13130</span>: 被映射到虚拟内存的文件的索引节点号,通过该节点可以找到对应的文件，
对匿名映射来说，因为没有文件在磁盘上，所以为0</li>
    <li><strong>/bin/bash</strong>: 被映射到虚拟内存的文件名称。后面带(deleted)的是内存数据，可以被销毁。
对有名映射来说，是映射的文件名。
对匿名映射来说，是此段虚拟内存在进程中的角色。[stack]表示在进程中作为栈使用，[heap]表示堆。其余情况比如mmap(NULL, ….)则无显示。</li>
  </ol>
</blockquote>

<ul>
  <li>
    <p><span style="background-color: yellow">Size</span></p>

    <p>虚拟内存空间大小。但是这个内存值不一定是物理内存实际分配的大小，因为在用户态上，虚拟内存总是延迟分配的。这个值计算也非常简单，就是该VMA的开       始位置减结束位置。</p>

    <p><strong>延迟分配</strong>:就是当进程申请内存的时候，Linux会给他先分配页，但是并不会区建立页与页框的映射关系，也就是并不会分配物理内存，而当真正使用的时候，就会产生一个缺页异常，硬件跳转page fault处理程序执行，在其中分配物理内存，然后修改页表(创建页表项)。异常处理完毕，返回程序用户态，继续执行。</p>
  </li>
  <li>
    <p><span style="background-color: yellow">Rss</span> resident set size</p>

    <p>实际分配的内存，这部分物理内存已经分配，不需要缺页中断就可以使用的。<strong>但可能是和其他进程共享的</strong>。</p>

    <p>这里有一个公式计算Rss：</p>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Rss</span><span class="o">=</span><span class="n">Shared_Clean</span><span class="o">+</span><span class="n">Shared_Dirty</span><span class="o">+</span><span class="n">Private_Clean</span><span class="o">+</span><span class="n">Private_Dirty</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><span style="background-color: yellow">Shared_Clean</span>  <span style="background-color: yellow">Shared_Dirty</span>   <span style="background-color: yellow">Private_Clean</span>  <span style="background-color: yellow">Private_Dirty</span></p>

    <p>share/private：表示该页面是共享还是私有。</p>

    <p>dirty/clean： 表示该页面是否被修改过，如果修改过（dirty），在页面被淘汰的时候，就会把该脏页面回写到交换分区(换出，swap out)。有 一个标志位用于表示页面是否dirty。</p>

    <p>share/private_dirty/clean 计算逻辑：</p>

    <p>查看该page的引用数，如果引用&gt;1，则归为shared，如果是1，则归为private，再查看该page的flag，是否标记为_PAGE_DIRTY，如果不是，则认为干净的</p>
  </li>
  <li>
    <p><span style="background-color: yellow">Pss</span> proportional set size</p>

    <p>平摊计算后的实际物理使用内存(有些内存会和其他进程共享，例如mmap进来的)。实际上包含上面private_clean+private_dirty，和按比例均分的shared_clean、shared_dirty。</p>

    <p>举个计算Pss的例子：</p>

    <p>如果进程A有x个private_clean页面，有y个private_dirty页面，有z个shared_clean仅和进程B共享，有h个shared_dirty页面和进程B、C共享。那么进程A的Pss为：x + y + z/2 + h/3</p>
  </li>
  <li>
    <p><span style="background-color: yellow">Referenced</span></p>

    <p>当前页面被标记为已引用或者包含匿名映射（The amount of memory currently marked as referenced or a mapping associated with a file may contain anonymous pages）。在Linux内存管理的页面替换算法中，当某个页面被访问后，Referenced标志被设置，如果该标志设置了，就不能将该页移出。</p>
  </li>
  <li>
    <p><span style="background-color: yellow">Anonymous</span></p>

    <p>匿名映射的物理内存，这部分内存不是来自于文件。</p>
  </li>
  <li>
    <p><span style="background-color: yellow">VmFlags</span></p>

    <p>vm_area的各种属性，具体如下：</p>

    <p><img src="/blog/assets/memory_check/vmflags.png" alt="vmflags" width="400px" height="450px" /></p>
  </li>
</ul>

<h2 id="13-不同变量的位置">1.3 不同变量的位置</h2>

<p>一个库映射到内存， 一般分为代码段、数据段和只读数据段</p>
<ul>
  <li>r- --p: so中的字符串常数</li>
  <li>rw--p: so中的全局变量，静态变量</li>
  <li>r- -xp: so的代码段，常量</li>
  <li>- ---p: 表示该 VMA 是私有的，不可执行，且不可读写. 这通常用于保护敏感数据或代码，防止其被修改或执行</li>
</ul>

<p>下面这段代码展示了不同变量的存储位置：</p>

<p><img src="/blog/assets/memory_check/variable_location.png" alt="variable" width="650px" height="450px" /></p>

<h1 id="2free-命令">2.free 命令</h1>

<p>free 命令用于显示系统的内存状态，包括物理内存、交换内存（swap）和内核缓冲区内存。详细输出如下：</p>

<p><img src="/blog/assets/memory_check/free.png" alt="variable" width="650px" height="60px" /></p>

<ul>
  <li>Mem 行（第二行）显示了内存的使用情况。</li>
  <li>
    <p>Swap行（第三行）显示了交换空间的使用情况。</p>
  </li>
  <li>total: 表示系统总的可用<u>物理内存</u>和<u>交换空间</u>大小。</li>
  <li>used : 表示已经被使用的<u>物理内存</u>和<u>交换空间</u>。</li>
  <li>free : 表示还有多少<u>物理内存</u>和<u>交换空间</u>可用使用。</li>
  <li>shared: 显示被共享使用的<u>物理内存</u>大小。</li>
  <li>buff/cache: 显示被 buffer 和 cache 使用的物<u>理内存</u>大小。</li>
  <li>available: 显示还可以被应用程序使用的<u>物理内存</u>大小。</li>
</ul>

<h2 id="21-buffer与cache">2.1 buffer与cache</h2>

<ul>
  <li>
    <p><span style="background-color: yellow">buffer</span>: 缓<font style="color:red">冲</font>区</p>

    <p>CPU 在进行一系列操作时，先在内存的一块区域进行，一系列操作完成后，再一次性把该内存区域提交给外部设备，来对这个区域操作。</p>

    <p>比如写一堆数据给硬盘，就先写到内存的一块区域，写好后一次写回到硬盘。又比如读数据，先在内存划出一块区域，让硬盘控制器写数据到这块区域，写好后，CPU 直接访问该区域得到数据。这个内存区域就叫buffer</p>

    <p>缓冲区是内存或存储的一部分，用于在等待从输入设备传输到输出设备时存放项目。</p>

    <p>操作系统通常在打印文档时使用缓冲区。这个过程称为排队（spooling），它将要打印的文档发送到缓冲区，而不是立即发送到打印机。如果打印机没有自己的内部存储器，或者内存已满，操作系统的缓冲区会保存等待打印的信息，同时打印机以自己的速度从缓冲区打印。</p>

    <p>通过将文档排队到缓冲区，处理器可以继续解释和执行指令，同时打印机进行打印。这使用户可以在打印机打印时继续在计算机上进行其他任务。多个打印作业在缓冲区中排队（发音为“Q”）。一个名为<strong>打印排队程序（print spooler）</strong>的程序拦截操作系统中要打印的文档，并将其放入队列中</p>
  </li>
  <li>
    <p><span style="background-color: yellow">cache</span>：缓<font style="color:red">存</font></p>

    <p>CPU 要访问一块数据时，首先访问内存的某个区域，看是否有该数据的缓存，有则直接访问，没有则访问它的来源地。
   CPU 利用内存或高速缓存对数据的再备份，为以后的再次访问提供方便</p>

    <p>缓存如今的大多数计算机通过缓存（发音为“cash”）来提高处理速度。</p>

    <p>缓存有两种主要类型：内存缓存和磁盘缓存。让我们详细了解一下内存缓存。</p>

    <p>L1 缓存：</p>

    <p>L1 缓存直接内置在处理器芯片中。     <br />
   它通常容量很小，范围从 8 KB 到 128 KB。
   L1 缓存存储经常使用的指令和数据，以便快速访问。</p>

    <p>L2 缓存：</p>

    <p>L2 缓存比 L1 缓存稍慢，但容量更大。
   它的大小范围从 64 KB 到 16 MB。
   一些现代处理器包括高级传输缓存，这是一种直接内置在处理器芯片上的 L2 缓存类型。
   使用高级传输缓存的处理器的性能比不使用它的处理器要快得多。
   现今的个人计算机通常具有 512 KB 到 12 MB 的高级传输缓存。</p>

    <p>缓存通过存储经常使用的指令和数据来显著加快处理时间。</p>

    <p>当处理器需要一条指令或数据时，它按照以下顺序搜索内存：L1 缓存，然后是 L2 缓存，然后是 RAM。</p>

    <p>如果所需信息在内存中找不到，处理器必须搜索速度较慢的存储介质，例如硬盘或光盘。</p>
  </li>
</ul>

<h2 id="22-手动释放缓存">2.2. 手动释放缓存</h2>

<ol>
  <li>首先，<u>使用sync命令将未写入磁盘的数据同步到磁盘，以确保文件系统的完整性。</u></li>
  <li>然后，通过设置/proc/sys/vm/drop_caches来释放内存缓存：
    <ul>
      <li>echo 1 &gt; /proc/sys/vm/drop_caches：释放页缓存。</li>
      <li>echo 2 &gt; /proc/sys/vm/drop_caches：释放 dentries 和 inodes。</li>
      <li>echo 3 &gt; /proc/sys/vm/drop_caches：释放所有缓存。</li>
    </ul>
  </li>
</ol>

<h1 id="3mtrace">3.mtrace</h1>

<p>mtrace 是 Linux 系统内核自带的一个内存追踪函数。它会在每个内存申请函数（malloc、realloc、calloc）的位置记录下信息，并在每个内存释放的位置记录下 free 的内存信息。其中包含有内存申请的地址、内存申请的大小、释放内存的地址、释放内存的大小。</p>

<p>具体来说，mtrace 函数的作用如下：</p>

<ul>
  <li>安装钩子函数，用于跟踪内存分配和释放。</li>
  <li>记录有关内存分配和释放的跟踪信息。</li>
  <li>可以用于发现程序中的内存泄漏和试图释放未分配内存的情况。</li>
</ul>

<p>使用方式：</p>

<ol>
  <li>在代码中包含 &lt;mcheck.h&gt; 头文件。</li>
  <li>在程序启动时调用 mtrace() 函数，开启内存分配和释放跟踪。</li>
  <li>程序结束时，可以调用 muntrace() 函数关闭内存分配和释放跟踪。</li>
  <li>运行mtrace脚本，分析跟踪日志，生成报告。</li>
</ol>

<p>请注意，mtrace 的跟踪输出通常是文本形式，不一定易于人类阅读。GNU C 库提供了一个 Perl 脚本 mtrace，用于解析跟踪日志并生成人类可读的输出。为了获得最佳效果，建议编译时启用调试，以便在可执行文件中记录行号信息。不过，mtrace 的跟踪会带来性能损耗.如果 MALLOC_TRACE 没有指向有效且可写的路径， 则mtrace不会记录信息。</p>

<p><img src="/blog/assets/memory_check/mtrace.png" alt="mtrace" width="500px" height="250px" />
<img src="/blog/assets/memory_check/mtrace_2.png" alt="mtrace" width="650px" height="250px" /></p>

<h1 id="4strace与ltrace">4.strace与ltrace</h1>

<p>ltrace 用于跟踪程序的库函数调用，而 strace 则用于跟踪系统调用。
它们都基于 ptrace 系统调用，但跟踪库函数和跟踪系统调用之间存在差异。 通过它们，我们也可以对应用的内存申请、释放进行跟踪。</p>

<p>ltrace 的工作原理：</p>
<ul>
  <li>ptrace 附加到正在运行的程序。</li>
  <li>定位程序的 PLT。</li>
  <li>使用 PTRACE_POKETEXT 设置软件断点（int $3 指令）覆盖库函数的 PLT 中的汇编 trampoline。</li>
  <li>恢复程序执行。</li>
</ul>

<p>strace 应该也是相类似的工作原理</p>

<h2 id="41-strace">4.1 strace</h2>

<p>strace 是一个强大的 Linux 命令，用于诊断、调试和统计。它允许您跟踪正在运行的程序的系统调用和接收的信号。下面是一些关于 strace 的参数使用方法。</p>

<ul>
  <li>-c：统计每个系统调用的执行时间、次数和错误次数。 示例：打印执行 uptime 时系统调用的时间、次数和错误次数：
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>strace <span class="nt">-c</span> <span class="nb">uptime</span>
</code></pre></div>    </div>
  </li>
  <li>-f：跟踪子进程，这些子进程是由当前跟踪的进程创建的。</li>
  <li>-i：在系统调用时打印指令指针。</li>
  <li>-t：跟踪的每一行都以时间为前缀。</li>
  <li>-tt：如果给出两次，则打印时间将包括微秒。</li>
  <li>-ttt：如果给定三次，则打印时间将包括微秒，并且前导部分将打印为自启动以来的秒数。</li>
  <li>-T：显示花费在系统调用上的时间。</li>
</ul>

<p>限定表达式：</p>
<ul>
  <li>-e trace=set：仅跟踪指定的系统调用集。例如，trace=open,close,read,write 表示仅跟踪这四个系统调用。</li>
  <li>-e trace=file：跟踪所有以文件名作为参数的系统调用。示例：打印执行 ls 时与文件有关的系统调用：
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>strace <span class="nt">-e</span> <span class="nv">trace</span><span class="o">=</span>file <span class="nb">ls</span>
</code></pre></div>    </div>
  </li>
  <li>-e trace=process：跟踪涉及进程管理的所有系统调用。</li>
  <li>-e trace=network：跟踪所有与网络相关的系统调用。</li>
  <li>-e trace=signal：跟踪所有与信号相关的系统调用。</li>
  <li>-e trace=ipc：跟踪所有与 IPC 相关的系统调用。</li>
  <li><span style="color: red;">-e trace=memory：跟踪所有与 momory 相关的系统调用。</span></li>
</ul>

<p>其他参数：</p>
<ul>
  <li>-o 文件名：将跟踪输出写入文件而不是 stderr。</li>
  <li>-p pid：使用进程 ID pid 附加到该进程并开始跟踪</li>
</ul>

<p>下面是运行 <code class="language-plaintext highlighter-rouge">strace ls</code> 的输出
<img src="/blog/assets/memory_check/strace.png" alt="strace" width="650px" height="500px" /></p>

<h2 id="42-ltrace">4.2 ltrace</h2>

<p>ltrace 是一个用于跟踪程序库调用的 Linux 工具。它可以拦截并记录被执行进程调用的动态库函数，以及该进程接收到的信号。此外，ltrace 还可以拦截并打印程序执行的系统调用。</p>

<p>常用参数和示例：
-c：统计每个系统调用的执行时间、次数和错误次数。 示例：打印执行 uptime 时系统调用的时间、次数和错误次数：</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ltrace <span class="nt">-c</span> <span class="nb">uptime</span>
</code></pre></div></div>

<ul>
  <li>-f：跟踪子进程，这些子进程是由当前跟踪的进程创建的。</li>
  <li>-i：在系统调用时打印指令指针。</li>
  <li>-t：跟踪的每一行都以时间为前缀。</li>
  <li>-tt：如果给出两次，则打印时间将包括微秒。</li>
  <li>-ttt：如果给定三次，则打印时间将包括微秒，并且前导部分将打印为自启动以来的秒数。</li>
  <li>-T：显示花费在系统调用上的时间。</li>
</ul>

<p>限定表达式：</p>

<ul>
  <li>-e trace=set：仅跟踪指定的系统调用集。例如，trace=open,close,read,write 表示仅跟踪这四个系统调用。</li>
  <li>-e trace=file：跟踪所有以文件名作为参数的系统调用。示例：打印执行 ls 时与文件有关的系统调用：
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ltrace <span class="nt">-e</span> <span class="nv">trace</span><span class="o">=</span>file <span class="nb">ls</span>
</code></pre></div>    </div>
  </li>
  <li>-e trace=process：跟踪涉及进程管理的所有系统调用。</li>
  <li>-e trace=network：跟踪所有与网络相关的系统调用。</li>
  <li>-e trace=signal：跟踪所有与信号相关的系统调用。</li>
  <li>-e trace=ipc：跟踪所有与 IPC 相关的系统调用。</li>
</ul>

<p>其他参数：</p>

<ul>
  <li>-o 文件名：将跟踪输出写入文件而不是 stderr。</li>
  <li>-p pid：使用进程 ID pid 附加到该进程并开始跟踪。</li>
</ul>

<p>下面是运行 <code class="language-plaintext highlighter-rouge">ltrace ls</code> 的输出</p>

<p><img src="/blog/assets/memory_check/ltrace.png" alt="ltrace" width="650px" height="500px" /></p>]]></content><author><name>Kevin</name></author><category term="Jekyll" /><summary type="html"><![CDATA[1.进程内存映射文件smaps]]></summary></entry><entry><title type="html">only test</title><link href="http://localhost:4000/blog/jekyll/2018-04-27-test.html" rel="alternate" type="text/html" title="only test" /><published>2018-04-27T00:00:00+08:00</published><updated>2018-04-27T00:00:00+08:00</updated><id>http://localhost:4000/blog/jekyll/test</id><content type="html" xml:base="http://localhost:4000/blog/jekyll/2018-04-27-test.html"><![CDATA[<p>only for test new txt</p>

<p>123
dsf</p>

<pre><code class="language-mermaid">graph TD;
    A--&gt;B;
    A--&gt;C;
    B--&gt;D;
    C--&gt;D;
</code></pre>

<h1 id="test">test</h1>

<ol>
  <li>预设环境</li>
</ol>

<blockquote>
  <p>$export WLD=“~/xxxxxxxxx”
apt install meson
apt install some_depenced_libs</p>
</blockquote>

<ol>
  <li>Wayland</li>
</ol>

<table>
  <thead>
    <tr>
      <th>Syntax</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Header</td>
      <td>Title</td>
    </tr>
    <tr>
      <td>Paragraph</td>
      <td>Text</td>
    </tr>
  </tbody>
</table>

<p><a href="/blog/assets/abc.md" title=":include">test_abc</a>
<img src="/blog/assets/YUV/sampling.png" alt="sampling" /></p>]]></content><author><name>Tao He</name></author><category term="Jekyll" /><summary type="html"><![CDATA[only for test new txt]]></summary></entry><entry><title type="html">YUV资料</title><link href="http://localhost:4000/blog/jekyll/2018-03-21-YUV.html" rel="alternate" type="text/html" title="YUV资料" /><published>2018-03-21T00:00:00+08:00</published><updated>2018-03-21T00:00:00+08:00</updated><id>http://localhost:4000/blog/jekyll/YUV</id><content type="html" xml:base="http://localhost:4000/blog/jekyll/2018-03-21-YUV.html"><![CDATA[<h1 id="1简介">1.简介</h1>

<p>YUV数据由Y、U、V三个分量组成，现在通常说的YUV指的是YCbCr。</p>

<p>Y：表示<strong>亮度</strong>（Luminance、Luma），占8bit（1字节）</p>

<p>Cb、Cr：表示<strong>色度</strong>（Chrominance、Chroma）</p>

<p>Cb（U）：蓝色色度分量，占8bit（1字节）</p>

<p>Cr（V）：红色色度分量，占8bit（1字节）</p>

<h1 id="2采样方式444-422-420的区别">2.采样方式(444, 422, 420的区别)</h1>
<p>把Y、U、V数据转变为R、G、B时用到</p>

<h2 id="21-采样方式">2.1 采样方式</h2>
<p>采样方式通常用A:B:C的形式来表示，比如4:4:4、4:2:2、4:2:0等</p>
<ul>
  <li>
    <p>A：假定在一块A*2个像素的概念区域，一般都是4.</p>
  </li>
  <li>
    <p>B：第1行的色度(UV)采样数目。</p>
  </li>
  <li>
    <p>C：第2行的色度(UV)采样数目</p>
  </li>
</ul>

<p>所以这里的B,C指的分别是在第一行，第二行UV采样的数目。 C的值一般要么等于B，要么等于0</p>

<p>示意图1：
<img src="/blog/assets/YUV/sampling.png" alt="sampling" /></p>

<p>示意图2</p>

<p><img src="/blog/assets/YUV/sampling_2.jpg" alt="sampling_2" /></p>

<p>上图中，不管是哪种采样格式，Y分量都是全水平、全垂直分辨率采样的，每一个像素都有自己独立的Y分量</p>

<h2 id="22-占用字节数">2.2 占用字节数</h2>

<p>由上可以推算出不同采样方式下每个像素需要的平均字节数。</p>

<ul>
  <li>
    <p>4:4:4</p>

    <p>一个像素YUV各占一个字节，总共3个字节 24bit</p>
  </li>
  <li>
    <p>4:2:2</p>

    <p>8个像素 ： 8个Y + 2个U +2个V +2个U +2个V = 16字节</p>

    <p>每个像素：16字节/8 = 2个字节 16bit</p>
  </li>
  <li>
    <p>4:2:0</p>

    <p>8个像素 ： 8个Y + 2个U +2个V  = 12字节</p>

    <p>每个像素：12字节/8 = 1.5个字节 12bit</p>
  </li>
</ul>

<h1 id="3存储方式planar-semi-planar和packed的区别">3.存储方式(Planar, Semi-Planar和Packed的区别)</h1>

<p>存储格式，表示的是Y、U、V数据是如何排列和存储的。 读取或写入Y、U、V数据时用到.</p>

<h2 id="31-分类">3.1 分类</h2>
<p>YUV的存储格式可以分为3大类：</p>

<table>
  <thead>
    <tr>
      <th>名称</th>
      <th>特点</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Planar(平面)</td>
      <td>Y、U、V分量分开单独存储,名称通常以字母p结尾,  3个planar</td>
    </tr>
    <tr>
      <td>Semi-Planar（半平面）</td>
      <td>Y分量单独存储，U、V分量交错存储, 名称通常以字母sp结尾, 1个planar</td>
    </tr>
    <tr>
      <td>Packed（紧凑）</td>
      <td>或者叫Interleaved(交错), Y、U、V分量交错存储,  1个planar</td>
    </tr>
  </tbody>
</table>

<h2 id="32-444">3.2 444</h2>

<p><img src="/blog/assets/YUV/444.png" alt="" width="540px" height="150px" /></p>

<p>I444 和YV24 主要是UV次序的不同</p>

<p><img src="/blog/assets/YUV/I444.png" alt="" width="540px" height="200px" /></p>

<p>semi-planar NV24 和NV42 主要是UV交替次序的不同</p>

<p><img src="/blog/assets/YUV/NV24.png" alt="" width="540px" height="200px" /></p>

<h2 id="33-422">3.3 422</h2>

<p><img src="/blog/assets/YUV/422.png" alt="" width="540px" height="150px" /></p>

<p><strong>Planar I422 YV16 区别：VU 次序</strong></p>

<p><img src="/blog/assets/YUV/YV16.png" alt="" width="540px" height="200px" /></p>

<p><strong>Semi-Planar NV16 NV61 区别：VU 次序</strong></p>

<p><img src="/blog/assets/YUV/NV16.png" alt="" width="540px" height="200px" /></p>

<p><strong>Packed UYVY YUYV YVYU 区别：VU 次序</strong></p>

<p><img src="/blog/assets/YUV/YUYV.png" alt="" width="540px" height="200px" /></p>

<h2 id="34-420">3.4 420</h2>

<p><img src="/blog/assets/YUV/420.png" alt="" width="540px" height="150px" /></p>

<p><strong>Planar I420 YV12</strong></p>

<p><img src="/blog/assets/YUV/I420.png" alt="" width="540px" height="200px" /></p>

<p><strong>采样方式420 I420，像素示意图</strong></p>

<p><img src="/blog/assets/YUV/I420_pixel.png" alt="" width="540px" height="200px" /></p>

<p><strong>Semi-Planar NV12 NV21</strong></p>

<p><img src="/blog/assets/YUV/NV12.png" alt="" width="540px" height="200px" /></p>

<p><strong>采样方式420，各种存储方式， 像素示意图</strong></p>

<p><img src="/blog/assets/YUV/420_pixel.png" alt="" width="540px" height="350px" /></p>

<h1 id="4借助ffmpeg格式转换">4.借助ffmpeg格式转换</h1>

<ol>
  <li>PNG -&gt; YUV
    <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ffmpeg <span class="nt">-i</span> <span class="k">in</span>.png <span class="nt">-s</span> 512x512 <span class="nt">-pix_fmt</span> yuv420p out.yuv
</code></pre></div>    </div>
  </li>
  <li>YUV -&gt; PNG
    <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ffmpeg <span class="nt">-s</span> 512x512 <span class="nt">-pix_fmt</span> yuv420p <span class="nt">-i</span> <span class="k">in</span>.yuv out.jpg
</code></pre></div>    </div>
  </li>
</ol>

<p><strong>YUV 文件只是存储数据的文件，没有大小信息，所以转换时一定要给出它的尺寸</strong></p>

<p><strong>PNG 文件含有尺寸信息，所以转YUV时可以不指定大小，默认原大小</strong></p>

<h1 id="5借助ffplay显示yuv">5.借助ffplay显示YUV</h1>

<p>可以通过ffplay显示YUV数据。</p>

<ul>
  <li>
    <p>YUV中直接存储的是所有像素的颜色信息（可以理解为是图像的一种原始数据）</p>
  </li>
  <li>
    <p>必须得设置YUV的尺寸（-s）、像素格式（-pix_fmt）才能正常显示</p>
  </li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ffplay <span class="nt">-s</span> 512x512 <span class="nt">-pix_fmt</span> yuv420p <span class="k">in</span>.yuv
<span class="c"># 在ffplay中</span>
<span class="c"># -s已经过期，建议改为：-video_size</span>
<span class="c"># -pix_fmt已经过期，建议改为：-pixel_format</span>
ffplay <span class="nt">-video_size</span> 512x512 <span class="nt">-pixel_format</span> yuv420p <span class="k">in</span>.yuv
</code></pre></div></div>

<h1 id="6glsl实现yuv转rgba">6.GLSL实现YUV转RGBA</h1>

<h2 id="61-基本计算公式">6.1 基本计算公式</h2>

<p>根据的标准不同，有不同的计算公式。下面是一个可以在shader中使用的计算方法。 只要先得到Y,U,V， 就可以按下面方法转换RGB</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="s">"   yuv.y = yuv.y - 0.5;                                  </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"   yuv.z = yuv.z - 0.5;                                  </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"                                                         </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"   rgb.r = yuv.x + 1.402 * yuv.z;                        </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"   rgb.g = yuv.x - 0.34413 * yuv.y - 0.71414 * yuv.z;    </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"   rgb.b = yuv.x + 1.772 * yuv.y;                        </span><span class="se">\n</span><span class="s">"</span>
</code></pre></div></div>
<p>YUV到RGBA的转换其实就两个要点</p>
<ul>
  <li>构建合适的纹理</li>
  <li>在shader中提前YUV</li>
</ul>

<h2 id="62-yuv444p-argb">6.2 YUV444P-&gt;ARGB</h2>

<h3 id="621-构建纹理">6.2.1 构建纹理</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">GLuint</span> <span class="nf">build_texture_4_yuv444p</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">){</span>
    <span class="n">GLuint</span> <span class="n">texture</span><span class="p">;</span>
    <span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">texture</span><span class="p">);</span>
    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">texture</span><span class="p">);</span>

    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_REPEAT</span><span class="p">);</span>    
    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_REPEAT</span><span class="p">);</span>        
    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>    
    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>

    <span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RED</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RED</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> 
    <span class="k">return</span> <span class="n">texture</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="622-在shader中提取yuv">6.2.2 在shader中提取YUV</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">yuv444_2_rgba_frag_src</span> <span class="o">=</span>    
    <span class="s">"uniform sampler2D    Sampler;                              </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"varying highp vec2   TexCoord;                             </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"void main (void)                                           </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"{                                                          </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"   highp vec3 yuv;                                         </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"   highp vec3 rgb;                                         </span><span class="se">\n</span><span class="s">"</span>    
    <span class="s">"   yuv.x = texture2D(Sampler, TexCoord).r;                 </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"   yuv.y = texture2D(Sampler, vec2(TexCoord.x, TexCoord.y+0.3333333)).r;</span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"   yuv.z = texture2D(Sampler, vec2(TexCoord.x, TexCoord.y+0.6666667)).r;</span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"                                                         </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"   yuv.y = yuv.y - 0.5;                                  </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"   yuv.z = yuv.z - 0.5;                                  </span><span class="se">\n</span><span class="s">"</span>
<span class="c1">// 矩阵计算方法</span>
    <span class="s">"   rgb = mat3(                                           </span><span class="se">\n</span><span class="s">"</span>
                    <span class="s">"1,       1,        1,                    </span><span class="se">\n</span><span class="s">"</span>
                    <span class="s">"0,     -.34413,    1.772,                </span><span class="se">\n</span><span class="s">"</span>
                    <span class="s">"1.402, -.71414,    0                     </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"              ) * yuv;                                   </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"                                                         </span><span class="se">\n</span><span class="s">"</span>    
    <span class="s">"   gl_FragColor = vec4(rgb, 1.0);                        </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"}                                                        </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

</code></pre></div></div>

<h2 id="63-nv24-argb">6.3 NV24-&gt;ARGB</h2>

<h3 id="631-构建纹理">6.3.1 构建纹理</h3>

<p>这里需要构建两个纹理，一个是Y的纹理， 一个是UV的纹理</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">GLuint</span> <span class="nf">build_texture_4_nv24_y</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">y_data</span><span class="p">){</span>
    <span class="n">GLuint</span> <span class="n">texture</span><span class="p">;</span>
  
    <span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">texture</span><span class="p">);</span>
    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">texture</span><span class="p">);</span>

    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>    
    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>        
    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>    
    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
    
    <span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_LUMINANCE</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_LUMINANCE</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="n">y_data</span><span class="p">);</span>
    
    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> 
    <span class="k">return</span> <span class="n">texture</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">GLuint</span> <span class="nf">build_texture_4_nv24_uv</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">uv_data</span><span class="p">){</span>
    <span class="n">GLuint</span> <span class="n">texture</span><span class="p">;</span>
  
    <span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">texture</span><span class="p">);</span>
    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">texture</span><span class="p">);</span>

    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>    
    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>        
    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>    
    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
    
    <span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_LUMINANCE_ALPHA</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_LUMINANCE_ALPHA</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="n">uv_data</span><span class="p">);</span>
    
    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> 
    <span class="k">return</span> <span class="n">texture</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="632-在shader中提取yuv">6.3.2 在shader中提取YUV</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">nv24_2_rgba_frag_src</span> <span class="o">=</span>        
    <span class="s">"uniform sampler2D    Sampler_y;                            </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"uniform sampler2D    Sampler_uv;                           </span><span class="se">\n</span><span class="s">"</span>    
    <span class="s">"varying highp vec2   TexCoord;                             </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"void main (void)                                           </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"{                                                          </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"   highp vec3 yuv;                                         </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"   highp vec3 rgb;                                         </span><span class="se">\n</span><span class="s">"</span>    
    <span class="s">"                                                           </span><span class="se">\n</span><span class="s">"</span>    
    <span class="s">"   yuv.x = texture2D(Sampler_y, TexCoord).r;             </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"   yuv.y = texture2D(Sampler_uv, TexCoord).r;            </span><span class="se">\n</span><span class="s">"</span>    
    <span class="s">"   yuv.z = texture2D(Sampler_uv, TexCoord).a;            </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"                                                         </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"   yuv.y = yuv.y - 0.5;                                  </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"   yuv.z = yuv.z - 0.5;                                  </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"                                                         </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"   rgb.r = yuv.x + 1.402 * yuv.z;                        </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"   rgb.g = yuv.x - 0.34413 * yuv.y - 0.71414 * yuv.z;    </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"   rgb.b = yuv.x + 1.772 * yuv.y;                        </span><span class="se">\n</span><span class="s">"</span>        
    <span class="s">"                                                         </span><span class="se">\n</span><span class="s">"</span>    
    <span class="s">"   gl_FragColor = vec4(rgb, 1.0);                        </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"}                                                        </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="64-nv16-argb">6.4 NV16-&gt;ARGB</h2>

<h3 id="641-构建纹理">6.4.1 构建纹理</h3>

<p>这里需要构建两个纹理，一个是Y的纹理， 一个是UV的纹理</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">GLuint</span> <span class="nf">build_texture_4_nv16_y</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">){</span>
    <span class="n">GLuint</span> <span class="n">texture</span><span class="p">;</span>
  
    <span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">texture</span><span class="p">);</span>
    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">texture</span><span class="p">);</span>

    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>    
    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>        
    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>    
    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
    
    <span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_LUMINANCE</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_LUMINANCE</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    
    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> 
    <span class="k">return</span> <span class="n">texture</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>注意glTexImage2D()的第四参数值发生了变化</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">GLuint</span> <span class="nf">build_texture_4_nv16_uv</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">){</span>
    <span class="n">GLuint</span> <span class="n">texture</span><span class="p">;</span>
  
    <span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">texture</span><span class="p">);</span>
    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">texture</span><span class="p">);</span>

    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>    
    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>        
    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>    
    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
    
    <span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_LUMINANCE_ALPHA</span><span class="p">,</span> <span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_LUMINANCE_ALPHA</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    
    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> 
    <span class="k">return</span> <span class="n">texture</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h3 id="642-在shader中提取yuv">6.4.2 在shader中提取YUV</h3>

<p>与NV24方法相同</p>

<h2 id="65-nv12-argb">6.5 NV12-&gt;ARGB</h2>

<h3 id="651-构建纹理">6.5.1 构建纹理</h3>

<p>这里需要构建两个纹理，一个是Y的纹理， 一个是UV的纹理</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">GLuint</span> <span class="nf">build_texture_4_nv12_y</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">){</span>
    <span class="n">GLuint</span> <span class="n">texture</span><span class="p">;</span>
  
    <span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">texture</span><span class="p">);</span>
    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">texture</span><span class="p">);</span>

    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>    
    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>        
    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>    
    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
    
    <span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_LUMINANCE</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_LUMINANCE</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    
    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> 
    <span class="k">return</span> <span class="n">texture</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p><strong>注意glTexImage2D()的第四,五参数值发生了变化</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">GLuint</span> <span class="nf">build_texture_4_nv12_uv</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">){</span>
    <span class="n">GLuint</span> <span class="n">texture</span><span class="p">;</span>
  
    <span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">texture</span><span class="p">);</span>
    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">texture</span><span class="p">);</span>

    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>    
    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_CLAMP_TO_EDGE</span><span class="p">);</span>        
    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>    
    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
    <span class="n">CHK_GL_ERR</span><span class="p">();</span>
    
    <span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_LUMINANCE_ALPHA</span><span class="p">,</span> <span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">height</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_LUMINANCE_ALPHA</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="n">CHK_GL_ERR</span><span class="p">();</span>
    
    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> 
    <span class="k">return</span> <span class="n">texture</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="652-在shader中提取yuv">6.5.2 在shader中提取YUV</h3>

<p>与NV24方法相同</p>]]></content><author><name>Kevin</name></author><category term="Jekyll" /><summary type="html"><![CDATA[1.简介]]></summary></entry><entry><title type="html">硬中断</title><link href="http://localhost:4000/blog/jekyll/2018-02-27-interrupte.html" rel="alternate" type="text/html" title="硬中断" /><published>2018-02-27T00:00:00+08:00</published><updated>2018-02-27T00:00:00+08:00</updated><id>http://localhost:4000/blog/jekyll/interrupte</id><content type="html" xml:base="http://localhost:4000/blog/jekyll/2018-02-27-interrupte.html"><![CDATA[<p>【转帖】</p>

<p>本来想写内核如何接收一个网络包这个过程，但发现把整个过程捋顺了，还是很难的。</p>

<p>推导整个过程的起点是<strong>中断</strong>，包括<strong>硬中断</strong>和<strong>软中断</strong>。</p>

<p>而这个过程要是讲清楚吧，感觉在整个网络包接收原理的大流程中有点喧宾夺主。但要是一笔带过吧，那对于这块有困惑的人就很难受，一切的起点没整明白在心里总是个疙瘩。所以，单拎出来一个主题中断，给大家把这个问题搞明白了。</p>

<p>另外，<strong>整个操作系统就是一个中断驱动的死循环</strong>，操作系统原理如果用一行代码解释，下面这样再合适不过了。</p>

<pre><code class="language-C">while(true) {
	doNothing();
}
</code></pre>

<p><strong>其他所有事情都是由操作系统提前注册的中断机制和其对应的中断处理函数完成</strong>，我们点击一下鼠标，敲击一下键盘，执行一个程序，都是用中断的方式来通知操作系统帮我们处理这些事件，当没有任何需要操作系统处理的事件时，它就乖乖停在死循环里不出来。</p>

<p>所以，中断，非常重要，它也是理解整个操作系统的根基，掌握它，不亏！</p>

<p>那我们开始吧。</p>

<p><strong>五花八门的中断分类</strong></p>

<p>关于中断的分类，教科书上和网上有很多”标准”答案了，如果你用搜索引擎去寻找答案，可能会找出很多不一样的分类结果。</p>

<p>所以我打算直接在 Intel 手册上找个最官方的标准答案。</p>

<p>在 <em>Intel 手册 Volume 1 Chapter 6.4 Interrupts and Exception</em> 给出。</p>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRaebHKiaWevE73umedjHIDmQ3eQXdDdbee9wMwIwic5eNK9N2Erm01239eKbz1hl6ZWLSo3BRf6UBg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" /></p>

<p>翻译过来就是，<strong>中断可以分为中断和异常，异常又可以分为故障、陷阱、中止</strong>。</p>

<p>第一句话有点奇怪，啥叫中断分为中断和异常呢？你看好多文章的时候也是这么写的，不知道你有没有曾疑惑过。</p>

<p>但其实原文的意思准确说是，<strong>CPU 提供了两种中断程序执行的机制，中断和异常</strong>。第一个中断是个动词，第二个中断才是真正的机制种类。</p>

<p>好吧，我感觉原文也挺奇怪的，但人家就这么叫，没辙。</p>

<p>接下来我只需要翻译一下就好了，再夹杂点自己的解读。</p>

<p>An interrupt is an asynchronous event that is typically triggered by an I/O device.</p>

<p>先说第一个机制中断（interrupt），<strong>中断是一个异步事件，通常由 IO 设备触发</strong>。比如点击一下鼠标、敲击一下键盘等。</p>

<p>An exception is a synchronous event that is generated when the processor detects one or more predefined conditions while executing an instruction.</p>

<p>再说第二个机制异常（exception），<strong>异常是一个同步事件，是 CPU 在执行指令时检测到的反常条件</strong>。比如除法异常、错误指令异常，缺页异常等。</p>

<p>这两个机制，殊途同归，<strong>都是让 CPU 收到一个中断号</strong>，至于 CPU 收到这个中断号之后干嘛，我们暂且不管。</p>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/GLeh42uInXRaebHKiaWevE73umedjHIDmq0gPkgWwLqjwEibZabXqibsCoCtG03GLQzxIvXh7UK3WYHYNHYWluPNQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" /></p>

<p>我们先看看收到中断号之前，具体就是中断和异常到底是怎么做到给 CPU 一个中断号的。</p>

<p>先说中断，别眨眼。</p>

<p>有一个设备叫做<strong>可编程中断控制器</strong>，它有很多的 <strong>IRQ</strong> 引脚线，接入了一堆能发出中断请求的硬件设备，当这些硬件设备给 IRQ 引脚线发一个信号时，由于可编程中断控制器提前被设置好了 IRQ 与中断号的对应关系，所以就转化成了对应的中断号，把这个中断号存储在自己的一个端口上，然后给 CPU 的 <strong>INTR</strong> 引脚发送一个信号，CPU 收到 INTR 引脚信号后去刚刚的那个端口读取到这个中断号的值。</p>

<p>估计你被绕晕了，但读我的文章有个好处，太复杂就上动图，来吧。
![[image-20230320094930185.png]]</p>

<p>你看，<strong>最终的目标，就是让 CPU 知道，有中断了，并且也知道中断号是多少</strong>。</p>

<p>比如上图中按下了键盘，最终到 CPU 那里的反应就是，得到了一个中断号 <strong>0x21</strong>。</p>

<p>那异常的机制就更简单了，是 CPU 自己执行指令时检测到的一些反常情况，然后自己给自己一个中断号即可，无需外界给。</p>

<p>比如 CPU 执行到了一个无效的指令，则自己给自己一个中断号 <strong>0x06</strong>，这个中断号是 Intel 的 CPU 提前就规定好写死了的硬布线逻辑。</p>

<p>好了，到目前为止，我们知道了无论是<strong>中断</strong>还是<strong>异常</strong>，最终都是通过各种方式，让 CPU 得到一个中断号。只不过中断是通过外部设备给 CPU 的 INTR 引脚发信号，异常是 CPU 自己执行指令的时候发现特殊情况触发的，自己给自己一个中断号。</p>

<p>还有一种方式可以给到 CPU 一个中断号，但 Intel 手册写在了后面，<em>Chapter 6.4.4 INT n</em>，就是大名鼎鼎的 <strong>INT 指令</strong>。
![[image-20230320095004648.png]]</p>

<p>INT 指令后面跟一个数字，就相当于直接用指令的形式，告诉 CPU 一个中断号。</p>

<p>比如 <strong>INT 0x80</strong>，就是告诉 CPU 中断号是 <strong>0x80</strong>。Linux 内核提供的<strong>系统调用</strong>，就是用了 INT 0x80 这种指令。</p>

<p>那我们上面的图又丰富了起来。
![[image-20230320095040034.png]]</p>

<p>有的地方喜欢把他们做一些区分，把 INT n 这种方式叫做<strong>软件中断</strong>，因为他是由软件程序主动触发的。相应的把上面的中断和异常叫做<strong>硬件中断</strong>，因为他们都是硬件自动触发的。</p>

<p>但我觉得大可不必，一共就这么几个分类，干嘛还要增加一层理解的成本呢，记三个方式不好么？</p>

<p>好了，总结一下，给 CPU 一个中断号有三种方式，而这也是中断分类的依据。</p>

<p><em><strong>1.</strong></em> <strong>通过中断控制器给 CPU 的 INTR 引脚发送信号</strong>，并且允许 CPU 从中断控制器的一个端口上读取中断号，比如按下键盘的一个按键，最终会给到 CPU 一个 0x21 中断号。</p>

<p><em><strong>2.</strong></em> <strong>CPU 执行某条指令发现了异常</strong>，会自己触发并给自己一个中断号，比如执行到了无效指令，CPU 会给自己一个 0x06 的中断号。</p>

<p><em><strong>3.</strong></em> <strong>执行 INT n 指令</strong>，会直接给 CPU 一个中断号 n，比如触发了 Linux 的系统调用，实际上就是执行了 INT 0x80 指令，那么 CPU 收到的就是一个 0x80 中断号。</p>

<p>再往后，CPU 以各种不同的方式收到的这些 0x21 0x06 0x80，都会<strong>一视同仁</strong>，做同样的后续处理流程，所以从现在开始，前面的事情就不用再管了，这也体现了分层的好处。</p>

<p><strong>收到中断号之后 CPU 干嘛？</strong></p>

<p>那 CPU 收到中断号后，如何处理呢？</p>

<p>先用一句不太准确的话总结，<strong>CPU 收到一个中断号 n 后，会去中断向量表中寻找第 n 个中断描述符，从中断描述符中找到中断处理程序的地址，然后跳过去执行</strong>。</p>

<p>为什么说不准确呢？因为从中断描述符中找到的，并不直接是程序的地址，而是<strong>段选择子</strong>和<strong>段内偏移地址</strong>。然后段选择子又会去<strong>全局描述符表</strong>中寻找<strong>段描述符</strong>，从中取出<strong>段基址</strong>。之后段基址 + 段内偏移地址，才是最终处理程序的入口地址。</p>

<p><img src="data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E" alt="图片" />当然这个入口地址，还不是最终的物理地址，如果开启了分页，又要经历分页机制的转换，就像下面这样。</p>

<p><img src="data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E" alt="图片" />不过不要担心，这不是中断的主流程，<strong>因为分段机制和分页机制是所有地址转换过程的必经之路，并不是中断这个流程所特有的</strong>。</p>

<p>所以我们简单的把中断描述符表中存储的地址，直接当做 CPU 可以跳过去执行的中断处理程序的入口地址，就好了，不影响理解他们。</p>

<p><img src="data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E" alt="图片" /></p>

<p>你看，这是不是简单很多。</p>

<p>那接下来的问题就很简单了，这里出现了两个名词，那就分别对他们进行发问。</p>

<p><em><strong>1.</strong></em> 中断描述符表是啥？</p>

<p><em><strong>2.</strong></em> 中断描述符是啥？</p>

<p><em><strong>3.</strong></em> 去哪里找他们？</p>

<p>分别回答即可</p>

<blockquote>
  <blockquote>
    <p><strong>中断描述符表是啥？</strong></p>

  </blockquote>
</blockquote>

<p><strong>就是一个在内存中的数组而已</strong>，操作系统初始化过程中，有很多结构都称之为 XXX 表，其实就是个数组罢了。</p>

<p>以 linux-2.6.0 源码为例，就很直观了。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct desc_struct idt_table[256] = { {0, 0}, };
</code></pre></div></div>

<p>你看，是一个大小为 256 的数组。idt_table 这个名字就是 <strong>Interrupt Descriptor Table</strong>，逐字翻译过来确实就是<strong>中断描述符表</strong>。</p>

<blockquote>
  <blockquote>
    <p><strong>中断描述符是啥？</strong></p>

  </blockquote>
</blockquote>

<p><strong>就是中断描述符表这个数组里的存储的数据结构</strong>，通过刚刚的源码也可以看出来，是一个叫 <strong>desc_struct</strong> 的结构。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct desc_struct {    unsigned long a,b;};
</code></pre></div></div>

<p>好家伙，Linux 源码里就这么简单粗暴表示，一个中断描述符的大小为 64 位，也就是 8 个字节，具体里面存的啥通过这个源码看不出来。</p>

<p>翻一下 Intel 手册，在 <em>Volumn 3 Chapter 5.11 IDT Descriptors</em> 中找到了一张图。</p>

<p><img src="data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E" alt="图片" /></p>

<p>可以看到，中断描述符具体还分成好几个种类，有：</p>

<p><strong>Task Gate</strong>：任务门描述符</p>

<p><strong>Interrupt Gate</strong>：中断门描述符</p>

<p><strong>Trap Gate</strong>：陷阱门描述符</p>

<p>不要慌，其中任务门描述符 Linux 中几乎没有用到。</p>

<p>中断门描述符和陷阱门描述符的区别仅仅是<strong>是否允许中断嵌套</strong>，实现方式非常简单粗暴，就是 CPU 如果收到的中断号对应的是一个中断门描述符，就修改 IF 标志位（就是一个寄存器中一位的值），修改了这个值后就屏蔽了中断，也就防止了中断的嵌套。而陷阱门没有改这个标志位，也就允许了中断的嵌套。</p>

<p>所以简单理解的话，你把他们当做同样一个描述符就好了，先别管这些细节，他们的结构几乎完全一样，只是差了一个类型标识罢了。</p>

<p>那这个中断描述符的结构长什么样呢？我们可以清晰地看到，里面有<strong>段选择子</strong>和<strong>段内偏移地址</strong>。</p>

<p><img src="data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E" alt="图片" /></p>

<p>回顾下刚刚说的中断处理流程。</p>

<p><img src="data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E" alt="图片" />没骗你吧。</p>

<p>但以上这些如果你都搞不明白，还是那句话，记这个最简单的流程就好了，不影响理解。</p>

<p><img src="data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E" alt="图片" /></p>

<p>好了，现在我们直观地看到了中断描述符表这个 256 大小的数组，以及它里面存的中断描述符长什么样子，<strong>最终的目的，还是帮助 CPU 找到一个程序的入口地址，然后跳转过去</strong>。</p>

<p>OK，下一个问题，就是 CPU 怎么寻找到这个中断描述符表的位置呢？它是在内存中一个固定的位置么？</p>

<blockquote>
  <blockquote>
    <p><strong>CPU 怎么找到中断描述符表</strong></p>

  </blockquote>
</blockquote>

<p>答案是否定的，<strong>中断描述符表在哪里，全凭各个操作系统的喜好，想放在哪里就放在哪里</strong>，但需要通过某种方式告诉 CPU，即可。</p>

<p>怎么告诉呢？CPU 提前预留了一个寄存器叫 <strong>IDTR 寄存器</strong>，这里面存放的就是中断描述符表的起始地址，以及中断描述符表的大小。</p>

<p>在 <em>Volumn 3 Chapter 5.10 Interrupt Descriptor Table</em> 中告诉了我们 IDTR 寄存器的结构。</p>

<p><img src="data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E" alt="图片" /></p>

<p>操作系统的代码可以通过 <strong>LIDT 指令</strong>，将中断描述符表的地址放在这个寄存器里。</p>

<p>还记得刚刚看的源码么？中断描述符表就是这个。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct desc_struct idt_table[256] = { {0, 0}, };
</code></pre></div></div>

<p>然后操作系统把这个的地址用 <strong>LIDT</strong> 指令放在 <strong>IDTR 寄存器</strong>就行了。IDTR 寄存器里的值一共 48 位，前 16 位是中断描述符表大小（字节数），后 32 位是中断描述符表的起始内存地址，就是这个 idt_table 的位置。</p>

<p>Linux-2.6.0 源码中是这样构造这个结构的，简单粗暴。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>idt_descr:    .word 256 * 8 - 1    .long idt_table
</code></pre></div></div>

<p>紧接着，一个 LIDT 指令把这个结构放到 IDTR 寄存器中。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lidt idt_descr
</code></pre></div></div>

<p>整个过程一气呵成，呵得我连代码格式都懒得调了，是不是很清晰明了。</p>

<p>这样，CPU 收到一个中断号后，<strong>中断描述符表的起始位置从 IDTR 寄存器中可以知道，而且里面的每个中断描述符都是 64 位大小，也就是 8 个字节，那自然就可以找到这个中断号对应的中断描述符</strong>。</p>

<p>接下来的问题就是，这个中断描述符表是谁来提前写好的？又是怎么写的？</p>

<blockquote>
  <blockquote>
    <p><strong>谁把中断描述符表这个结构写在内存的</strong></p>

  </blockquote>
</blockquote>

<p>很简单，操作系统呗。</p>

<p>在 Linux-2.6.0 内核源码的 traps.c 文件中，有这样一段代码。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void __init trap_init(void) {    set_trap_gate(0, &amp;divide_error);    ...    set_trap_gate(6, &amp;invalid_op);    ...    set_intr_gate(14, &amp;page_fault);    ...    set_system_gate(0x80, &amp;system_call);}
</code></pre></div></div>

<p>你看，我们刚刚提到的<strong>除法异常、非法指令异常、缺页异常</strong>，以及之后可能通过 INT 0x80 触发<strong>系统调用</strong>的中断处理函数 system_call，就是这样被写到了中断描述符表里。</p>

<p>经过这样一番操作后，我们的中断描述符表里的值就丰富了起来。</p>

<p>好了，现在只剩下最后一个问题了，CPU 在找到一个中断描述符后，如何跳过去执行？</p>

<blockquote>
  <blockquote>
    <p><strong>找到中断描述符后，干嘛</strong></p>

  </blockquote>
</blockquote>

<p>现在这个问题可以再问得大一些了，就是 <strong>CPU 在收到一个中断号并且找到了中断描述符之后，究竟做了哪些事</strong>？</p>

<p>当然，最简单的办法就是，<strong>直接把中断描述符里的中断程序地址取出来，放在自己的 CS:IP 寄存器中</strong>，因为这里存的值就是下一跳指令的地址，只要放进去了，到下一个 CPU 指令周期时，就会去那里继续执行了。</p>

<p>但 CPU 并没有这样简单粗暴，而是帮助我们程序员做了好多额外的事情，这增加了我们的学习和理解成本，但方便了写操作系统的程序员，拿到一些中断的信息，以及中断程序结束后的返回工作。</p>

<p>但其实，就是做了一些<strong>压栈操作</strong>。</p>

<p><em><strong>1.</strong></em> 如果发生了特权级转移，压入之前的堆栈段寄存器 SS 及栈顶指针 ESP 保存到栈中，并将堆栈切换为 TSS 中的堆栈。</p>

<p><em><strong>2.</strong></em> 压入标志寄存器 EFLAGS。</p>

<p><em><strong>3.</strong></em> 压入之前的代码段寄存器 CS 和指令寄存器 EIP，相当于压入返回地址。</p>

<p><em><strong>4.</strong></em> 如果此中断有错误码的，压入错误码 ERROR_CODE</p>

<p><em><strong>5.</strong></em> 结束（之后就跳转到中断程序了）</p>

<p>压栈操作结束后，栈就变成了这个样子。</p>

<p><img src="data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E" alt="图片" /></p>

<p>特权级的转移需要切换栈，所以提前将之前的<strong>栈指针</strong>压入。<strong>错误码</strong>可以方便中断处理程序做一些工作，如果需要，从栈顶拿到就好了。</p>

<p>抛开这两者不说，剩下的就只有<strong>标志寄存器</strong>和<strong>中断发生前的代码地址</strong>，被压入了栈，这很好理解，就是方便中断程序结束后，返回原来的代码嘛~</p>

<p>具体的压栈工作，以及如何利用这些栈的信息达到结束中断并返回原程序的效果，Intel 手册中也写得很清楚。</p>

<p><em>Volumn 3A System Programming Guide  Chapter 5.12.1Exception- or Interrupt-Handler Procedures</em></p>

<p><img src="data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E" alt="图片" /></p>

<p>看下面的话，通过配合 <strong>IRET</strong> 或 <strong>IRETD</strong> 指令返回。</p>

<p>由于后续版本的 Linux 自己的玩法比较多，已经不用 Intel 提供的现成指令了，所以这回我们从 Linux-0.11 版源码中寻找答案。</p>

<p>比如除法异常的中断处理函数，在 asm.s 中。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_divide_error: push dword ptr _do_divide_error ;no_error_code: ; xchg [esp],eax ; push ebx push ecx push edx push edi push esi push ebp push ds ; push es push fs push 0 ; lea edx,[esp+44] ; push edx mov edx,10h ; mov ds,dx mov es,dx mov fs,dx call eax ; add esp,8 ; pop fs pop es pop ds pop ebp pop esi pop edi pop edx pop ecx pop ebx pop eax ;// 弹出原来eax 中的内容。 iretd
</code></pre></div></div>

<p>只看最后一行，确实用了 iretd 指令。</p>

<p>这个指令会依次弹出栈顶的三个元素，把它们分别赋值给 <strong>EIP，CS 和 EFLAGS</strong>，而栈顶的三个元素，又恰好是 <strong>EIP，CS 和 EFLAGS</strong> 这样的顺序，你说这巧不巧？</p>

<p>当然不巧，人家 CPU 执行中断函数前做了压栈操作，然后又提供了 iret 指令做弹栈操作，当然是给你配套使用的！</p>

<p>你看，<strong>中断是如何切到中断处理程序的？就是靠中断描述符表中记录的地址。那中断又如何回到原来的代码继续执行呢？是通过 CPU 帮我们把中断发生前的地址压入了栈中</strong>，然后我们程序自己利用他们去返回，当然也可以不返回。</p>

<p>这就是 CPU 和操作系统配合的结果，把中断这个事给解决了。</p>

<p><img src="data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E" alt="图片" /></p>

<p><strong>总结</strong></p>

<p>所以总结起来就是，理解中断，只要回答了这几个问题就好。</p>

<p><strong>如何给 CPU 一个中断号？</strong></p>

<p>外部设备通过 INTR 引脚，或者 CPU 执行指令的过程中自己触发，或者由软件通过 INT n 指令强行触发。</p>

<p>同样中断也是这样进行分类的。</p>

<p><strong>CPU 收到中断号后如何寻找到中断程序的入口地址？</strong></p>

<p>通过 IDTR 寄存器找到中断描述符表，通过中断描述符表和中断号定位到中断描述符，取出中断描述符表中存储的程序入口地址。</p>

<p><strong>中断描述符表是谁写的？</strong></p>

<p>操作系统代码写上去的。</p>

<p><strong>找到程序入口地址之后，CPU 做了什么？</strong></p>

<p>简单说，实际上做的事情就是压栈，并跳转到入口地址处执行代码。而压栈的目的，就是保护现场（原来的程序地址、原来的程序堆栈、原来的标志位）和传递信息（错误码）</p>

<p>好了，中断讲完了，如果再往后扩大一点点概念，以上说的中断，统统都是<strong>硬中断</strong>。注意，不叫硬件中断哦。</p>

<p>为什么叫硬中断呢？因为这是 Intel CPU 这个硬件实现的中断机制，注意这里是实现机制，并不是触发机制，因为触发可以通过外部硬件，也可以通过软件的 INT 指令。</p>

<p>那与硬中断对应的还有<strong>软中断</strong>，这个概念网上好多地方都讲错了，把软中断和 INT 指令这种软件中断混淆了，<strong>所以我觉得软件中断最好称其为，由软件触发的中断，而软中断称其为软件实现的中断</strong>。</p>

<p><strong>软中断是纯粹由软件实现的一种类似中断的机制</strong>，实际上它就是模仿硬件，在内存中有一个地方存储着软中断的标志位，然后由内核的一个线程不断轮询这些标志位，如果有哪个标志位有效，则再去另一个地方寻找这个软中断对应的中断处理程序。</p>

<p>软中断是 Linux 实现中断的<strong>下半部</strong>的一种非常常见的方式，之后我讲 Linux 内核如何接受网络包这个事情的时候也可以看到，软中断是研究整个过程的一个突破口。</p>

<ul>
  <li>EOF -</li>
</ul>

<p>推荐阅读  点击标题可跳转</p>

<p>1、<a href="http://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&amp;mid=2666558962&amp;idx=1&amp;sn=ede9eea879107df21557e1b9dcfeeb28&amp;chksm=80dcb159b7ab384f22e68fc32d5556afd3e98c29d08757a871582d526bf5985b0c7c3fd3ec6d&amp;scene=21#wechat_redirect">10 分钟看懂 Docker 和 K8S</a></p>

<p>2、<a href="http://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&amp;mid=2666558647&amp;idx=1&amp;sn=f9f02d09c89ec081c61a717b3724b7fd&amp;chksm=80dcb01cb7ab390a0d89664294542d564e7cc4d539cc6dc30ef997158d1b1ac496a21a991407&amp;scene=21#wechat_redirect">这才是中国被卡脖子最严重的软件！</a></p>

<p>3、<a href="http://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&amp;mid=2666558954&amp;idx=2&amp;sn=775617c1787bb8ab5251444c8762cd44&amp;chksm=80dcb141b7ab38576e44e8149b6f64aab5812d557f7f50a6b8543b375c7a67acac0fe75f00ac&amp;scene=21#wechat_redirect">如果让你来设计网络，你会把它弄成啥样？</a></p>

<p>看完本文有收获？请分享给更多人</p>

<p>推荐关注「Linux 爱好者」，提升Linux技能</p>

<p><img src="http://mmbiz.qpic.cn/mmbiz_png/9aPYe0E1fb3sjicd8JxDra10FRIqT54Zke2sfhibTDdtdnVhv5Qh3wLHZmKPjiaD7piahMAzIH6Cnltd1Nco17Ihjw/0?wx_fmt=png" alt="" /></p>

<p><strong>Linux爱好者</strong></p>

<p>点击获取《每天一个Linux命令》系列和精选Linux技术资源。「Linux爱好者」日常分享 Linux/Unix 相关内容，包括：工具资源、使用技巧、课程书籍等。</p>

<p>75篇原创内容</p>

<p>公众号</p>

<p>点赞和在看就是最大的支持❤️</p>

<p>分享收藏</p>

<p><img src="https://mp.weixin.qq.com/mp/qrcode?scene=10000004&amp;size=102&amp;__biz=MzAxODI5ODMwOA==&amp;mid=2666559053&amp;idx=2&amp;sn=cdd9e3e14102740664c93bfe99bb0044&amp;send_time=" alt="" /></p>

<p>微信扫一扫<br />
关注该公众号</p>]]></content><author><name>Tao He</name></author><category term="Jekyll" /><summary type="html"><![CDATA[【转帖】]]></summary></entry></feed>