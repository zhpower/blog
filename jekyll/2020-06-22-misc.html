<!DOCTYPE HTML>
<html lang="en" >
    <head><meta charset="UTF-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"><title>Kernel Misc · 学习笔记</title><meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="description" content="Build Jekyll site with the GitBook style.
"><meta name="generator" content="Jekyll (using style of GitBook 3.2.3)"><meta name="author" content="kevin_zh"><link rel="stylesheet" href="/blog/assets/gitbook/style.css">
<link rel="stylesheet" href="/blog/assets/gitbook/gitbook-plugin-back-to-top-button/plugin.css">
<link rel="stylesheet" href="/blog/assets/gitbook/gitbook-plugin-expandable-chapters-small2/expandable-chapters-small.css">
<link rel="stylesheet" href="/blog/assets/gitbook/gitbook-plugin-fontsettings/website.css">
<link rel="stylesheet" href="/blog/assets/gitbook/gitbook-plugin-search-pro/search.css">
<link rel="stylesheet" href="/blog/assets/gitbook/gitbook-plugin-splitter/splitter.css">

<link rel="stylesheet" href="/blog/assets/gitbook/rouge/magritte.css">

<link rel="stylesheet" href="/blog/assets/gitbook/custom.css">
<link rel="stylesheet" href="/blog/assets/gitbook/custom-local.css">

<meta name="HandheldFriendly" content="true"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="/blog/assets/gitbook/images/apple-touch-icon-precomposed-152.png">
<link rel="shortcut icon" href="/blog//assets/gitbook/images/favicon.ico" type="image/x-icon">




            <link rel="prev" href="/blog/linux/2018-08-01-DeviceResourceManage.html" />
        

        
            <link rel="next" href="/blog/jekyll/2020-10-02-FuncTrace.html" />
        
    </head>
    <body>
        <div class="book"><div class="book-summary">
    <script type="text/javascript">
        // Fixes the page links scroll problem on both desktop and mobile browsers
        function pageScrollToTop(element) {
            // both mobile and non-mobile
            $('div.body-inner').animate({scrollTop: 0});
            $(element).parent().find('li>ul>li').removeClass('active');
            return true;  // propagate
        }
        // Fixes the anchor links scroll problem on mobile browsers
        function mobilePageScrollToAnchor(element) {
            $(element).closest('li.chapter').find('ul>li').removeClass('active');
            $(element).parent().addClass('active');
            if ($(document).width() <= 1240) {
                $('div.body-inner').animate({scrollTop: $($(element).attr('href')).get(0).offsetTop});
            }
            return true;
        }
    </script>

    <nav role="navigation">
        <div id="book-search-input" role="search">
            <input type="text" placeholder="Type to search" />
        </div>
        <div id="book-search-input-link" role="search">
            <a href="/blog/assets/search.html">Click to Search</a>
        </div>
        <ul class="summary">
            
            <li class="chapter" data-level="1.1" data-path="/blog">
            
                <a href="/blog/" onclick="pageScrollToTop(this)">
                    学习笔记
                </a>
            </li>

            <li class="divider"></li>

            
                <!-- <p>pages</p> -->
                
                    

                    

                    
                
            
                <!-- <p>posts</p> -->
                
                    

                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2000-04-27-linux_grpahic_architecture.html">
                        
                            <a href="/blog/jekyll/2000-04-27-linux_grpahic_architecture.html" onclick="pageScrollToTop(this)">
                                Linux graphic架构
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/graphic/2001-02-01-DRM.html">
                        
                            <a href="/blog/graphic/2001-02-01-DRM.html" onclick="pageScrollToTop(this)">
                                DRM子系统
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/graphic/2002-05-15-Wayland&Weston.html">
                        
                            <a href="/blog/graphic/2002-05-15-Wayland&Weston.html" onclick="pageScrollToTop(this)">
                                Wayland&amp;Weston
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2002-06-11-Weston.html">
                        
                            <a href="/blog/jekyll/2002-06-11-Weston.html" onclick="pageScrollToTop(this)">
                                Weston Misc
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2002-08-10-Wayland-Misc.html">
                        
                            <a href="/blog/jekyll/2002-08-10-Wayland-Misc.html" onclick="pageScrollToTop(this)">
                                Wayland Misc
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2003-08-20-OpenGL_misc.html">
                        
                            <a href="/blog/jekyll/2003-08-20-OpenGL_misc.html" onclick="pageScrollToTop(this)">
                                OpenGL
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2013-03-02-cobalt.html">
                        
                            <a href="/blog/jekyll/2013-03-02-cobalt.html" onclick="pageScrollToTop(this)">
                                Cobalt
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/graphic/2018-03-21-YUV.html">
                        
                            <a href="/blog/graphic/2018-03-21-YUV.html" onclick="pageScrollToTop(this)">
                                YUV编码
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2018-05-20-memory_check.html">
                        
                            <a href="/blog/jekyll/2018-05-20-memory_check.html" onclick="pageScrollToTop(this)">
                                进程内存检查
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/linux/2018-08-01-DeviceResourceManage.html">
                        
                            <a href="/blog/linux/2018-08-01-DeviceResourceManage.html" onclick="pageScrollToTop(this)">
                                设备资源管理模块
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter active" data-level="1.2" data-path="/blog/jekyll/2020-06-22-misc.html">
                        
                            <a href="/blog/jekyll/2020-06-22-misc.html" onclick="pageScrollToTop(this)">
                                Kernel Misc
                            </a>
                            
                                
                                    <ul><li><a href="#kref" onclick="mobilePageScrollToAnchor(this)" >kref</a></li><li><a href="#idrid-range" onclick="mobilePageScrollToAnchor(this)" >IDR(ID Range)</a></li><li><a href="#非一致性内存-和一致性" onclick="mobilePageScrollToAnchor(this)" >非一致性内存 和一致性</a><ul><li><a href="#dma_alloc_noncoherent" onclick="mobilePageScrollToAnchor(this)" >dma_alloc_noncoherent</a></li><li><a href="#dma_alloc_wc" onclick="mobilePageScrollToAnchor(this)" >dma_alloc_wc</a></li></ul></li><li><a href="#定时器" onclick="mobilePageScrollToAnchor(this)" >定时器</a><ul><li><a href="#timer_setup" onclick="mobilePageScrollToAnchor(this)" >timer_setup</a></li><li><a href="#高精度定时器" onclick="mobilePageScrollToAnchor(this)" >高精度定时器</a></li></ul></li><li><a href="#内核线程" onclick="mobilePageScrollToAnchor(this)" >内核线程</a></li><li><a href="#工作队列" onclick="mobilePageScrollToAnchor(this)" >工作队列</a><ul><li><a href="#schedule_work" onclick="mobilePageScrollToAnchor(this)" >schedule_work</a></li><li><a href="#alloc_ordered_workqueue" onclick="mobilePageScrollToAnchor(this)" >alloc_ordered_workqueue</a></li><li><a href="#create_singlethread_workqueue" onclick="mobilePageScrollToAnchor(this)" >create_singlethread_workqueue</a></li></ul></li><li><a href="#completion" onclick="mobilePageScrollToAnchor(this)" >completion</a></li><li><a href="#kobject_uevent_env" onclick="mobilePageScrollToAnchor(this)" >kobject_uevent_env</a></li><li><a href="#benchmark" onclick="mobilePageScrollToAnchor(this)" >benchmark</a></li></ul>

                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2020-10-02-FuncTrace.html">
                        
                            <a href="/blog/jekyll/2020-10-02-FuncTrace.html" onclick="pageScrollToTop(this)">
                                Function Trace
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2021-04-27-ffmpeg.html">
                        
                            <a href="/blog/jekyll/2021-04-27-ffmpeg.html" onclick="pageScrollToTop(this)">
                                ffmpeg命令
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2022-04-27-bit.html">
                        
                            <a href="/blog/jekyll/2022-04-27-bit.html" onclick="pageScrollToTop(this)">
                                位运算
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2022-05-02-App_misc.html">
                        
                            <a href="/blog/jekyll/2022-05-02-App_misc.html" onclick="pageScrollToTop(this)">
                                linux dev misc
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2024-03-22-Camera.html">
                        
                            <a href="/blog/jekyll/2024-03-22-Camera.html" onclick="pageScrollToTop(this)">
                                Camera
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2024-04-27-git.html">
                        
                            <a href="/blog/jekyll/2024-04-27-git.html" onclick="pageScrollToTop(this)">
                                Git
                            </a>
                            
                                
                            
                        </li>
                    

                    
                        <li class="divider"></li>
                    
                
            
        </ul>
    </nav>
</div>
<div class="book-body">
                <div class="book-header" role="navigation">
                    <!-- Title -->
                    <h1>
                        <i class="fa fa-circle-o-notch fa-spin"></i>
                        
                            <a href="." >Kernel Misc</a>
                        
                    </h1>
                </div>

                <div class="body-inner"><div class="page-wrapper" tabindex="-1" role="main">
    

    <div class="page-inner">
        <div id="book-search-results">
            <div class="search-noresults">
                <section class="normal markdown-section">
                    
                        <h1 id="/jekyll/misc">Kernel Misc</h1>
                    

                    <h1 id="kref">kref</h1>

<p>kref_init 是一个用于初始化内核对象引用计数器（krefs）的函数。它允许你为你的对象添加引用计数，确保在多个地方使用和传递对象时，代码的正确性。以下是关于 kref_init 的一些重要信息：</p>

<ul>
  <li>初始化：</li>
</ul>

<p>在分配内存并创建对象后，你需要调用 kref_init 来初始化引用计数器。例如：</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">my_data</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
</code></pre></div></div>

<p>这将在 kref 中的 refcount 设置为 1。</p>

<ul>
  <li>使用规则：</li>
</ul>

<p>在对指针进行非临时拷贝（尤其是传递给另一个执行线程）之前，必须使用 kref_get 增加引用计数。
在完成对指针的处理后，必须调用 kref_put。如果这是对指针的最后一次引用，释放程序将被调用。</p>

<ul>
  <li>示例：</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">data_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">ref</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">my_data</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">my_data</span><span class="p">,</span> <span class="n">refcount</span><span class="p">);</span>
    <span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">more_data_handling</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">cb_data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">my_data</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">cb_data</span><span class="p">;</span>
    <span class="c1">// 处理 data</span>
    <span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="n">data_release</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">my_data_handler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">rv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">my_data</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
    <span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
    <span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
    <span class="c1">// 创建线程处理数据</span>
    <span class="c1">// ...</span>
    <span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="n">data_release</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>在上述示例中，两个线程处理数据的顺序并不重要，kref_put 会在数据不再被引用时释放它。
请注意，遵循这些规则可以确保正确管理内核对象的引用计数，避免内存泄漏和悬挂指针。</p>

<h1 id="idrid-range">IDR(ID Range)</h1>

<p>IDR 是一种用于管理连续整数范围的数据结构，通常用于内核中需要为对象分配唯一标识符的场景。
idr_alloc 函数用于在 Linux 内核中分配 IDR（ID Range）对象中的未使用的 ID。</p>

<p>以下是 idr_alloc 函数的用法：</p>

<ol>
  <li>首先，您需要初始化一个 IDR。对于静态分配的 IDR，您可以使用 DEFINE_IDR() 宏；对于动态分配的 IDR，您可以使用 idr_init() 函数。</li>
  <li>调用 idr_alloc() 来分配一个未使用的 ID。</li>
  <li>使用 idr_find() 查询与该 ID 相关的指针。</li>
  <li>使用 idr_remove() 释放该 ID。</li>
</ol>

<p>如果需要更改与某个 ID 相关联的指针，您可以调用 idr_replace()。这通常用于保留 ID，通过将 NULL 指针传递给分配函数，然后使用保留的 ID 初始化对象，最后将初始化的对象插入 IDR。</p>

<p>到目前为止，所有用户都满足了 UINT_MAX 的限制，因此他们使用 idr_alloc_u32()。</p>

<p>如果需要按顺序分配 ID，您可以使用 idr_alloc_cyclic()。请注意，处理较大数量的 ID 时，IDR 的效率会降低，因此使用这个函数会有一些代价。</p>

<p>当您使用完 IDR 后，可以调用 idr_destroy() 来释放 IDR 占用的内存。这不会释放 IDR 指向的对象；如果您想这样做，请使用其中一个迭代器来执行此操作。</p>

<p>您可以使用 idr_is_empty() 来查看当前是否分配了任何 ID。</p>

<p>如果在从 IDR 分配一个新 ID 时需要带锁，您可能需要传递一组限制性的 GFP 标志，但这可能导致 IDR 无法分配内存。为了解决该问题，您可以在获取锁之前调用 idr_preload()，然后在分配之后调用 idr_preload_end()。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;linux/idr.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">idr</span> <span class="n">my_idr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">id1</span><span class="p">,</span> <span class="n">id2</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">ptr1</span><span class="p">,</span> <span class="o">*</span><span class="n">ptr2</span><span class="p">;</span>

    <span class="c1">// Initialize the IDR</span>
    <span class="n">idr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_idr</span><span class="p">);</span>

    <span class="c1">// Allocate two unused IDs</span>
    <span class="n">id1</span> <span class="o">=</span> <span class="n">idr_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_idr</span><span class="p">,</span> <span class="s">"sample1"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
    <span class="n">id2</span> <span class="o">=</span> <span class="n">idr_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_idr</span><span class="p">,</span> <span class="s">"sample2"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

    <span class="c1">// Associate pointers with the IDs</span>
    <span class="n">ptr1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mh">0xdeadbeef</span><span class="p">;</span>
    <span class="n">ptr2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mh">0xcafebabe</span><span class="p">;</span>
    <span class="n">idr_replace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_idr</span><span class="p">,</span> <span class="n">ptr1</span><span class="p">,</span> <span class="n">id1</span><span class="p">);</span>
    <span class="n">idr_replace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_idr</span><span class="p">,</span> <span class="n">ptr2</span><span class="p">,</span> <span class="n">id2</span><span class="p">);</span>

    <span class="c1">// Look up pointers by ID</span>
    <span class="n">ptr1</span> <span class="o">=</span> <span class="n">idr_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_idr</span><span class="p">,</span> <span class="n">id1</span><span class="p">);</span>
    <span class="n">ptr2</span> <span class="o">=</span> <span class="n">idr_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_idr</span><span class="p">,</span> <span class="n">id2</span><span class="p">);</span>

    <span class="c1">// Free the IDs</span>
    <span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_idr</span><span class="p">,</span> <span class="n">id1</span><span class="p">);</span>
    <span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_idr</span><span class="p">,</span> <span class="n">id2</span><span class="p">);</span>

    <span class="c1">// Destroy the IDR</span>
    <span class="n">idr_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_idr</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<h1 id="非一致性内存-和一致性">非一致性内存 和一致性</h1>

<h2 id="dma_alloc_noncoherent">dma_alloc_noncoherent</h2>

<p>它是Linux内核中的一个DMA内存分配函数，用于分配一段物理内存，使其可以被DMA硬件访问12. 这个函数的作用是在非一致性内存（non-coherent memory）上分配一块区域，以便设备可以使用它作为DMA的源或目标地址。让我详细解释一下这个函数的用途和参数。</p>

<p>dma_alloc_noncoherent函数的原型如下：</p>

<p><code class="language-plaintext highlighter-rouge">void *dma_alloc_noncoherent(struct device *dev, size_t size, dma_addr_t *dma_handle, gfp_t flag);</code></p>

<ul>
  <li>dev: 指向设备结构的指针，表示要为哪个设备分配内存。</li>
  <li>size: 要分配的内存大小（以字节为单位）。</li>
  <li>dma_handle: 用于返回DMA地址的指针。这个地址可以转换为与总线宽度相同的无符号整数，并传递给设备作为分配区域的DMA地址基址。</li>
  <li>flag: 用于指定内存分配的GFP_标志（类似于kmalloc()中的标志）。例如，可以使用GFP_KERNEL来分配普通内核内存。
非一致性内存是一种特殊类型的内存，写入它的数据可以立即被处理器或设备读取，而无需考虑缓存效应。需要注意的是，CPU不能直接引用dma_addr_t，因为物理地址空间和DMA地址空间之间可能存在转换。</li>
</ul>

<p>使用dma_alloc_noncoherent分配的内存区域不保证一致性，因此在使用之前，可能需要手动刷新处理器的写缓冲区，以确保设备可以正确读取该内存。
释放由dma_alloc_noncoherent分配的内存时，应使用dma_free_noncoherent函数：</p>

<p><code class="language-plaintext highlighter-rouge">void dma_free_noncoherent(struct device *dev, size_t size, void *cpu_addr, dma_addr_t dma_handle);</code></p>

<p>dev、size和dma_handle参数必须与传递给dma_alloc_noncoherent的相同。
cpu_addr是由dma_alloc_noncoherent返回的虚拟地址。
请注意，与其他内存分配函数不同，这些函数只能在启用IRQ的情况下调用。</p>

<p>如果你的驱动程序需要大量较小的DMA一致性内存区域，你可以使用DMA池（dma_pool）来分配和管理这些区域，而不是使用dma_alloc_coherent()。DMA池类似于kmem_cache，但它使用dma_alloc_coherent()而不是__get_free_pages()</p>

<h2 id="dma_alloc_wc">dma_alloc_wc</h2>
<p>这个函数允许驱动程序申请带缓存一致性的DMA内存。缓存一致性是指确保CPU和DMA设备之间的数据一致性，以避免数据不一致的问题。使用dma_alloc_wc分配的内存区域旨在在CPU和DMA设备之间保持一致，以便数据正确传输。</p>

<p>释放由dma_alloc_wc分配的内存时，应使用dma_free_wc函数：</p>

<p><code class="language-plaintext highlighter-rouge">void dma_free_wc(struct device *dev, size_t size, void *cpu_addr, dma_addr_t dma_handle);</code></p>

<ul>
  <li>dev、size和dma_handle参数必须与传递给dma_alloc_wc的相同。</li>
  <li>cpu_addr是由dma_alloc_wc返回的虚拟地址。</li>
</ul>

<p><u>adf</u></p>

<h1 id="定时器">定时器</h1>

<h2 id="timer_setup">timer_setup</h2>

<p>它是Linux内核中用于初始化定时器的函数。它能够方便地设置和初始化一个计时器，并通过设置参数来灵活地控制计时器的行为1. 合理使用timer_setup函数可以让我们更好地处理时间相关的任务，提高操作系统的性能和可靠性。</p>

<p>在Linux内核中，定时器通常使用timer_list结构体来表示。下面是timer_list结构体的一些关键字段：</p>

<ul>
  <li>entry: 定时器列表元素，用于将定时器挂载在内核定时器链表上。</li>
  <li>expires: 定时器定时时间。</li>
  <li>function: 定时器回调函数，定时器时间到时执行该函数。</li>
  <li>flags: 标志位，用于设置定时器的属性。</li>
</ul>

<p>在旧版本的内核中，我们使用init_timer函数来初始化定时器。而在新版本中，这个函数变成了timer_setup函数。下面是timer_setup函数的定义：</p>

<p><code class="language-plaintext highlighter-rouge">void timer_setup(struct timer_list *timer, void (*callback)(struct timer_list *), unsigned int flags);</code></p>

<p>使用timer_setup函数时，我们需要传入以下参数：</p>

<ul>
  <li>timer: 要初始化的定时器。</li>
  <li>callback: 定时器的回调函数，此函数的形参是当前定时器的变量。</li>
  <li>flags: 标志位，可以设置定时器的属性。</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;linux/kernel.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/timer.h&gt;</span><span class="cp">
</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">"GPL"</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">timer_list</span> <span class="n">my_timer</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">my_timer_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">"This line is printed after 5 seconds.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_module_with_timer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">"Initializing a module with timer.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="c1">// Setup the timer for initial use</span>
    <span class="n">timer_setup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_timer</span><span class="p">,</span> <span class="n">my_timer_callback</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// Set the timer interval to 5000 milliseconds (5 seconds)</span>
    <span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">5000</span><span class="p">));</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">exit_module_with_timer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">"Goodbye, cruel world!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">init_module_with_timer</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">exit_module_with_timer</span><span class="p">);</span>

</code></pre></div></div>
<h2 id="高精度定时器">高精度定时器</h2>

<p><code class="language-plaintext highlighter-rouge">hrtimer_init</code> 是 Linux 内核中与高精度定时器（HRTimer）相关的函数之一。让我为您详细介绍一下，并提供一个示例代码：</p>

<ol>
  <li><strong>HRTimer 简介</strong>：
    <ul>
      <li>HRTimer 是 Linux 内核中的高精度定时器，用于提供纳秒级别的时钟精度。</li>
      <li>与传统的定时器相比，HRTimer 允许更精确地控制定时事件，适用于对时间要求较高的场景，如看门狗、USB、以太网、块设备、虚拟机等子系统。</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">hrtimer_init</code> 函数</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">hrtimer_init</code> 用于初始化一个 <code class="language-plaintext highlighter-rouge">struct hrtimer</code> 实例。</li>
      <li>参数：
        <ul>
          <li><code class="language-plaintext highlighter-rouge">timer</code>：指向要初始化的 HRTimer 实例的指针。</li>
          <li><code class="language-plaintext highlighter-rouge">clock_id</code>：时钟的种类，例如 <code class="language-plaintext highlighter-rouge">CLOCK_MONOTONIC</code> 表示自系统开机以来的单调递增时间。</li>
          <li><code class="language-plaintext highlighter-rouge">mode</code>：定时器的模式，可以是绝对时间（<code class="language-plaintext highlighter-rouge">HRTIMER_MODE_ABS</code>）或相对时间（<code class="language-plaintext highlighter-rouge">HRTIMER_MODE_REL</code>）。</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>示例代码</strong>：
    <ul>
      <li>下面是一个使用 HRTimer 的简单示例代码，用于在内核中启动一个相对时间的 HRTimer：
        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;linux/hrtimer.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/ktime.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp">
</span>     
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">"GPL"</span><span class="p">);</span>
     
<span class="k">static</span> <span class="k">struct</span> <span class="n">hrtimer</span> <span class="n">my_timer</span><span class="p">;</span>
<span class="k">static</span> <span class="n">ktime_t</span> <span class="n">interval</span><span class="p">;</span>
     
<span class="k">static</span> <span class="k">enum</span> <span class="n">hrtimer_restart</span> <span class="nf">my_timer_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">hrtimer</span> <span class="o">*</span><span class="n">timer</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Your timer callback logic here</span>
    <span class="c1">// For demonstration purposes, let's print a message.</span>
    <span class="n">pr_info</span><span class="p">(</span><span class="s">"HRTimer callback executed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">HRTIMER_RESTART</span><span class="p">;</span>
<span class="p">}</span>
     
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">my_module_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Initialize the HRTimer</span>
    <span class="n">interval</span> <span class="o">=</span> <span class="n">ktime_set</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// Set interval to 1 second</span>
    <span class="n">hrtimer_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_timer</span><span class="p">,</span> <span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="n">HRTIMER_MODE_REL</span><span class="p">);</span>
    <span class="n">my_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">my_timer_callback</span><span class="p">;</span>
     
    <span class="c1">// Start the timer</span>
    <span class="n">hrtimer_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_timer</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">HRTIMER_MODE_REL</span><span class="p">);</span>
     
    <span class="n">pr_info</span><span class="p">(</span><span class="s">"HRTimer module initialized</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
     
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">my_module_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Cleanup: Stop the timer</span>
    <span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_timer</span><span class="p">);</span>
    <span class="n">pr_info</span><span class="p">(</span><span class="s">"HRTimer module removed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
     
<span class="n">module_init</span><span class="p">(</span><span class="n">my_module_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">my_module_exit</span><span class="p">);</span>
</code></pre></div>        </div>
      </li>
      <li>在上述示例中，我们初始化了一个相对时间的 HRTimer，设置了回调函数 <code class="language-plaintext highlighter-rouge">my_timer_callback</code>，并启动了定时器。</li>
    </ul>
  </li>
</ol>

<h1 id="内核线程">内核线程</h1>

<p><strong>kthread_create_worker()</strong> 函数是Linux内核中用于创建内核线程的一个函数。通过设置标志参数和格式化字符串，可以指定创建内核线程的行为和名称。它分配并初始化了一个kthread_worker结构体，并使用它来创建内核线程.</p>

<p>以下是kthread_create_worker函数的一些关键参数：</p>

<ul>
  <li>cpu: 如果大于等于0，将创建特定于某个CPU的工作线程；如果不想创建特定于CPU的工作线程，可以将CPU域赋值为-1。</li>
  <li>flags: 可以设置一些标志位，根据需要来控制内核线程的行为。</li>
  <li>namefmt: 一个格式化字符串，用于指定内核线程的名称。</li>
</ul>

<p>这个函数会分配内存并初始化kthread_worker结构，然后返回指向该结构的指针。您可以根据具体需求使用这个函数来创建和管理内核线程。</p>

<p>如果您需要一个示例代码，以下是一个简单的例子，展示了如何在模块初始化时创建一个内核线程，以及如何在卸载模块时关闭该内核线程：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/kthread.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/delay.h&gt;</span><span class="cp">
</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">"GPL"</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">demo_thr</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">msleep_interruptible</span><span class="p">(</span><span class="mi">2000</span><span class="p">);</span>
        <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"Thread is running...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">thr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kthread_demo_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">thr</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">demo_thr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">"kthread-demo"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">thr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">"Failed to create kthread</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kthread_demo_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">thr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">kthread_stop</span><span class="p">(</span><span class="n">thr</span><span class="p">);</span>
        <span class="n">thr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">kthread_demo_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">kthread_demo_exit</span><span class="p">);</span>
</code></pre></div></div>
<p>在这个示例中，我们使用kthread_run函数创建一个名为kthread-demo的内核线程，它每隔2秒打印一条信息。在卸载模块时，我们使用kthread_stop来关闭该内核线程。</p>

<h1 id="工作队列">工作队列</h1>

<h2 id="schedule_work">schedule_work</h2>

<p>函数是Linux内核中的一个重要函数，用于将一个工作项（work）添加到工作队列（workqueue）中。这个函数的作用是在后台执行一些延迟较长的任务，而不会阻塞主线程的执行。</p>

<p>以下是关于schedule_work函数的一些要点：</p>

<ul>
  <li>功能：将工作项添加到<strong>默认的工作队列</strong>（通常是system_wq）中，以便稍后执行。</li>
  <li>调用方式：schedule_work(&amp;my_work);，其中my_work是一个已经初始化的工作项。</li>
  <li>工作队列：工作队列是一种异步执行机制，用于处理延迟的或非实时的任务。</li>
  <li>延迟执行：schedule_work会将工作项添加到工作队列中，等待系统调度执行。这样，主线程可以继续执行其他任务，而不必等待工作项完成。</li>
  <li>工作项回调函数：工作项的实际执行逻辑由回调函数定义。当工作项被调度执行时，会调用这个回调函数。</li>
</ul>

<p>以下是一个简单的示例代码，展示了如何使用INIT_WORK和schedule_work来创建和调度一个工作项：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;linux/init.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/kernel.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/workqueue.h&gt;</span><span class="cp">
</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">"GPL"</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">work_struct</span> <span class="n">my_work</span><span class="p">;</span>

<span class="c1">// 工作项的回调函数</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">my_work_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"My work handler is running...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="c1">// 在这里执行您的工作逻辑</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_my_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"Initializing my kernel module with workqueue...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="c1">// 初始化工作项</span>
    <span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_work</span><span class="p">,</span> <span class="n">my_work_handler</span><span class="p">);</span>

    <span class="c1">// 将工作项添加到工作队列</span>
    <span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_work</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cleanup_my_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"Cleaning up my kernel module...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">init_my_module</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">cleanup_my_module</span><span class="p">);</span>
</code></pre></div></div>
<p>在这个示例中，我们首先定义了一个名为my_workqueue的工作队列结构体，以及一个名为my_work的工作项。然后，在init_my_module函数中使用create_singlethread_workqueue来创建一个名为my_workqueue的工作队列。接着，我们使用INIT_WORK来初始化工作项，并使用schedule_work来调度它。</p>

<h2 id="alloc_ordered_workqueue">alloc_ordered_workqueue</h2>

<p>用于创建<strong>有序</strong>的工作队列（workqueue）。让我详细介绍一下，并提供一个示例代码：</p>

<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">alloc_ordered_workqueue</code> 简介</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">alloc_ordered_workqueue</code> 函数用于分配一个有序的工作队列。</li>
      <li>有序工作队列是一种特殊类型的工作队列，它确保工作项按照提交的顺序执行。</li>
    </ul>
  </li>
  <li><strong>函数签名</strong>：
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="nf">alloc_ordered_workqueue</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li><strong>参数说明</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">name</code>：工作队列的名称。</li>
      <li><code class="language-plaintext highlighter-rouge">flags</code>：标志位，用于配置工作队列的行为。</li>
    </ul>
  </li>
  <li>
    <p><strong>示例代码</strong>：</p>

    <p>下面是一个简单的示例代码，展示如何使用 <code class="language-plaintext highlighter-rouge">alloc_ordered_workqueue</code> 创建一个有序的工作队列：</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;linux/init.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/workqueue.h&gt;</span><span class="cp">
</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">my_ordered_wq</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">my_work_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pr_info</span><span class="p">(</span><span class="s">"Work item executed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="nf">DECLARE_WORK</span><span class="p">(</span><span class="n">my_work</span><span class="p">,</span> <span class="n">my_work_handler</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">my_module_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">my_ordered_wq</span> <span class="o">=</span> <span class="n">alloc_ordered_workqueue</span><span class="p">(</span><span class="s">"my_ordered_wq"</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">my_ordered_wq</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pr_err</span><span class="p">(</span><span class="s">"Failed to create ordered workqueue</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">queue_work</span><span class="p">(</span><span class="n">my_ordered_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_work</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">my_module_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">my_ordered_wq</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">my_module_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">my_module_exit</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">"GPL"</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">"Ordered Workqueue Example"</span><span class="p">);</span>
</code></pre></div>    </div>

    <p>在此示例中，我们创建了一个名为 “my_ordered_wq” 的有序工作队列，并将一个工作项 <code class="language-plaintext highlighter-rouge">my_work</code> 提交到队列中。工作项的处理函数 <code class="language-plaintext highlighter-rouge">my_work_handler</code> 将在有序的顺序中执行。</p>
  </li>
</ol>

<h2 id="create_singlethread_workqueue">create_singlethread_workqueue</h2>

<p><code class="language-plaintext highlighter-rouge">create_singlethread_workqueue</code> 是 Linux 内核中的一个函数，用于创建一个只包含单个工作线程的工作队列（workqueue）。让我详细介绍一下：🙂</p>

<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">create_singlethread_workqueue</code> 简介</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">create_singlethread_workqueue</code> 函数用于创建一个只包含一个工作线程的工作队列。</li>
      <li><strong>无论系统中有多少个 CPU，这个工作队列都只会有一个工作线程</strong>。</li>
    </ul>
  </li>
  <li><strong>函数签名</strong>：
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="nf">create_singlethread_workqueue</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li><strong>参数说明</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">name</code>：工作队列的名称。</li>
    </ul>
  </li>
  <li><strong>工作原理</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">create_singlethread_workqueue</code> 创建的工作队列只有一个工作线程。</li>
      <li>所有提交到这个工作队列的工作项都会由这个单一的工作线程按顺序执行。</li>
    </ul>
  </li>
  <li>
    <p><strong>示例代码</strong>：
下面是一个简单的示例代码，展示如何使用 <code class="language-plaintext highlighter-rouge">create_singlethread_workqueue</code> 创建一个只包含单个工作线程的工作队列：</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;linux/init.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/workqueue.h&gt;</span><span class="cp">
</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">my_singlethread_wq</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">my_work_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pr_info</span><span class="p">(</span><span class="s">"Work item executed!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="nf">DECLARE_WORK</span><span class="p">(</span><span class="n">my_work</span><span class="p">,</span> <span class="n">my_work_handler</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">my_module_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">my_singlethread_wq</span> <span class="o">=</span> <span class="n">create_singlethread_workqueue</span><span class="p">(</span><span class="s">"my_singlethread_wq"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">my_singlethread_wq</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pr_err</span><span class="p">(</span><span class="s">"Failed to create singlethread workqueue</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">queue_work</span><span class="p">(</span><span class="n">my_singlethread_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_work</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">my_module_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">my_singlethread_wq</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">my_module_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">my_module_exit</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">"GPL"</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">"Singlethread Workqueue Example"</span><span class="p">);</span>
</code></pre></div>    </div>

    <p>在此示例中，我们创建了一个名为 “my_singlethread_wq” 的工作队列，并将一个工作项 <code class="language-plaintext highlighter-rouge">my_work</code> 提交到队列中。这个工作项的处理函数 <code class="language-plaintext highlighter-rouge">my_work_handler</code> 将在单一的工作线程中按顺序执行。</p>
  </li>
</ol>

<h1 id="completion">completion</h1>

<p>init_completion() 是Linux内核中用于完成事件通知机制的一个函数，主要用于进程间或线程间的同步。这个函数初始化一个 completion 结构体，该结构体用于表示某个事件是否已经发生。在多线程或多进程编程中，有时需要一个线程或进程等待另一个线程或进程完成某个任务。</p>

<p>让我们来详细了解一下 init_completion() 函数的功能和用法：</p>

<ul>
  <li>初始化completion结构体：
    <ul>
      <li>completion 结构体用于维护“complete”状态，表示某个任务是否已完成。</li>
      <li>结构体定义如下：
        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">completion</span> <span class="p">{</span>
   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">done</span><span class="p">;</span>
   <span class="k">struct</span> <span class="n">swait_queue_head</span> <span class="n">wait</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>        </div>
      </li>
      <li>done 字段表示完成状态，初始值为 0。</li>
      <li>swait_queue_head 是一个等待队列头，用于管理等待该完成事件的线程。</li>
    </ul>
  </li>
  <li>init_completion() 函数：
    <ul>
      <li>动态定义及初始化一个信号量：
        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define init_completion(x) __init_completion(x)
</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__init_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">x</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="n">init_swait_queue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>这个函数实际上是初始化了 completion 结构体中的信号量。</li>
    </ul>
  </li>
  <li>等待完成：
    <ul>
      <li>等待信号量的释放：
        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">__sched</span> <span class="nf">wait_for_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">wait_for_common</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">MAX_SCHEDULE_TIMEOUT</span><span class="p">,</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>发信端：</p>

    <ul>
      <li>complete() 函数用于唤醒等待该完成事件的单个线程：
        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">!=</span> <span class="n">UINT_MAX</span><span class="p">)</span>
       <span class="n">x</span><span class="o">-&gt;</span><span class="n">done</span><span class="o">++</span><span class="p">;</span>
    <span class="n">swake_up_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
    <span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>同时唤醒所有等待线程：
    <ul>
      <li>complete_all() 函数用于唤醒等待此特定完成事件的所有线程：
        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">complete_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">lockdep_assert_RT_in_threaded_ctx</span><span class="p">();</span>
    <span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
    <span class="n">x</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">=</span> <span class="n">UINT_MAX</span><span class="p">;</span>
    <span class="n">swake_up_all_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
    <span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>完整示例</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/init.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/completion.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/delay.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/kthread.h&gt;</span><span class="cp">
</span><span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">"GPL"</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">"kevin"</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">completion</span> <span class="n">my_completion</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">){</span>
    <span class="n">pr_info</span><span class="p">(</span><span class="s">"My thread is waiting for completion...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_completion</span><span class="p">);</span>
    <span class="n">pr_info</span><span class="p">(</span><span class="s">"My thread woke up! Event completed.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">my_init</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">pr_info</span><span class="p">(</span><span class="s">"Initializing my module...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_completion</span><span class="p">);</span>
    <span class="c1">// Start a new kernel thread</span>
    <span class="n">kthread_run</span><span class="p">(</span><span class="n">my_thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">"my_thread"</span><span class="p">);</span>
    <span class="c1">// Simulate some work...</span>
    <span class="n">msleep</span><span class="p">(</span><span class="mi">2000</span><span class="p">);</span>
    <span class="n">pr_info</span><span class="p">(</span><span class="s">"Completing the event...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_completion</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">my_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">pr_info</span><span class="p">(</span><span class="s">"Exiting my module...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">my_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">my_exit</span><span class="p">);</span>
</code></pre></div></div>

<h1 id="kobject_uevent_env">kobject_uevent_env</h1>

<p>它是 <strong>Linux 内核</strong> 中的一个函数，用于在 <strong>kobject</strong> 状态发生变化时发送 <strong>uevent</strong> 到用户空间。让我详细解释一下：</p>

<ol>
  <li><strong>kobject</strong>：
    <ul>
      <li><strong>kobject</strong> 是内核中的一个抽象对象，用于表示各种内核数据结构，例如设备、驱动程序、总线等。</li>
      <li>每个 <strong>kobject</strong> 都有一个名称、引用计数和其他属性。</li>
    </ul>
  </li>
  <li><strong>uevent</strong>：
    <ul>
      <li><strong>uevent</strong> 是用户空间事件的缩写，用于通知用户空间程序内核中的状态变化。</li>
      <li>例如，当设备插入或移除时，内核会生成相应的 <strong>uevent</strong>。</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">kobject_uevent_env</code> 函数</strong>：
    <ul>
      <li>这个函数用于发送 <strong>uevent</strong> 到用户空间。</li>
      <li>它接受一个指向 <strong>kobject</strong> 的指针和一个表示 <strong>uevent</strong> 的环境变量数组。</li>
      <li>用户空间程序可以监听这些事件并做出相应的处理。</li>
    </ul>
  </li>
  <li><strong>使用示例</strong>：
    <ul>
      <li>在设备驱动程序中，当设备状态发生变化时，例如设备插入或移除，可以使用 <code class="language-plaintext highlighter-rouge">kobject_uevent_env</code> 发送相应的 <strong>uevent</strong>。</li>
      <li>用户空间程序收到这些事件后，可以根据需要执行操作。</li>
    </ul>
  </li>
</ol>

<p>以下是一个简单的示例代码，展示了如何在内核模块中使用 <code class="language-plaintext highlighter-rouge">kobject_uevent_env</code> 发送 <strong>uevent</strong>：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/init.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/kobject.h&gt;</span><span class="cp">
</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">my_kobj</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_uevent</span><span class="p">(</span><span class="k">struct</span> <span class="n">kset</span> <span class="o">*</span><span class="n">kset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_uevent_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Add custom environment variables to the uevent</span>
    <span class="n">add_uevent_var</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s">"MY_CUSTOM_VAR=hello_world"</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kset_uevent_ops</span> <span class="n">my_uevent_ops</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">uevent</span> <span class="o">=</span> <span class="n">my_uevent</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">my_module_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">my_kobj</span> <span class="o">=</span> <span class="n">kobject_create_and_add</span><span class="p">(</span><span class="s">"my_kobject"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">my_kobj</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

    <span class="n">my_kobj</span><span class="o">-&gt;</span><span class="n">kset</span> <span class="o">=</span> <span class="n">kset_create_and_add</span><span class="p">(</span><span class="s">"my_kset"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">my_kobj</span><span class="o">-&gt;</span><span class="n">kset</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">kobject_put</span><span class="p">(</span><span class="n">my_kobj</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">my_kobj</span><span class="o">-&gt;</span><span class="n">kset</span><span class="o">-&gt;</span><span class="n">uevent_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_uevent_ops</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">my_module_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">kset_unregister</span><span class="p">(</span><span class="n">my_kobj</span><span class="o">-&gt;</span><span class="n">kset</span><span class="p">);</span>
    <span class="n">kobject_put</span><span class="p">(</span><span class="n">my_kobj</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">my_module_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">my_module_exit</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">"GPL"</span><span class="p">);</span>
</code></pre></div></div>

<p>在此示例中，我们创建了一个名为 <code class="language-plaintext highlighter-rouge">my_kobject</code> 的 <strong>kobject</strong>，并将其添加到一个名为 <code class="language-plaintext highlighter-rouge">my_kset</code> 的 <strong>kset</strong> 中。然后，我们设置了一个自定义的 <strong>uevent</strong>，将环境变量 <code class="language-plaintext highlighter-rouge">MY_CUSTOM_VAR</code> 添加到 <strong>uevent</strong> 中。</p>

<p>请注意，实际应用中，您需要根据您的需求自定义更多的环境变量和处理逻辑。</p>

<h1 id="benchmark">benchmark</h1>

<ul>
  <li>
    <p>DRM kernel aspects (display and render):</p>

    <p>IGT GPU Tools (IGT): main DRM test suite, used for CI</p>

    <p><a href="https://gitlab.freedesktop.org/drm/igt-gpu-tools/">https://gitlab.freedesktop.org/drm/igt-gpu-tools/</a></p>
  </li>
  <li>
    <p>OpenGL aspects:</p>

    <ul>
      <li>
        <p>drawElements Quality Program (dEQP): OpenGL/OpenGL ES/Vulkan conformance tests</p>

        <p><a href="https://android.googlesource.com/platform/external/deqp/">https://android.googlesource.com/platform/external/deqp/</a></p>
      </li>
      <li>
        <p>glmark2: OpenGL 2.0 and ES 2.0 benchmark tool</p>

        <p><a href="https://github.com/glmark2/glmark2/">https://github.com/glmark2/glmark2/</a></p>
      </li>
    </ul>
  </li>
  <li>
    <p>Patch series continuous integration:</p>

    <p>EzBench: a collection of tools to benchmark graphics-related patch-series</p>

    <p><a href="https://github.com/freedesktop/ezbench/">https://github.com/freedesktop/ezbench/</a></p>
  </li>
  <li>
    <p>General benchmarking (including graphics):</p>

    <p>Phoronix Test Suite: automated benchmarking tool</p>

    <p><a href="https://github.com/phoronix-test-suite/phoronix-test-suite/">https://github.com/phoronix-test-suite/phoronix-test-suite/</a></p>
  </li>
</ul>
</section>
            </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div></div>
    </div>
</div>

<!-- introduce mathjax support -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ['$', '$'], ['\\(', '\\)'] ]
  },
  svg: {
    fontCache: 'global'
  }
};
</script>
<script
  type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>


<!-- introduce per-page mermaid support -->

    <script>
    function render_mermaid() {
        mermaid.initialize({
            startOnLoad: false,
            theme: "default",
        });
        window.mermaid.init(undefined, document.querySelectorAll('.language-mermaid'));
    }

    function initialize_mermaid() {
        if (document.readyState === "loading") {
            // Loading hasn't finished yet
            document.addEventListener("DOMContentLoaded", render_mermaid);
        } else {
            // `DOMContentLoaded` has already fired
            render_mermaid();
        }
    }

    if (window.mermaid_script && window.mermaid) {
        initialize_mermaid();
    } else {
        window.mermaid_script = document.createElement("script");
        mermaid_script.onload = initialize_mermaid;
        document.head.appendChild(mermaid_script);
        mermaid_script.defer = true;
        mermaid_script.id = 'mermaid-script';
        mermaid_script.src = '/blog/assets/gitbook/mermaid.min.js';
    }
</script>



<!-- introduce mathjax support -->
<script>
    function fixes_chrome_anchors() {
        let chrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
        if (window.location.hash && chrome) {
            setTimeout(function () {
                var hash = window.location.hash;
                window.location.hash = "";
                window.location.hash = hash;
            }, 300);
        }
    }

    if (document.readyState === "loading") {
        // Loading hasn't finished yet
        document.addEventListener("DOMContentLoaded", fixes_chrome_anchors);
    } else {
        // `DOMContentLoaded` has already fired
        fixes_chrome_anchors();
    }
</script>


                        <a href="/blog/linux/2018-08-01-DeviceResourceManage.html" class="navigation navigation-prev navigation-unique" aria-label="Previous page: 设备资源管理模块">
                            <i class="fa fa-angle-left"></i>
                        </a>
                    

                    
                        <a href="/blog/jekyll/2020-10-02-FuncTrace.html" class="navigation navigation-next navigation-unique" aria-label="Next page: Function Trace">
                            <i class="fa fa-angle-right"></i>
                        </a>
                    
                </div>
            </div>

            <script>
            var gitbook = gitbook || [];
            gitbook.push(function() {
                gitbook.page.hasChanged({
    "page": {
        "title": "Introduction",
        "level": "1.1",
        "depth": 1,
        
        "next": {
            "title": "Function Trace",
            "level": "1.2",
            "depth": 1,
            "path": "_posts/2020-10-02-FuncTrace.md",
            "ref": "_posts/2020-10-02-FuncTrace.md",
            "articles": []
        },
        
        "dir": "ltr"
    },    "config": {
        "plugins": ["fontsettings", "highlight", "livereload", "lunr", "search", "sharing", "theme-default", "livereload"],
        "styles": {
            "ebook": "styles/ebook.css",
            "epub": "styles/epub.css",
            "mobi": "styles/mobi.css",
            "pdf": "styles/pdf.css",
            "print": "styles/print.css",
            "website": "styles/website.css"
        },
        "pluginsConfig": {
            "expandable-chapter-small2": {
                "articlesExpand": true,
            },
            "fontsettings": {
                "family": "sans",
                "size": 2,
                "theme": "white"
            },
            "highlight": {},
            "livereload": {},
            "lunr": {
                "ignoreSpecialCharacters": false,
                "maxIndexSize": 1000000
            },
            "search": {},            "sharing": {
                "facebook": false,

                "google": false,

                "github": false,
              
                "github_link": "https://github.com",
              

                "telegram": false,
                "telegram_link": "https://t.me",

                "instapaper": false,

                "twitter": false,
              

                "vk": false,

                "weibo": false,

                "all": ["facebook", "google", "twitter", "weibo", "instapaper", "github", "telegram"]
            },
"theme-default": {
                "showLevel": false,
                "styles": {
                    "ebook": "styles/ebook.css",
                    "epub": "styles/epub.css",
                    "mobi": "styles/mobi.css",
                    "pdf": "styles/pdf.css",
                    "print": "styles/print.css",
                    "website": "styles/website.css"
                }
            },
        },
        "theme": "default",
        "author": "Tao He",
        "pdf": {
            "pageNumbers": true,
            "fontSize": 12,
            "fontFamily": "Arial",
            "paperSize": "a4",
            "chapterMark": "pagebreak",
            "pageBreaksBefore": "/",
            "margin": {
                "right": 62,
                "left": 62,
                "top": 56,
                "bottom": 56
            }
        },
        "structure": {
            "langs": "LANGS.md",
            "readme": "README.md",
        },
        "variables": {},
        "title": "学习笔记",
        "language": "en",
        "gitbook": "*"
    },
    "file": {
        "path": "_posts/2022-06-22-misc.md",
        "mtime": "2020-06-22 00:00:00 +0800",
        "type": "markdown"
    },
    "gitbook": {
        "version": "3.2.3"
    },
    "basePath": "/blog",
    "book": {
        "language": ""
    }
});
            });
            </script>
        </div><script src="/blog/assets/gitbook/gitbook.js"></script>
<script src="/blog/assets/gitbook/theme.js"></script>

<script src="/blog/assets/gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
<script src="/blog/assets/gitbook/gitbook-plugin-copy-code-button/toggle.js"></script>
<script src="/blog/assets/gitbook/gitbook-plugin-expandable-chapters-small2/expandable-chapters-small.js"></script>
<script src="/blog/assets/gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
<script src="/blog/assets/gitbook/gitbook-plugin-search-pro/jquery.mark.min.js"></script>
<script src="/blog/assets/gitbook/gitbook-plugin-search-pro/search.js"></script>
<!-- <script src="/blog/assets/gitbook/gitbook-plugin-sharing/buttons.js"></script> -->
<script src="/blog/assets/gitbook/gitbook-plugin-splitter/splitter.js"></script>

<!--
<script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
<script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
<script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
<script src="../gitbook/gitbook-plugin-search/search.js"></script>
-->

</body>
</html>