<!DOCTYPE HTML>
<html lang="en" >
    <head><meta charset="UTF-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"><title>OpenGL · 学习笔记</title><meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="description" content="Build Jekyll site with the GitBook style.
"><meta name="generator" content="Jekyll (using style of GitBook 3.2.3)"><meta name="author" content="kevin_zh"><link rel="stylesheet" href="/blog/assets/gitbook/style.css">
<link rel="stylesheet" href="/blog/assets/gitbook/gitbook-plugin-back-to-top-button/plugin.css">
<link rel="stylesheet" href="/blog/assets/gitbook/gitbook-plugin-expandable-chapters-small2/expandable-chapters-small.css">
<link rel="stylesheet" href="/blog/assets/gitbook/gitbook-plugin-fontsettings/website.css">
<link rel="stylesheet" href="/blog/assets/gitbook/gitbook-plugin-search-pro/search.css">
<link rel="stylesheet" href="/blog/assets/gitbook/gitbook-plugin-splitter/splitter.css">

<link rel="stylesheet" href="/blog/assets/gitbook/rouge/magritte.css">

<link rel="stylesheet" href="/blog/assets/gitbook/custom.css">
<link rel="stylesheet" href="/blog/assets/gitbook/custom-local.css">

<meta name="HandheldFriendly" content="true"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="/blog/assets/gitbook/images/apple-touch-icon-precomposed-152.png">
<link rel="shortcut icon" href="/blog//assets/gitbook/images/favicon.ico" type="image/x-icon">




            <link rel="prev" href="/blog/jekyll/2002-08-10-Wayland-Misc.html" />
        

        
            <link rel="next" href="/blog/jekyll/2013-03-02-cobalt.html" />
        
    </head>
    <body>
        <div class="book"><div class="book-summary">
    <script type="text/javascript">
        // Fixes the page links scroll problem on both desktop and mobile browsers
        function pageScrollToTop(element) {
            // both mobile and non-mobile
            $('div.body-inner').animate({scrollTop: 0});
            $(element).parent().find('li>ul>li').removeClass('active');
            return true;  // propagate
        }
        // Fixes the anchor links scroll problem on mobile browsers
        function mobilePageScrollToAnchor(element) {
            $(element).closest('li.chapter').find('ul>li').removeClass('active');
            $(element).parent().addClass('active');
            if ($(document).width() <= 1240) {
                $('div.body-inner').animate({scrollTop: $($(element).attr('href')).get(0).offsetTop});
            }
            return true;
        }
    </script>

    <nav role="navigation">
        <div id="book-search-input" role="search">
            <input type="text" placeholder="Type to search" />
        </div>
        <div id="book-search-input-link" role="search">
            <a href="/blog/assets/search.html">Click to Search</a>
        </div>
        <ul class="summary">
            
            <li class="chapter" data-level="1.1" data-path="/blog">
            
                <a href="/blog/" onclick="pageScrollToTop(this)">
                    学习笔记
                </a>
            </li>

            <li class="divider"></li>

            
                <!-- <p>pages</p> -->
                
                    

                    

                    
                
            
                <!-- <p>posts</p> -->
                
                    

                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2000-04-27-linux_grpahic_architecture.html">
                        
                            <a href="/blog/jekyll/2000-04-27-linux_grpahic_architecture.html" onclick="pageScrollToTop(this)">
                                Linux graphic arch
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/graphic/2001-02-01-DRM.html">
                        
                            <a href="/blog/graphic/2001-02-01-DRM.html" onclick="pageScrollToTop(this)">
                                DRM子系统
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/graphic/2002-05-15-Wayland&Weston.html">
                        
                            <a href="/blog/graphic/2002-05-15-Wayland&Weston.html" onclick="pageScrollToTop(this)">
                                Wayland&amp;Weston
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2002-06-11-Weston.html">
                        
                            <a href="/blog/jekyll/2002-06-11-Weston.html" onclick="pageScrollToTop(this)">
                                Weston Misc
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2002-08-10-Wayland-Misc.html">
                        
                            <a href="/blog/jekyll/2002-08-10-Wayland-Misc.html" onclick="pageScrollToTop(this)">
                                Wayland Misc
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter active" data-level="1.2" data-path="/blog/jekyll/2003-08-20-OpenGL_misc.html">
                        
                            <a href="/blog/jekyll/2003-08-20-OpenGL_misc.html" onclick="pageScrollToTop(this)">
                                OpenGL
                            </a>
                            
                                
                                    <ul><li><a href="#glinvalidateframebuffer-vs-glclear" onclick="mobilePageScrollToAnchor(this)" >glInvalidateFramebuffer vs glClear</a></li><li><a href="#gldiscardframebufferext" onclick="mobilePageScrollToAnchor(this)" >glDiscardFramebufferEXT</a></li><li><a href="#texture-obj与rbo的区别" onclick="mobilePageScrollToAnchor(this)" >Texture obj与RBO的区别</a></li><li><a href="#shader" onclick="mobilePageScrollToAnchor(this)" >shader</a><ul><li><a href="#初始化" onclick="mobilePageScrollToAnchor(this)" >初始化</a></li><li><a href="#变量" onclick="mobilePageScrollToAnchor(this)" >变量</a></li></ul></li><li><a href="#资源释放" onclick="mobilePageScrollToAnchor(this)" >资源释放</a></li><li><a href="#纹理过滤" onclick="mobilePageScrollToAnchor(this)" >纹理过滤</a></li><li><a href="#纹理环绕" onclick="mobilePageScrollToAnchor(this)" >纹理环绕</a></li><li><a href="#glmapbufferrange" onclick="mobilePageScrollToAnchor(this)" >glMapBufferRange</a></li><li><a href="#freetype" onclick="mobilePageScrollToAnchor(this)" >freetype</a></li></ul>

                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2013-03-02-cobalt.html">
                        
                            <a href="/blog/jekyll/2013-03-02-cobalt.html" onclick="pageScrollToTop(this)">
                                Cobalt
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/graphic/2018-03-21-YUV.html">
                        
                            <a href="/blog/graphic/2018-03-21-YUV.html" onclick="pageScrollToTop(this)">
                                YUV编码
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2018-05-20-memory_check.html">
                        
                            <a href="/blog/jekyll/2018-05-20-memory_check.html" onclick="pageScrollToTop(this)">
                                进程内存检查
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/linux/2018-08-01-DeviceResourceManage.html">
                        
                            <a href="/blog/linux/2018-08-01-DeviceResourceManage.html" onclick="pageScrollToTop(this)">
                                设备资源管理模块
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2020-06-22-misc.html">
                        
                            <a href="/blog/jekyll/2020-06-22-misc.html" onclick="pageScrollToTop(this)">
                                Kernel Misc
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2020-10-02-FuncTrace.html">
                        
                            <a href="/blog/jekyll/2020-10-02-FuncTrace.html" onclick="pageScrollToTop(this)">
                                Function Trace
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2021-04-27-ffmpeg.html">
                        
                            <a href="/blog/jekyll/2021-04-27-ffmpeg.html" onclick="pageScrollToTop(this)">
                                ffmpeg命令
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2022-04-27-bit.html">
                        
                            <a href="/blog/jekyll/2022-04-27-bit.html" onclick="pageScrollToTop(this)">
                                位运算
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2022-05-02-App_misc.html">
                        
                            <a href="/blog/jekyll/2022-05-02-App_misc.html" onclick="pageScrollToTop(this)">
                                linux dev misc
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2024-04-27-git.html">
                        
                            <a href="/blog/jekyll/2024-04-27-git.html" onclick="pageScrollToTop(this)">
                                Git
                            </a>
                            
                                
                            
                        </li>
                    

                    
                        <li class="divider"></li>
                    
                
            
        </ul>
    </nav>
</div>
<div class="book-body">
                <div class="book-header" role="navigation">
                    <!-- Title -->
                    <h1>
                        <i class="fa fa-circle-o-notch fa-spin"></i>
                        
                            <a href="." >OpenGL</a>
                        
                    </h1>
                </div>

                <div class="body-inner"><div class="page-wrapper" tabindex="-1" role="main">
    

    <div class="page-inner">
        <div id="book-search-results">
            <div class="search-noresults">
                <section class="normal markdown-section">
                    
                        <h1 id="/jekyll/OpenGL_misc">OpenGL</h1>
                    

                    <h1 id="glinvalidateframebuffer-vs-glclear">glInvalidateFramebuffer vs glClear</h1>

<p>glInvalidateFramebuffer 和 glClear 是OpenGL中两个不同的函数，它们的作用和用法有所不同：</p>

<ul>
  <li>glInvalidateFramebuffer：
    <ul>
      <li>功能：glInvalidateFramebuffer 用于显式地标记帧缓冲区的某些部分为无效。这样，GPU就知道这些部分的内容不再需要，可以避免不必要的数据交换。</li>
      <li>应用场景：通常在使用帧缓冲区对象（FBO）时，当我们切换到不同的FBO或者不再需要某些颜色、深度或模板缓冲区的内容时，可以调用该函数。</li>
      <li>性能影响：尽管在RenderDoc等工具中可能显示glInvalidateFramebuffer的耗时较高，但实际上，只有少数几次调用不会对渲染性能产生影响。</li>
    </ul>
  </li>
  <li>glClear：
    <ul>
      <li>功能：glClear 用于清除当前帧缓冲区的内容，包括颜色缓冲区、深度缓冲区和模板缓冲区。</li>
      <li>应用场景：在每一帧开始时，我们通常会调用glClear来准备帧缓冲区，以便进行新的绘制。</li>
      <li>性能影响：glClear的性能开销通常较小，但在某些情况下，如果频繁调用，可能会影响性能。</li>
    </ul>
  </li>
</ul>

<p>总结：</p>
<ul>
  <li>glInvalidateFramebuffer 用于标记帧缓冲区的部分内容为无效，以减少不必要的数据交换。</li>
  <li>glClear 用于清除整个帧缓冲区的内容，以准备进行新的绘制。</li>
  <li>在使用RenderDoc等工具时，可以忽略glInvalidateFramebuffer的耗时，但需要关注片上高速缓存回写内存的消耗  。</li>
</ul>

<h1 id="gldiscardframebufferext">glDiscardFramebufferEXT</h1>

<p><code class="language-plaintext highlighter-rouge">void glDiscardFramebufferEXT(enum target, sizei numAttachments, const enum *attachments);</code></p>

<p>这个扩展提供了一个新的命令，glDiscardFramebufferEXT，它会使得指定帧缓冲附件的内容变为未定义状态。在未来的操作修改内容之前，这些指定缓冲区的内容是未定义的，只有被修改的区域保证包含有效内容。有效地使用此命令可以为实现提供新的优化机会。
一些 OpenGL ES 实现会将帧缓冲图像缓存到一个小的快速内存池中。在渲染之前，这些实现必须将逻辑缓冲区（如颜色、深度、模板等）的现有内容加载到该内存中。渲染后，这些缓冲区中的一部分或全部也会被存储回外部内存，以便将来再次使用其内容。在许多应用程序中，逻辑缓冲区在渲染开始时被清除。如果是这样，加载或存储这些缓冲区的工作就是浪费的。
即使没有这个扩展，如果渲染的一帧从全屏清除开始，OpenGL ES 实现也可以优化掉在渲染帧之前加载帧缓冲区内容的步骤。有了这个扩展，应用程序可以使用 DiscardFramebufferEXT 来表示帧缓冲区的内容将不再需要。在这种情况下，OpenGL ES 实现也可以优化掉在渲染帧后存储帧缓冲区内容的步骤。</p>

<p>glDiscardFramebufferEXT的工作是告知驱动程序你不关心framebuffer的内容。什么驱动程序(或GPU)决定用它做什么 - 这不取决于你。驱动程序可以将所有内容重置为0，或者它可以保持原样，或者当您下次调用glClear时它将使用此信息并且将更有效地执行它(例如通过为内容分配新内存，而不是执行memset与0值)。不要担心它会做什么</p>

<h1 id="texture-obj与rbo的区别">Texture obj与RBO的区别</h1>

<p>FBO(Frame Buffer Object)即帧缓冲区对象，是一个可添加缓冲区的容器，可以为其添加纹理或渲染缓冲区对象（RBO),它们的区别如下图</p>

<p><img src="/blog/assets/OpenGL/renderbuffer.png" alt="renderbuffer" /></p>

<h1 id="shader">shader</h1>

<h2 id="初始化">初始化</h2>
<p><img src="/blog/assets/OpenGL/shader.png" alt="shader" />
<img src="/blog/assets/OpenGL/shader2.jpg" alt="shader_2" /></p>
<h2 id="变量">变量</h2>

<p><strong>uniform变量</strong></p>

<p>uniform变量是外部application程序传递给（vertex和fragment）shader的变量。因此它是application通过函数glUniform**（）函数赋值的。在（vertex和fragment）shader程序内部，uniform变量就像是C语言里面的常量（const ），它不能被shader程序修改。</p>

<p><strong>attribute变量</strong></p>

<p>attribute变量是只能在vertex shader中使用的变量。它不能在fragment shader中声明attribute变量，也不能被fragment shader中使用。一般用attribute变量来表示一些顶点的数据，如：顶点坐标，法线，纹理坐标，顶点颜色等。在application中，一般用函数glBindAttribLocation（）来绑定每个attribute变量的位置，然后用函数glVertexAttribPointer（）为每个attribute变量赋值。</p>

<p><strong>varying变量</strong></p>

<p>varying变量是vertex和fragment shader之间做数据传递用的。一般vertex shader修改varying变量的值，然后fragment shader使用该varying变量的值。因此varying变量在vertex和fragment shader二者之间的声明必须是一致的。application不能使用此变量。</p>

<h1 id="资源释放">资源释放</h1>

<p>dmabuf资源释放主要考虑texture，eglImage 和dmabuf， FBO不需要考虑。</p>

<ul>
  <li>
    <p>texture、 eglImage和 dmabuf是一体的，释放时需要调用glDeleteTextures， eglDestroyImageKHR， close(dmabuf)， 三个都完成后 dmabuf才真正释放。</p>
  </li>
  <li>
    <p>如果texture附加到一个FBO上，glDeleteTextrues()后会使得该FBO的附加纹理为0.</p>
  </li>
  <li>
    <p>如果前面已经attach 一个纹理到FBO， 在attach 新纹理到另一个FBO时，要先把前一个FBO的纹理设置为0, 否则释放不掉。</p>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span>
    <span class="n">init_dev</span><span class="p">();</span>
    <span class="n">egl_Init</span><span class="p">();</span>

    <span class="n">dmabuf_fd</span> <span class="o">=</span> <span class="n">allocate_dmabuf</span><span class="p">(</span><span class="mi">1920</span><span class="o">*</span><span class="mi">1080</span><span class="o">*</span><span class="mi">4</span><span class="p">);</span>
    <span class="n">textureid</span> <span class="o">=</span> <span class="n">create_texture_for_dmabuf</span><span class="p">(</span><span class="n">dmabuf_fd</span><span class="p">,</span> <span class="mi">1920</span><span class="p">,</span> <span class="mi">1080</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eglImg</span><span class="p">);</span>

    <span class="n">glGenFramebuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">FBO2</span><span class="p">);</span>
    <span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">FBO2</span><span class="p">);</span>
    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_EXTERNAL_OES</span><span class="p">,</span> <span class="n">textureid</span><span class="p">);</span>
    <span class="n">glFramebufferTexture2D</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="n">GL_TEXTURE_EXTERNAL_OES</span><span class="p">,</span> <span class="n">textureid</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">glCheckFramebufferStatus</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">)</span> <span class="o">!=</span> <span class="n">GL_FRAMEBUFFER_COMPLETE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="c1">// 得到当前附加纹理ID为 1</span>
    <span class="n">glGetFramebufferAttachmentParameteriv</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="n">GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">text</span><span class="p">);</span>

    <span class="n">free_dmabuf</span><span class="p">(</span><span class="n">dmabuf_fd</span><span class="p">);</span>
    <span class="n">glDeleteTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">textureid</span><span class="p">);</span>
    <span class="n">eglDestroyImageKHR</span><span class="p">(</span><span class="n">g_EGLDisplay</span><span class="p">,</span> <span class="n">eglImg</span><span class="p">);</span>
    <span class="c1">// 完成后 /sys/kernel/debug/dmabuf/bufferinfo 中dmabuf已经释放</span>

    <span class="c1">// 得到当前附加纹理ID为 0</span>
    <span class="n">glGetFramebufferAttachmentParameteriv</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="n">GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">text</span><span class="p">);</span>
    <span class="n">glDeleteFramebuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">FBO2</span><span class="p">);</span>
    <span class="n">eglDestroyContext</span><span class="p">(</span><span class="n">g_EGLDisplay</span><span class="p">,</span> <span class="n">g_EGLContext</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span>
    <span class="n">init_dev</span><span class="p">();</span>
    <span class="n">egl_Init</span><span class="p">();</span>

    <span class="n">dmabuf_fd1</span> <span class="o">=</span> <span class="n">allocate_dmabuf</span><span class="p">(</span><span class="mi">1920</span><span class="o">*</span><span class="mi">1080</span><span class="o">*</span><span class="mi">4</span><span class="p">);</span>
    <span class="n">textureid1</span> <span class="o">=</span> <span class="n">create_texture_for_dmabuf</span><span class="p">(</span><span class="n">dmabuf_fd1</span><span class="p">,</span> <span class="mi">1920</span><span class="p">,</span> <span class="mi">1080</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eglImg1</span><span class="p">);</span>

    <span class="n">dmabuf_fd2</span> <span class="o">=</span> <span class="n">allocate_dmabuf</span><span class="p">(</span><span class="mi">1920</span><span class="o">*</span><span class="mi">1080</span><span class="o">*</span><span class="mi">4</span><span class="p">);</span>
    <span class="n">textureid2</span> <span class="o">=</span> <span class="n">create_texture_for_dmabuf</span><span class="p">(</span><span class="n">dmabuf_fd2</span><span class="p">,</span> <span class="mi">1920</span><span class="p">,</span> <span class="mi">1080</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eglImg2</span><span class="p">);</span>

    <span class="n">glGenFramebuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">FBO1</span><span class="p">);</span>
    <span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">FBO1</span><span class="p">);</span>
    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_EXTERNAL_OES</span><span class="p">,</span> <span class="n">textureid1</span><span class="p">);</span>
    <span class="n">glFramebufferTexture2D</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="n">GL_TEXTURE_EXTERNAL_OES</span><span class="p">,</span> <span class="n">textureid1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">glCheckFramebufferStatus</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">)</span> <span class="o">!=</span> <span class="n">GL_FRAMEBUFFER_COMPLETE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 注意要设置FBO 的纹理为0， 否则后面不能真正释放</span>
    <span class="n">glFramebufferTexture2D</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="n">GL_TEXTURE_EXTERNAL_OES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">glGenFramebuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">FBO2</span><span class="p">);</span>
    <span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">FBO2</span><span class="p">);</span>
    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_EXTERNAL_OES</span><span class="p">,</span> <span class="n">textureid2</span><span class="p">);</span>
    <span class="n">glFramebufferTexture2D</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="n">GL_TEXTURE_EXTERNAL_OES</span><span class="p">,</span> <span class="n">textureid2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">glCheckFramebufferStatus</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">)</span> <span class="o">!=</span> <span class="n">GL_FRAMEBUFFER_COMPLETE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">free_dmabuf</span><span class="p">(</span><span class="n">dmabuf_fd1</span><span class="p">);</span>
    <span class="n">glDeleteTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">textureid1</span><span class="p">);</span>
    <span class="n">eglDestroyImageKHR</span><span class="p">(</span><span class="n">g_EGLDisplay</span><span class="p">,</span> <span class="n">eglImg1</span><span class="p">);</span>
    <span class="n">free_dmabuf</span><span class="p">(</span><span class="n">dmabuf_fd2</span><span class="p">);</span>
    <span class="n">glDeleteTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">textureid2</span><span class="p">);</span>
    <span class="n">eglDestroyImageKHR</span><span class="p">(</span><span class="n">g_EGLDisplay</span><span class="p">,</span> <span class="n">eglImg2</span><span class="p">);</span>    
    <span class="c1">// 完成后 /sys/kernel/debug/dmabuf/bufferinfo 中dmabuf已经释放</span>

    <span class="n">glDeleteFramebuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">FBO1</span><span class="p">);</span>
    <span class="n">glDeleteFramebuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">FBO2</span><span class="p">);</span>

    <span class="n">eglDestroyContext</span><span class="p">(</span><span class="n">g_EGLDisplay</span><span class="p">,</span> <span class="n">g_EGLContext</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<h1 id="纹理过滤">纹理过滤</h1>

<p>一个纹理通常是由很多的像素点组成的，那么通过纹理坐标如何得到对应点应该的颜色，这就是纹理采样方式或纹理过滤。</p>

<p>下面是两种重要的纹理采样(纹理过滤)：</p>

<ul>
  <li><strong>GL_NEAREST</strong>:邻近过滤，这个是默认纹理过滤方式，OpenGL会选择中心点最接近纹理坐标的那个像素. 这种方式放大有颗粒感</li>
</ul>

<p><img src="/blog/assets/OpenGL/filter_nearest.png" alt="filter_nearest" /></p>

<ul>
  <li><strong>GL_LINEAR</strong>：线性过滤，它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色，一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大， 放大后较平滑。</li>
</ul>

<p><img src="/blog/assets/OpenGL/filter_linear.png" alt="filter_linear" /></p>

<p><strong>二者放大后的效果比较</strong></p>

<p><img src="/blog/assets/OpenGL/texture_filtering.png" alt="texture_filtering" /></p>

<p>当纹理被放大或缩小贴到一个平面时，我们可以设置不同的纹理采样(纹理过滤)方式，达到不同的效果。它所涉及到的OpenGL 函数如下：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">glTexParameteri</span><span class="o">(</span><span class="no">GL_TEXTURE_2D</span><span class="o">,</span> <span class="no">GL_TEXTURE_MIN_FILTER</span><span class="o">,</span> <span class="no">GL_NEAREST</span><span class="o">);</span> <span class="c1">// 缩小</span>
    <span class="n">glTexParameteri</span><span class="o">(</span><span class="no">GL_TEXTURE_2D</span><span class="o">,</span> <span class="no">GL_TEXTURE_MAG_FILTER</span><span class="o">,</span> <span class="no">GL_LINEAR</span><span class="o">);</span>  <span class="c1">// 放大</span>
</code></pre></div></div>

<h1 id="纹理环绕">纹理环绕</h1>

<p>纹理坐标的范围通常是从(0, 0)到(1, 1)，那如果我们把纹理坐标设置在范围之外会发生什么？OpenGL默认的行为是重复这个纹理图像。</p>

<table>
  <thead>
    <tr>
      <th>环绕方式</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>GL_REPEAT</td>
      <td>对纹理的默认行为。重复纹理图像。</td>
    </tr>
    <tr>
      <td>GL_MIRRORED_REPEAT</td>
      <td>和GL_REPEAT一样，但每次重复图片是镜像放置的。</td>
    </tr>
    <tr>
      <td>GL_CLAMP_TO_EDGE</td>
      <td>纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。</td>
    </tr>
    <tr>
      <td>GL_CLAMP_TO_BORDER</td>
      <td>超出的坐标为用户指定的边缘颜色</td>
    </tr>
  </tbody>
</table>

<p><img src="/blog/assets/OpenGL/texture_wrapping.png" alt="texture_wrapping" /></p>

<p>相关函数</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">glTexParameteri</span><span class="o">(</span><span class="no">GL_TEXTURE_2D</span><span class="o">,</span> <span class="no">GL_TEXTURE_WRAP_S</span><span class="o">,</span> <span class="no">GL_MIRRORED_REPEAT</span><span class="o">);</span>
    <span class="n">glTexParameteri</span><span class="o">(</span><span class="no">GL_TEXTURE_2D</span><span class="o">,</span> <span class="no">GL_TEXTURE_WRAP_T</span><span class="o">,</span> <span class="no">GL_MIRRORED_REPEAT</span><span class="o">);</span>
</code></pre></div></div>

<p>如果我们选择GL_CLAMP_TO_BORDER选项，我们还需要指定一个边缘的颜色。这需要使用glTexParameter函数的fv后缀形式，用GL_TEXTURE_BORDER_COLOR作为它的选项，并且传递一个float数组作为边缘的颜色值：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">float</span> <span class="n">borderColor</span><span class="o">[]</span> <span class="o">=</span> <span class="o">{</span> <span class="mf">1.0f</span><span class="o">,</span> <span class="mf">1.0f</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">,</span> <span class="mf">1.0f</span> <span class="o">};</span>
    <span class="n">glTexParameterfv</span><span class="o">(</span><span class="no">GL_TEXTURE_2D</span><span class="o">,</span> <span class="no">GL_TEXTURE_BORDER_COLOR</span><span class="o">,</span> <span class="n">borderColor</span><span class="o">);</span>
</code></pre></div></div>

<h1 id="glmapbufferrange">glMapBufferRange</h1>

<p><code class="language-plaintext highlighter-rouge">glMapBufferRange</code> 是一个 OpenGL 函数，用于将指定缓冲对象的一部分数据<span style="color:red">映射到客户端的地址空间中</span>,可以减少一次CPU 内存数据的读写。 以下是关于 <code class="language-plaintext highlighter-rouge">glMapBufferRange</code> 的详细说明：</p>

<ul>
  <li><strong>作用</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">glMapBufferRange</code> 允许你直接访问缓冲对象的数据，以便在客户端代码中进行读取或写入操作。</li>
      <li>通过映射缓冲区的一部分，你可以有效地操作其中的数据。</li>
    </ul>
  </li>
  <li><strong>参数</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">target</code>：目标缓冲对象类型，通常为 <code class="language-plaintext highlighter-rouge">GL_ARRAY_BUFFER</code> 或 <code class="language-plaintext highlighter-rouge">GL_ELEMENT_ARRAY_BUFFER</code>。</li>
      <li><code class="language-plaintext highlighter-rouge">offset</code>：要映射的数据在缓冲对象中的偏移量。</li>
      <li><code class="language-plaintext highlighter-rouge">length</code>：要映射的数据的长度。</li>
      <li><code class="language-plaintext highlighter-rouge">access</code>：访问权限，可以是 <code class="language-plaintext highlighter-rouge">GL_READ_ONLY</code>、<code class="language-plaintext highlighter-rouge">GL_WRITE_ONLY</code> 或 <code class="language-plaintext highlighter-rouge">GL_READ_WRITE</code>。</li>
      <li><code class="language-plaintext highlighter-rouge">返回值</code>：映射后的指针，用于访问缓冲区数据。</li>
    </ul>
  </li>
  <li><strong>使用场景</strong>：
    <ul>
      <li>在顶点缓冲对象（VBO）中，你可以使用 <code class="language-plaintext highlighter-rouge">glMapBufferRange</code> 来更新顶点数据。</li>
      <li>在像素缓冲对象（PBO）中，你可以使用它来处理像素数据。</li>
    </ul>
  </li>
</ul>

<p>总之，<code class="language-plaintext highlighter-rouge">glMapBufferRange</code> 允许你映射缓冲对象的一部分数据，以便在客户端代码中直接访问和操作。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;GL/glew.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;GLFW/glfw3.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Initialize GLFW and create a window</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">glfwInit</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to initialize GLFW"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">GLFWwindow</span><span class="o">*</span> <span class="n">window</span> <span class="o">=</span> <span class="n">glfwCreateWindow</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="s">"OpenGL Sample"</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">window</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to create GLFW window"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">glfwTerminate</span><span class="p">();</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">glfwMakeContextCurrent</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
    <span class="c1">// Initialize GLEW</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">glewInit</span><span class="p">()</span> <span class="o">!=</span> <span class="n">GLEW_OK</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to initialize GLEW"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// Create a buffer object (VBO)</span>
    <span class="n">GLuint</span> <span class="n">vbo</span><span class="p">;</span>
    <span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vbo</span><span class="p">);</span>
    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">vbo</span><span class="p">);</span>
    <span class="c1">// Allocate storage for the buffer</span>
    <span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">,</span> <span class="n">GL_DYNAMIC_DRAW</span><span class="p">);</span>
    <span class="c1">// Map a portion of the buffer</span>
    <span class="n">GLintptr</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">GLsizeiptr</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
    <span class="n">GLvoid</span><span class="o">*</span> <span class="n">mappedData</span> <span class="o">=</span> <span class="n">glMapBufferRange</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">GL_MAP_WRITE_BIT</span> <span class="o">|</span> <span class="n">GL_MAP_INVALIDATE_BUFFER_BIT</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mappedData</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Modify the data in the mapped region</span>
        <span class="c1">// ...</span>
        <span class="c1">// Unmap the buffer</span>
        <span class="n">glUnmapBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to map buffer"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// Main loop</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="p">(</span><span class="n">window</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// Render your scene using the modified buffer data</span>
        <span class="c1">// ...</span>
        <span class="n">glfwSwapBuffers</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
        <span class="n">glfwPollEvents</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="c1">// Cleanup</span>
    <span class="n">glDeleteBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vbo</span><span class="p">);</span>
    <span class="n">glfwDestroyWindow</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
    <span class="n">glfwTerminate</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">DumpTexture</span><span class="p">(</span><span class="n">GLuint</span> <span class="n">TextureId</span><span class="p">,</span> <span class="n">GLuint</span> <span class="n">x0</span><span class="p">,</span> <span class="n">GLuint</span> <span class="n">y0</span><span class="p">,</span> <span class="n">GLuint</span> <span class="n">x1</span><span class="p">,</span> <span class="n">GLuint</span> <span class="n">y1</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">fbo0</span><span class="p">;</span>
    <span class="n">glGetIntegerv</span><span class="p">(</span> <span class="n">GL_FRAMEBUFFER_BINDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fbo0</span><span class="p">);</span>
    <span class="n">GLuint</span> <span class="n">fbo</span><span class="p">;</span>
    <span class="n">glGenFramebuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fbo</span><span class="p">);</span>
    <span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">fbo</span><span class="p">);</span>
    <span class="n">glFramebufferTexture2D</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">TextureId</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>    
    <span class="k">if</span> <span class="p">(</span><span class="n">glCheckFramebufferStatus</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">)</span> <span class="o">!=</span> <span class="n">GL_FRAMEBUFFER_COMPLETE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"glCheckFramebufferStatus() failed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">GLuint</span> <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">x1</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">*</span> <span class="p">(</span><span class="n">y1</span><span class="o">-</span><span class="n">y0</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">;</span>
    <span class="n">GLuint</span> <span class="n">pbo_down</span><span class="p">;</span>
    <span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pbo_down</span><span class="p">);</span>
    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_PIXEL_PACK_BUFFER</span><span class="p">,</span> <span class="n">pbo_down</span><span class="p">);</span>
    <span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_PIXEL_PACK_BUFFER</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">GL_STREAM_READ</span><span class="p">);</span>
    <span class="n">glReadPixels</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span><span class="n">y0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">GL_RGBA</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">GLubyte</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="p">(</span><span class="n">GLubyte</span><span class="o">*</span><span class="p">)</span><span class="n">glMapBufferRange</span><span class="p">(</span><span class="n">GL_PIXEL_PACK_BUFFER</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>  <span class="n">GL_MAP_READ_BIT</span><span class="p">);</span>
    <span class="n">GLubyte</span>  <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="n">glUnmapBuffer</span><span class="p">(</span><span class="n">GL_PIXEL_PACK_BUFFER</span><span class="p">);</span>
    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_PIXEL_PACK_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">stbi_write_png</span><span class="p">(</span><span class="s">"/tmp/texture_img.png"</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">x1</span><span class="o">-</span><span class="n">x0</span><span class="p">),</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">y1</span><span class="o">-</span><span class="n">y0</span><span class="p">),</span> <span class="mi">4</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)((</span><span class="n">x1</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">));</span>
    <span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">fbo0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h1 id="freetype">freetype</h1>

<p>下图是freetype调用的基本框架。</p>

<p><img src="/blog/assets/OpenGL/freetype_func.png" alt="freetype_funcs" /></p>

<p><img src="/blog/assets/OpenGL/freetype_glyph.png" alt="freetype_glyph" /></p>

<p>参看上图，在绘制字符时以baseline为水平基准，则所有的字符就会对齐。</p>

</section>
            </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div></div>
    </div>
</div>

<!-- introduce mathjax support -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ['$', '$'], ['\\(', '\\)'] ]
  },
  svg: {
    fontCache: 'global'
  }
};
</script>
<script
  type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>


<!-- introduce per-page mermaid support -->

    <script>
    function render_mermaid() {
        mermaid.initialize({
            startOnLoad: false,
            theme: "default",
        });
        window.mermaid.init(undefined, document.querySelectorAll('.language-mermaid'));
    }

    function initialize_mermaid() {
        if (document.readyState === "loading") {
            // Loading hasn't finished yet
            document.addEventListener("DOMContentLoaded", render_mermaid);
        } else {
            // `DOMContentLoaded` has already fired
            render_mermaid();
        }
    }

    if (window.mermaid_script && window.mermaid) {
        initialize_mermaid();
    } else {
        window.mermaid_script = document.createElement("script");
        mermaid_script.onload = initialize_mermaid;
        document.head.appendChild(mermaid_script);
        mermaid_script.defer = true;
        mermaid_script.id = 'mermaid-script';
        mermaid_script.src = '/blog/assets/gitbook/mermaid.min.js';
    }
</script>



<!-- introduce mathjax support -->
<script>
    function fixes_chrome_anchors() {
        let chrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
        if (window.location.hash && chrome) {
            setTimeout(function () {
                var hash = window.location.hash;
                window.location.hash = "";
                window.location.hash = hash;
            }, 300);
        }
    }

    if (document.readyState === "loading") {
        // Loading hasn't finished yet
        document.addEventListener("DOMContentLoaded", fixes_chrome_anchors);
    } else {
        // `DOMContentLoaded` has already fired
        fixes_chrome_anchors();
    }
</script>


                        <a href="/blog/jekyll/2002-08-10-Wayland-Misc.html" class="navigation navigation-prev navigation-unique" aria-label="Previous page: Wayland Misc">
                            <i class="fa fa-angle-left"></i>
                        </a>
                    

                    
                        <a href="/blog/jekyll/2013-03-02-cobalt.html" class="navigation navigation-next navigation-unique" aria-label="Next page: Cobalt">
                            <i class="fa fa-angle-right"></i>
                        </a>
                    
                </div>
            </div>

            <script>
            var gitbook = gitbook || [];
            gitbook.push(function() {
                gitbook.page.hasChanged({
    "page": {
        "title": "Introduction",
        "level": "1.1",
        "depth": 1,
        
        "next": {
            "title": "Cobalt",
            "level": "1.2",
            "depth": 1,
            "path": "_posts/2013-03-2-cobalt.md",
            "ref": "_posts/2013-03-2-cobalt.md",
            "articles": []
        },
        
        "dir": "ltr"
    },    "config": {
        "plugins": ["fontsettings", "highlight", "livereload", "lunr", "search", "sharing", "theme-default", "livereload"],
        "styles": {
            "ebook": "styles/ebook.css",
            "epub": "styles/epub.css",
            "mobi": "styles/mobi.css",
            "pdf": "styles/pdf.css",
            "print": "styles/print.css",
            "website": "styles/website.css"
        },
        "pluginsConfig": {
            "expandable-chapter-small2": {
                "articlesExpand": true,
            },
            "fontsettings": {
                "family": "sans",
                "size": 2,
                "theme": "white"
            },
            "highlight": {},
            "livereload": {},
            "lunr": {
                "ignoreSpecialCharacters": false,
                "maxIndexSize": 1000000
            },
            "search": {},            "sharing": {
                "facebook": false,

                "google": false,

                "github": false,
              
                "github_link": "https://github.com",
              

                "telegram": false,
                "telegram_link": "https://t.me",

                "instapaper": false,

                "twitter": false,
              

                "vk": false,

                "weibo": false,

                "all": ["facebook", "google", "twitter", "weibo", "instapaper", "github", "telegram"]
            },
"theme-default": {
                "showLevel": false,
                "styles": {
                    "ebook": "styles/ebook.css",
                    "epub": "styles/epub.css",
                    "mobi": "styles/mobi.css",
                    "pdf": "styles/pdf.css",
                    "print": "styles/print.css",
                    "website": "styles/website.css"
                }
            },
        },
        "theme": "default",
        "author": "Tao He",
        "pdf": {
            "pageNumbers": true,
            "fontSize": 12,
            "fontFamily": "Arial",
            "paperSize": "a4",
            "chapterMark": "pagebreak",
            "pageBreaksBefore": "/",
            "margin": {
                "right": 62,
                "left": 62,
                "top": 56,
                "bottom": 56
            }
        },
        "structure": {
            "langs": "LANGS.md",
            "readme": "README.md",
        },
        "variables": {},
        "title": "学习笔记",
        "language": "en",
        "gitbook": "*"
    },
    "file": {
        "path": "_posts/2020-08-20-OpenGL_misc.md",
        "mtime": "2003-08-20 00:00:00 +0800",
        "type": "markdown"
    },
    "gitbook": {
        "version": "3.2.3"
    },
    "basePath": "/blog",
    "book": {
        "language": ""
    }
});
            });
            </script>
        </div><script src="/blog/assets/gitbook/gitbook.js"></script>
<script src="/blog/assets/gitbook/theme.js"></script>

<script src="/blog/assets/gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
<script src="/blog/assets/gitbook/gitbook-plugin-copy-code-button/toggle.js"></script>
<script src="/blog/assets/gitbook/gitbook-plugin-expandable-chapters-small2/expandable-chapters-small.js"></script>
<script src="/blog/assets/gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
<script src="/blog/assets/gitbook/gitbook-plugin-search-pro/jquery.mark.min.js"></script>
<script src="/blog/assets/gitbook/gitbook-plugin-search-pro/search.js"></script>
<!-- <script src="/blog/assets/gitbook/gitbook-plugin-sharing/buttons.js"></script> -->
<script src="/blog/assets/gitbook/gitbook-plugin-splitter/splitter.js"></script>

<!--
<script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
<script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
<script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
<script src="../gitbook/gitbook-plugin-search/search.js"></script>
-->

</body>
</html>