<!DOCTYPE HTML>
<html lang="en" >
    <head><meta charset="UTF-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"><title>OpenGL · 学习笔记</title><meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="description" content="Build Jekyll site with the GitBook style.
"><meta name="generator" content="Jekyll (using style of GitBook 3.2.3)"><meta name="author" content="kevin_zh"><link rel="stylesheet" href="/blog/assets/gitbook/style.css">
<link rel="stylesheet" href="/blog/assets/gitbook/gitbook-plugin-back-to-top-button/plugin.css">
<link rel="stylesheet" href="/blog/assets/gitbook/gitbook-plugin-expandable-chapters-small2/expandable-chapters-small.css">
<link rel="stylesheet" href="/blog/assets/gitbook/gitbook-plugin-fontsettings/website.css">
<link rel="stylesheet" href="/blog/assets/gitbook/gitbook-plugin-search-pro/search.css">
<link rel="stylesheet" href="/blog/assets/gitbook/gitbook-plugin-splitter/splitter.css">

<link rel="stylesheet" href="/blog/assets/gitbook/rouge/magritte.css">

<link rel="stylesheet" href="/blog/assets/gitbook/custom.css">
<link rel="stylesheet" href="/blog/assets/gitbook/custom-local.css">

<meta name="HandheldFriendly" content="true"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="/blog/assets/gitbook/images/apple-touch-icon-precomposed-152.png">
<link rel="shortcut icon" href="/blog//assets/gitbook/images/favicon.ico" type="image/x-icon">




            <link rel="prev" href="/blog/jekyll/2002-08-10-Wayland-Misc.html" />
        

        
            <link rel="next" href="/blog/jekyll/2013-03-02-cobalt.html" />
        
    </head>
    <body>
        <div class="book"><div class="book-summary">
    <script type="text/javascript">
        // Fixes the page links scroll problem on both desktop and mobile browsers
        function pageScrollToTop(element) {
            // both mobile and non-mobile
            $('div.body-inner').animate({scrollTop: 0});
            $(element).parent().find('li>ul>li').removeClass('active');
            return true;  // propagate
        }
        // Fixes the anchor links scroll problem on mobile browsers
        function mobilePageScrollToAnchor(element) {
            $(element).closest('li.chapter').find('ul>li').removeClass('active');
            $(element).parent().addClass('active');
            if ($(document).width() <= 1240) {
                $('div.body-inner').animate({scrollTop: $($(element).attr('href')).get(0).offsetTop});
            }
            return true;
        }
    </script>

    <nav role="navigation">
        <div id="book-search-input" role="search">
            <input type="text" placeholder="Type to search" />
        </div>
        <div id="book-search-input-link" role="search">
            <a href="/blog/assets/search.html">Click to Search</a>
        </div>
        <ul class="summary">
            
            <li class="chapter" data-level="1.1" data-path="/blog">
            
                <a href="/blog/" onclick="pageScrollToTop(this)">
                    学习笔记
                </a>
            </li>

            <li class="divider"></li>

            
                <!-- <p>pages</p> -->
                
                    

                    

                    
                
            
                <!-- <p>posts</p> -->
                
                    

                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2000-04-27-linux_grpahic_architecture.html">
                        
                            <a href="/blog/jekyll/2000-04-27-linux_grpahic_architecture.html" onclick="pageScrollToTop(this)">
                                Linux graphic架构
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/graphic/2001-02-01-DRM.html">
                        
                            <a href="/blog/graphic/2001-02-01-DRM.html" onclick="pageScrollToTop(this)">
                                DRM子系统
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/graphic/2002-05-15-Wayland&Weston.html">
                        
                            <a href="/blog/graphic/2002-05-15-Wayland&Weston.html" onclick="pageScrollToTop(this)">
                                Wayland&amp;Weston
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2002-06-11-Weston.html">
                        
                            <a href="/blog/jekyll/2002-06-11-Weston.html" onclick="pageScrollToTop(this)">
                                Weston Misc
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2002-08-10-Wayland-Misc.html">
                        
                            <a href="/blog/jekyll/2002-08-10-Wayland-Misc.html" onclick="pageScrollToTop(this)">
                                Wayland Misc
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter active" data-level="1.2" data-path="/blog/jekyll/2003-08-20-OpenGL_misc.html">
                        
                            <a href="/blog/jekyll/2003-08-20-OpenGL_misc.html" onclick="pageScrollToTop(this)">
                                OpenGL
                            </a>
                            
                                
                                    <ul><li><a href="#glinvalidateframebuffer-vs-glclear" onclick="mobilePageScrollToAnchor(this)" >glInvalidateFramebuffer vs glClear</a></li><li><a href="#gldiscardframebufferext" onclick="mobilePageScrollToAnchor(this)" >glDiscardFramebufferEXT</a></li><li><a href="#texture-obj与rbo的区别" onclick="mobilePageScrollToAnchor(this)" >Texture obj与RBO的区别</a></li><li><a href="#vaovboveo" onclick="mobilePageScrollToAnchor(this)" >VAO,VBO,VEO</a></li><li><a href="#shader" onclick="mobilePageScrollToAnchor(this)" >shader</a><ul><li><a href="#初始化" onclick="mobilePageScrollToAnchor(this)" >初始化</a></li><li><a href="#变量" onclick="mobilePageScrollToAnchor(this)" >变量</a></li></ul></li><li><a href="#资源释放" onclick="mobilePageScrollToAnchor(this)" >资源释放</a></li><li><a href="#glwaitsync-vs-glclientwaitsync" onclick="mobilePageScrollToAnchor(this)" >glWaitSync VS glClientWaitSync</a></li><li><a href="#纹理过滤" onclick="mobilePageScrollToAnchor(this)" >纹理过滤</a></li><li><a href="#纹理环绕" onclick="mobilePageScrollToAnchor(this)" >纹理环绕</a></li><li><a href="#glmapbufferrange" onclick="mobilePageScrollToAnchor(this)" >glMapBufferRange</a></li><li><a href="#freetype" onclick="mobilePageScrollToAnchor(this)" >freetype</a></li><li><a href="#抗锯齿" onclick="mobilePageScrollToAnchor(this)" >抗锯齿</a><ul><li><a href="#line" onclick="mobilePageScrollToAnchor(this)" >line</a></li><li><a href="#msaa" onclick="mobilePageScrollToAnchor(this)" >MSAA</a></li><li><a href="#文字渲染中的抗锯齿" onclick="mobilePageScrollToAnchor(this)" >文字渲染中的抗锯齿</a></li></ul></li><li><a href="#图像处理" onclick="mobilePageScrollToAnchor(this)" >图像处理</a><ul><li><a href="#对比度调节" onclick="mobilePageScrollToAnchor(this)" >对比度调节</a></li><li><a href="#gamma校正" onclick="mobilePageScrollToAnchor(this)" >gamma校正</a></li><li><a href="#阈值分隔" onclick="mobilePageScrollToAnchor(this)" >阈值分隔</a></li><li><a href="#白平衡" onclick="mobilePageScrollToAnchor(this)" >白平衡</a></li><li><a href="#降噪" onclick="mobilePageScrollToAnchor(this)" >降噪</a></li></ul></li></ul>

                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2013-03-02-cobalt.html">
                        
                            <a href="/blog/jekyll/2013-03-02-cobalt.html" onclick="pageScrollToTop(this)">
                                Cobalt
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/graphic/2018-03-21-YUV.html">
                        
                            <a href="/blog/graphic/2018-03-21-YUV.html" onclick="pageScrollToTop(this)">
                                YUV编码
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2018-05-20-memory_check.html">
                        
                            <a href="/blog/jekyll/2018-05-20-memory_check.html" onclick="pageScrollToTop(this)">
                                进程内存检查
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/linux/2018-08-01-DeviceResourceManage.html">
                        
                            <a href="/blog/linux/2018-08-01-DeviceResourceManage.html" onclick="pageScrollToTop(this)">
                                设备资源管理模块
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2020-06-22-misc.html">
                        
                            <a href="/blog/jekyll/2020-06-22-misc.html" onclick="pageScrollToTop(this)">
                                Kernel Misc
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2020-10-02-FuncTrace.html">
                        
                            <a href="/blog/jekyll/2020-10-02-FuncTrace.html" onclick="pageScrollToTop(this)">
                                Function Trace
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2021-04-27-ffmpeg.html">
                        
                            <a href="/blog/jekyll/2021-04-27-ffmpeg.html" onclick="pageScrollToTop(this)">
                                ffmpeg命令
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2022-04-27-bit.html">
                        
                            <a href="/blog/jekyll/2022-04-27-bit.html" onclick="pageScrollToTop(this)">
                                位运算
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2022-05-02-App_misc.html">
                        
                            <a href="/blog/jekyll/2022-05-02-App_misc.html" onclick="pageScrollToTop(this)">
                                linux dev misc
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2024-03-22-Camera.html">
                        
                            <a href="/blog/jekyll/2024-03-22-Camera.html" onclick="pageScrollToTop(this)">
                                Camera
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/blog/jekyll/2024-04-27-git.html">
                        
                            <a href="/blog/jekyll/2024-04-27-git.html" onclick="pageScrollToTop(this)">
                                Git
                            </a>
                            
                                
                            
                        </li>
                    

                    
                        <li class="divider"></li>
                    
                
            
        </ul>
    </nav>
</div>
<div class="book-body">
                <div class="book-header" role="navigation">
                    <!-- Title -->
                    <h1>
                        <i class="fa fa-circle-o-notch fa-spin"></i>
                        
                            <a href="." >OpenGL</a>
                        
                    </h1>
                </div>

                <div class="body-inner"><div class="page-wrapper" tabindex="-1" role="main">
    

    <div class="page-inner">
        <div id="book-search-results">
            <div class="search-noresults">
                <section class="normal markdown-section">
                    
                        <h1 id="/jekyll/OpenGL_misc">OpenGL</h1>
                    

                    <h1 id="glinvalidateframebuffer-vs-glclear">glInvalidateFramebuffer vs glClear</h1>

<p>glInvalidateFramebuffer 和 glClear 是OpenGL中两个不同的函数，它们的作用和用法有所不同：</p>

<ul>
  <li>glInvalidateFramebuffer：
    <ul>
      <li>功能：glInvalidateFramebuffer 用于显式地标记帧缓冲区的某些部分为无效。这样，GPU就知道这些部分的内容不再需要，可以避免不必要的数据交换。</li>
      <li>应用场景：通常在使用帧缓冲区对象（FBO）时，当我们切换到不同的FBO或者不再需要某些颜色、深度或模板缓冲区的内容时，可以调用该函数。</li>
      <li>性能影响：尽管在RenderDoc等工具中可能显示glInvalidateFramebuffer的耗时较高，但实际上，只有少数几次调用不会对渲染性能产生影响。</li>
    </ul>
  </li>
  <li>glClear：
    <ul>
      <li>功能：glClear 用于清除当前帧缓冲区的内容，包括颜色缓冲区、深度缓冲区和模板缓冲区。</li>
      <li>应用场景：在每一帧开始时，我们通常会调用glClear来准备帧缓冲区，以便进行新的绘制。</li>
      <li>性能影响：glClear的性能开销通常较小，但在某些情况下，如果频繁调用，可能会影响性能。</li>
    </ul>
  </li>
</ul>

<p>总结：</p>
<ul>
  <li>glInvalidateFramebuffer 用于标记帧缓冲区的部分内容为无效，以减少不必要的数据交换。</li>
  <li>glClear 用于清除整个帧缓冲区的内容，以准备进行新的绘制。</li>
  <li>在使用RenderDoc等工具时，可以忽略glInvalidateFramebuffer的耗时，但需要关注片上高速缓存回写内存的消耗  。</li>
</ul>

<h1 id="gldiscardframebufferext">glDiscardFramebufferEXT</h1>

<p><code class="language-plaintext highlighter-rouge">void glDiscardFramebufferEXT(enum target, sizei numAttachments, const enum *attachments);</code></p>

<p>这个扩展提供了一个新的命令，glDiscardFramebufferEXT，它会使得指定帧缓冲附件的内容变为未定义状态。在未来的操作修改内容之前，这些指定缓冲区的内容是未定义的，只有被修改的区域保证包含有效内容。有效地使用此命令可以为实现提供新的优化机会。
一些 OpenGL ES 实现会将帧缓冲图像缓存到一个小的快速内存池中。在渲染之前，这些实现必须将逻辑缓冲区（如颜色、深度、模板等）的现有内容加载到该内存中。渲染后，这些缓冲区中的一部分或全部也会被存储回外部内存，以便将来再次使用其内容。在许多应用程序中，逻辑缓冲区在渲染开始时被清除。如果是这样，加载或存储这些缓冲区的工作就是浪费的。
即使没有这个扩展，如果渲染的一帧从全屏清除开始，OpenGL ES 实现也可以优化掉在渲染帧之前加载帧缓冲区内容的步骤。有了这个扩展，应用程序可以使用 DiscardFramebufferEXT 来表示帧缓冲区的内容将不再需要。在这种情况下，OpenGL ES 实现也可以优化掉在渲染帧后存储帧缓冲区内容的步骤。</p>

<p>glDiscardFramebufferEXT的工作是告知驱动程序你不关心framebuffer的内容。什么驱动程序(或GPU)决定用它做什么 - 这不取决于你。驱动程序可以将所有内容重置为0，或者它可以保持原样，或者当您下次调用glClear时它将使用此信息并且将更有效地执行它(例如通过为内容分配新内存，而不是执行memset与0值)。不要担心它会做什么</p>

<h1 id="texture-obj与rbo的区别">Texture obj与RBO的区别</h1>

<p>FBO(Frame Buffer Object)即帧缓冲区对象，是一个可添加缓冲区的容器，可以为其添加纹理或渲染缓冲区对象（RBO),它们的区别如下图</p>

<p><img src="/blog/assets/OpenGL/renderbuffer.png" alt="renderbuffer" /></p>

<h1 id="vaovboveo">VAO,VBO,VEO</h1>

<p>在OpenGL中，VAO（Vertex Array Object）、VBO（Vertex Buffer Object）和EBO（Element Buffer Object）是用于管理和组织顶点数据的重要工具。它们在现代OpenGL编程中扮演着关键角色。以下是它们的区别和联系：</p>

<p><strong>Vertex Array Object (VAO)</strong></p>

<p>VAO是顶点数组对象，用于存储关于顶点属性配置的状态。一个VAO可以绑定多个VBO和EBO，并记录这些缓冲区的绑定状态和顶点属性配置。使用VAO可以简化顶点属性的管理和绑定，便于切换不同的顶点数据配置。</p>

<p><span style="color:#FF00FF">一个VAO可以关联多组记录顶点不同属性的VBO，在实际使用时只绑定该VAO就完成所有VBO的关联</span>。见下文smaple code</p>

<p>主要功能</p>
<ul>
  <li>记录顶点属性指针的配置。</li>
  <li>记录与之关联的VBO和EBO的绑定状态。</li>
  <li>简化绘制调用时的状态切换</li>
</ul>

<p><strong>Vertex Buffer Object (VBO)</strong></p>

<p>VBO是顶点缓冲对象，用于在GPU内存中存储顶点数据（如顶点位置、法线、纹理坐标等）。VBO的主要优点是能够显著提高顶点数据的传输效率，因为数据存储在GPU内存中而非CPU内存中。</p>

<p>主要功能</p>
<ul>
  <li>存储顶点数据。</li>
  <li>提供高效的数据传输和存取方式。</li>
</ul>

<p><strong>Element Buffer Object (EBO)</strong></p>

<p>EBO是元素缓冲对象（也称为索引缓冲对象，IBO），用于在GPU内存中存储顶点索引。EBO允许我们通过索引数组来绘制图形，从而避免顶点数据的重复，提高存储效率和渲染性能。</p>

<p>主要功能</p>
<ul>
  <li>存储顶点索引。</li>
  <li>通过索引数组绘制顶点，从而减少重复顶点数据。</li>
</ul>

<p><strong>smaple code</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;GL/glew.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;GLFW/glfw3.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="c1">// 顶点位置数据</span>
<span class="n">GLfloat</span> <span class="n">positions</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span>
     <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span>
     <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span><span class="p">,</span>  <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span><span class="p">,</span>  <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span>
<span class="p">};</span>
<span class="c1">// 顶点颜色数据</span>
<span class="n">GLfloat</span> <span class="n">colors</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span>
    <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span>
    <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span>
    <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span>
<span class="p">};</span>
<span class="c1">// 索引数据</span>
<span class="n">GLuint</span> <span class="n">indices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
    <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 初始化GLFW</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">glfwInit</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to initialize GLFW"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 创建窗口</span>
    <span class="n">GLFWwindow</span><span class="o">*</span> <span class="n">window</span> <span class="o">=</span> <span class="n">glfwCreateWindow</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="s">"VAO with Multiple VBOs"</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">window</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to create GLFW window"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">glfwTerminate</span><span class="p">();</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">glfwMakeContextCurrent</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
    <span class="c1">// 初始化GLEW</span>
    <span class="n">glewExperimental</span> <span class="o">=</span> <span class="n">GL_TRUE</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">glewInit</span><span class="p">()</span> <span class="o">!=</span> <span class="n">GLEW_OK</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to initialize GLEW"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 生成并绑定VAO</span>
    <span class="n">GLuint</span> <span class="n">vao</span><span class="p">;</span>
    <span class="n">glGenVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vao</span><span class="p">);</span>
    <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">vao</span><span class="p">);</span>
    <span class="c1">// 生成并绑定位置VBO</span>
    <span class="n">GLuint</span> <span class="n">vboPositions</span><span class="p">;</span>
    <span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vboPositions</span><span class="p">);</span>
    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">vboPositions</span><span class="p">);</span>
    <span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">positions</span><span class="p">),</span> <span class="n">positions</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
    <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="c1">// 生成并绑定颜色VBO</span>
    <span class="n">GLuint</span> <span class="n">vboColors</span><span class="p">;</span>
    <span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vboColors</span><span class="p">);</span>
    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">vboColors</span><span class="p">);</span>
    <span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">colors</span><span class="p">),</span> <span class="n">colors</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
    <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="c1">// 生成并绑定EBO</span>
    <span class="n">GLuint</span> <span class="n">ebo</span><span class="p">;</span>
    <span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ebo</span><span class="p">);</span>
    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">ebo</span><span class="p">);</span>
    <span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="n">indices</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
    <span class="c1">// 解绑VAO</span>
    <span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="c1">// 渲染循环</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="p">(</span><span class="n">window</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// 清屏</span>
        <span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="p">);</span>
        <span class="c1">// 绘制, 在使用时只要绑定vao即可</span>
        <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">vao</span><span class="p">);</span>
        <span class="n">glDrawElements</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">GL_UNSIGNED_INT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="c1">// 交换缓冲</span>
        <span class="n">glfwSwapBuffers</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
        <span class="n">glfwPollEvents</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="c1">// 释放资源</span>
    <span class="n">glDeleteVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vao</span><span class="p">);</span>
    <span class="n">glDeleteBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vboPositions</span><span class="p">);</span>
    <span class="n">glDeleteBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vboColors</span><span class="p">);</span>
    <span class="n">glDeleteBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ebo</span><span class="p">);</span>
    <span class="c1">// 终止GLFW</span>
    <span class="n">glfwTerminate</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="shader">shader</h1>

<h2 id="初始化">初始化</h2>
<p><img src="/blog/assets/OpenGL/shader.png" alt="shader" />
<img src="/blog/assets/OpenGL/shader2.jpg" alt="shader_2" /></p>
<h2 id="变量">变量</h2>

<p><strong>uniform变量</strong></p>
<pre><code class="language-mermaid">graph LR;
    App--&gt;Vertext_Shader;
    Vertext_Shader--&gt;Frag_Shader;
</code></pre>
<p>uniform变量是外部application程序传递给（vertex和fragment）shader的变量。因此它是application通过函数glUniform**（）函数赋值的。在（vertex和fragment）shader程序内部，uniform变量就像是C语言里面的常量（const ），它不能被shader程序修改。</p>

<p><strong>attribute变量</strong></p>

<pre><code class="language-mermaid">graph LR;
    App--&gt;Vertext_Shader;
</code></pre>
<p>attribute变量是只能在vertex shader中使用的变量。它不能在fragment shader中声明attribute变量，也不能被fragment shader中使用。一般用attribute变量来表示一些顶点的数据，如：顶点坐标，法线，纹理坐标，顶点颜色等。在application中，一般用函数glBindAttribLocation（）来绑定每个attribute变量的位置，然后用函数glVertexAttribPointer（）为每个attribute变量赋值。</p>

<p><strong>varying变量</strong></p>

<pre><code class="language-mermaid">graph LR;    
    Vertext_Shader--&gt;Frag_Shader;
</code></pre>
<p>varying变量是vertex和fragment shader之间做数据传递用的。一般vertex shader修改varying变量的值，然后fragment shader使用该varying变量的值。因此varying变量在vertex和fragment shader二者之间的声明必须是一致的。application不能使用此变量。</p>

<h1 id="资源释放">资源释放</h1>

<p>dmabuf资源释放主要考虑texture，eglImage 和dmabuf， FBO不需要考虑。</p>

<ul>
  <li>
    <p>texture、 eglImage和 dmabuf是一体的，释放时需要调用glDeleteTextures， eglDestroyImageKHR， close(dmabuf)， 三个都完成后 dmabuf才真正释放。</p>
  </li>
  <li>
    <p>如果texture附加到一个FBO上，glDeleteTextrues()后会使得该FBO的附加纹理为0.</p>
  </li>
  <li>
    <p>如果前面已经attach 一个纹理到FBO， 在attach 新纹理到另一个FBO时，要先把前一个FBO的纹理设置为0, 否则释放不掉。</p>
  </li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">int</span> <span class="nf">main</span><span class="p">(</span><span class="nx">int</span> <span class="nx">argc</span><span class="p">,</span> <span class="nx">char</span> <span class="kd">const</span> <span class="o">*</span><span class="nx">argv</span><span class="p">[]){</span>
    <span class="nf">init_dev</span><span class="p">();</span>
    <span class="nf">egl_Init</span><span class="p">();</span>

    <span class="nx">dmabuf_fd</span> <span class="o">=</span> <span class="nf">allocate_dmabuf</span><span class="p">(</span><span class="mi">1920</span><span class="o">*</span><span class="mi">1080</span><span class="o">*</span><span class="mi">4</span><span class="p">);</span>
    <span class="nx">textureid</span> <span class="o">=</span> <span class="nf">create_texture_for_dmabuf</span><span class="p">(</span><span class="nx">dmabuf_fd</span><span class="p">,</span> <span class="mi">1920</span><span class="p">,</span> <span class="mi">1080</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">eglImg</span><span class="p">);</span>

    <span class="nf">glGenFramebuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">FBO2</span><span class="p">);</span>
    <span class="nf">glBindFramebuffer</span><span class="p">(</span><span class="nx">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="nx">FBO2</span><span class="p">);</span>
    <span class="nf">glBindTexture</span><span class="p">(</span><span class="nx">GL_TEXTURE_EXTERNAL_OES</span><span class="p">,</span> <span class="nx">textureid</span><span class="p">);</span>
    <span class="nf">glFramebufferTexture2D</span><span class="p">(</span><span class="nx">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="nx">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="nx">GL_TEXTURE_EXTERNAL_OES</span><span class="p">,</span> <span class="nx">textureid</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if </span><span class="p">(</span><span class="nf">glCheckFramebufferStatus</span><span class="p">(</span><span class="nx">GL_FRAMEBUFFER</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">GL_FRAMEBUFFER_COMPLETE</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="c1">// 得到当前附加纹理ID为 1</span>
    <span class="nf">glGetFramebufferAttachmentParameteriv</span><span class="p">(</span><span class="nx">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="nx">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="nx">GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">text</span><span class="p">);</span>

    <span class="nf">free_dmabuf</span><span class="p">(</span><span class="nx">dmabuf_fd</span><span class="p">);</span>
    <span class="nf">glDeleteTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">textureid</span><span class="p">);</span>
    <span class="nf">eglDestroyImageKHR</span><span class="p">(</span><span class="nx">g_EGLDisplay</span><span class="p">,</span> <span class="nx">eglImg</span><span class="p">);</span>
    <span class="c1">// 完成后 /sys/kernel/debug/dmabuf/bufferinfo 中dmabuf已经释放</span>

    <span class="c1">// 得到当前附加纹理ID为 0</span>
    <span class="nf">glGetFramebufferAttachmentParameteriv</span><span class="p">(</span><span class="nx">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="nx">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="nx">GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">text</span><span class="p">);</span>
    <span class="nf">glDeleteFramebuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">FBO2</span><span class="p">);</span>
    <span class="nf">eglDestroyContext</span><span class="p">(</span><span class="nx">g_EGLDisplay</span><span class="p">,</span> <span class="nx">g_EGLContext</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">int</span> <span class="nf">main</span><span class="p">(</span><span class="nx">int</span> <span class="nx">argc</span><span class="p">,</span> <span class="nx">char</span> <span class="kd">const</span> <span class="o">*</span><span class="nx">argv</span><span class="p">[]){</span>
    <span class="nf">init_dev</span><span class="p">();</span>
    <span class="nf">egl_Init</span><span class="p">();</span>

    <span class="nx">dmabuf_fd1</span> <span class="o">=</span> <span class="nf">allocate_dmabuf</span><span class="p">(</span><span class="mi">1920</span><span class="o">*</span><span class="mi">1080</span><span class="o">*</span><span class="mi">4</span><span class="p">);</span>
    <span class="nx">textureid1</span> <span class="o">=</span> <span class="nf">create_texture_for_dmabuf</span><span class="p">(</span><span class="nx">dmabuf_fd1</span><span class="p">,</span> <span class="mi">1920</span><span class="p">,</span> <span class="mi">1080</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">eglImg1</span><span class="p">);</span>

    <span class="nx">dmabuf_fd2</span> <span class="o">=</span> <span class="nf">allocate_dmabuf</span><span class="p">(</span><span class="mi">1920</span><span class="o">*</span><span class="mi">1080</span><span class="o">*</span><span class="mi">4</span><span class="p">);</span>
    <span class="nx">textureid2</span> <span class="o">=</span> <span class="nf">create_texture_for_dmabuf</span><span class="p">(</span><span class="nx">dmabuf_fd2</span><span class="p">,</span> <span class="mi">1920</span><span class="p">,</span> <span class="mi">1080</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">eglImg2</span><span class="p">);</span>

    <span class="nf">glGenFramebuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">FBO1</span><span class="p">);</span>
    <span class="nf">glBindFramebuffer</span><span class="p">(</span><span class="nx">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="nx">FBO1</span><span class="p">);</span>
    <span class="nf">glBindTexture</span><span class="p">(</span><span class="nx">GL_TEXTURE_EXTERNAL_OES</span><span class="p">,</span> <span class="nx">textureid1</span><span class="p">);</span>
    <span class="nf">glFramebufferTexture2D</span><span class="p">(</span><span class="nx">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="nx">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="nx">GL_TEXTURE_EXTERNAL_OES</span><span class="p">,</span> <span class="nx">textureid1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if </span><span class="p">(</span><span class="nf">glCheckFramebufferStatus</span><span class="p">(</span><span class="nx">GL_FRAMEBUFFER</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">GL_FRAMEBUFFER_COMPLETE</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 注意要设置FBO 的纹理为0， 否则后面不能真正释放</span>
    <span class="nf">glFramebufferTexture2D</span><span class="p">(</span><span class="nx">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="nx">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="nx">GL_TEXTURE_EXTERNAL_OES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="nf">glGenFramebuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">FBO2</span><span class="p">);</span>
    <span class="nf">glBindFramebuffer</span><span class="p">(</span><span class="nx">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="nx">FBO2</span><span class="p">);</span>
    <span class="nf">glBindTexture</span><span class="p">(</span><span class="nx">GL_TEXTURE_EXTERNAL_OES</span><span class="p">,</span> <span class="nx">textureid2</span><span class="p">);</span>
    <span class="nf">glFramebufferTexture2D</span><span class="p">(</span><span class="nx">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="nx">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="nx">GL_TEXTURE_EXTERNAL_OES</span><span class="p">,</span> <span class="nx">textureid2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if </span><span class="p">(</span><span class="nf">glCheckFramebufferStatus</span><span class="p">(</span><span class="nx">GL_FRAMEBUFFER</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">GL_FRAMEBUFFER_COMPLETE</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nf">free_dmabuf</span><span class="p">(</span><span class="nx">dmabuf_fd1</span><span class="p">);</span>
    <span class="nf">glDeleteTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">textureid1</span><span class="p">);</span>
    <span class="nf">eglDestroyImageKHR</span><span class="p">(</span><span class="nx">g_EGLDisplay</span><span class="p">,</span> <span class="nx">eglImg1</span><span class="p">);</span>
    <span class="nf">free_dmabuf</span><span class="p">(</span><span class="nx">dmabuf_fd2</span><span class="p">);</span>
    <span class="nf">glDeleteTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">textureid2</span><span class="p">);</span>
    <span class="nf">eglDestroyImageKHR</span><span class="p">(</span><span class="nx">g_EGLDisplay</span><span class="p">,</span> <span class="nx">eglImg2</span><span class="p">);</span>    
    <span class="c1">// 完成后 /sys/kernel/debug/dmabuf/bufferinfo 中dmabuf已经释放</span>

    <span class="nf">glDeleteFramebuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">FBO1</span><span class="p">);</span>
    <span class="nf">glDeleteFramebuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">FBO2</span><span class="p">);</span>

    <span class="nf">eglDestroyContext</span><span class="p">(</span><span class="nx">g_EGLDisplay</span><span class="p">,</span> <span class="nx">g_EGLContext</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<h1 id="glwaitsync-vs-glclientwaitsync">glWaitSync VS glClientWaitSync</h1>

<p><strong>硬件层面的指令执行</strong></p>

<p><img src="/blog/assets/OpenGL/cpu_gpu.webp" alt="" /></p>

<p>glWaitSync是在GPU上等待fence,</p>

<p>glClientWaitSync是在CPU上等待fence</p>

<h1 id="纹理过滤">纹理过滤</h1>

<p>一个纹理通常是由很多的像素点组成的，那么通过<span style="color:red">纹理坐标</span>如何得到对应点应该的颜色，这就是<span style="color:red">纹理采样方式或纹理过滤</span>。</p>

<p>下面是两种重要的纹理采样(纹理过滤)：</p>

<ul>
  <li><strong>GL_NEAREST</strong>:邻近过滤，这个是默认纹理过滤方式，OpenGL会选择中心点最接近纹理坐标的那个像素. 这种方式放大有颗粒感</li>
</ul>

<p><img src="/blog/assets/OpenGL/filter_nearest.png" alt="filter_nearest" /></p>

<ul>
  <li><strong>GL_LINEAR</strong>：线性过滤，它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色，一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大， 放大后较平滑。</li>
</ul>

<p><img src="/blog/assets/OpenGL/filter_linear.png" alt="filter_linear" /></p>

<p><strong>二者放大后的效果比较</strong></p>

<p><img src="/blog/assets/OpenGL/texture_filtering.png" alt="texture_filtering" /></p>

<p>当纹理被放大或缩小贴到一个平面时，我们可以设置不同的纹理采样(纹理过滤)方式，达到不同的效果。它所涉及到的OpenGL 函数如下：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">glTexParameteri</span><span class="o">(</span><span class="no">GL_TEXTURE_2D</span><span class="o">,</span> <span class="no">GL_TEXTURE_MIN_FILTER</span><span class="o">,</span> <span class="no">GL_NEAREST</span><span class="o">);</span> <span class="c1">// 缩小</span>
    <span class="n">glTexParameteri</span><span class="o">(</span><span class="no">GL_TEXTURE_2D</span><span class="o">,</span> <span class="no">GL_TEXTURE_MAG_FILTER</span><span class="o">,</span> <span class="no">GL_LINEAR</span><span class="o">);</span>  <span class="c1">// 放大</span>
</code></pre></div></div>

<p><strong>小纹理贴到大目标上</strong></p>

<p>让我们比较一下 在一个很大的物体上应用<span style="color:red">一张低分辨率</span>的纹理的不同效果
<img src="/blog/assets/OpenGL/nearest.webp" alt="" /></p>

<p><strong>大纹理贴到小目标上</strong></p>

<p>在这种情况下， 会产生所谓的摩尔波纹</p>

<p><img src="/blog/assets/OpenGL/bowen.webp" alt="" width="140px" height="200px" /></p>

<p><strong>Mipmap</strong></p>

<p>如何解决上面摩尔波纹的问题，GPU 引入了Mipmap(<span style="color:#ff00ff">多级渐远纹理</span>)概念。它简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一。</p>

<p>使用Mipmap的渲染过程：</p>

<p>如果一个20<em>20的像素区域需要映射400</em>400的纹理像素区域时，首先检测到一颗像素需要映射到纹理像素为20<em>20，然后在Mipmap纹理中里寻找最接近20</em>20纹理像素的多级渐远纹理，并使用此多级渐远纹理进行采样</p>

<p>此时过滤方式的设置</p>

<table>
  <thead>
    <tr>
      <th>过滤方式</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>GL_NEAREST_MIPMAP_NEAREST</td>
      <td>使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样</td>
    </tr>
    <tr>
      <td>GL_LINEAR_MIPMAP_NEAREST</td>
      <td>使用最邻近的多级渐远纹理级别，并使用线性插值进行采样</td>
    </tr>
    <tr>
      <td>GL_NEAREST_MIPMAP_LINEAR</td>
      <td>在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样</td>
    </tr>
    <tr>
      <td>GL_LINEAR_MIPMAP_LINEAR</td>
      <td>在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样</td>
    </tr>
  </tbody>
</table>

<p><strong>使用方法</strong></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nx">GLuint</span> <span class="nx">texture</span><span class="p">;</span>
    <span class="nf">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">texture</span><span class="p">);</span>
    <span class="nf">glBindTexture</span><span class="p">(</span><span class="nx">GL_TEXTURE_2D</span><span class="p">,</span> <span class="nx">texture</span><span class="p">);</span>

    <span class="c1">// 加载原始纹理图像数据</span>
    <span class="nf">glTexImage2D</span><span class="p">(</span><span class="nx">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">GL_RGB</span><span class="p">,</span> <span class="nx">width</span><span class="p">,</span> <span class="nx">height</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">GL_RGB</span><span class="p">,</span> <span class="nx">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="nx">data</span><span class="p">);</span>

    <span class="c1">// 自动生成 Mipmap</span>
    <span class="nf">glGenerateMipmap</span><span class="p">(</span><span class="nx">GL_TEXTURE_2D</span><span class="p">);</span>

    <span class="c1">// 设置 Mipmap 过滤模式</span>
    <span class="nf">glTexParameteri</span><span class="p">(</span><span class="nx">GL_TEXTURE_2D</span><span class="p">,</span> <span class="nx">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="nx">GL_LINEAR_MIPMAP_LINEAR</span><span class="p">);</span>
    <span class="nf">glTexParameteri</span><span class="p">(</span><span class="nx">GL_TEXTURE_2D</span><span class="p">,</span> <span class="nx">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="nx">GL_LINEAR</span><span class="p">);</span>

</code></pre></div></div>

<h1 id="纹理环绕">纹理环绕</h1>

<p>纹理坐标的范围通常是从(0, 0)到(1, 1)，那如果我们把纹理坐标设置在范围之外会发生什么？OpenGL默认的行为是重复这个纹理图像。</p>

<table>
  <thead>
    <tr>
      <th>环绕方式</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>GL_REPEAT</td>
      <td>对纹理的默认行为。重复纹理图像。</td>
    </tr>
    <tr>
      <td>GL_MIRRORED_REPEAT</td>
      <td>和GL_REPEAT一样，但每次重复图片是镜像放置的。</td>
    </tr>
    <tr>
      <td>GL_CLAMP_TO_EDGE</td>
      <td>纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。</td>
    </tr>
    <tr>
      <td>GL_CLAMP_TO_BORDER</td>
      <td>超出的坐标为用户指定的边缘颜色</td>
    </tr>
  </tbody>
</table>

<p><img src="/blog/assets/OpenGL/texture_wrapping.png" alt="texture_wrapping" /></p>

<p>相关函数</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">glTexParameteri</span><span class="o">(</span><span class="no">GL_TEXTURE_2D</span><span class="o">,</span> <span class="no">GL_TEXTURE_WRAP_S</span><span class="o">,</span> <span class="no">GL_MIRRORED_REPEAT</span><span class="o">);</span>
    <span class="n">glTexParameteri</span><span class="o">(</span><span class="no">GL_TEXTURE_2D</span><span class="o">,</span> <span class="no">GL_TEXTURE_WRAP_T</span><span class="o">,</span> <span class="no">GL_MIRRORED_REPEAT</span><span class="o">);</span>
</code></pre></div></div>

<p>如果我们选择GL_CLAMP_TO_BORDER选项，我们还需要指定一个边缘的颜色。这需要使用glTexParameter函数的fv后缀形式，用GL_TEXTURE_BORDER_COLOR作为它的选项，并且传递一个float数组作为边缘的颜色值：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">float</span> <span class="n">borderColor</span><span class="o">[]</span> <span class="o">=</span> <span class="o">{</span> <span class="mf">1.0f</span><span class="o">,</span> <span class="mf">1.0f</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">,</span> <span class="mf">1.0f</span> <span class="o">};</span>
    <span class="n">glTexParameterfv</span><span class="o">(</span><span class="no">GL_TEXTURE_2D</span><span class="o">,</span> <span class="no">GL_TEXTURE_BORDER_COLOR</span><span class="o">,</span> <span class="n">borderColor</span><span class="o">);</span>
</code></pre></div></div>

<h1 id="glmapbufferrange">glMapBufferRange</h1>

<p><code class="language-plaintext highlighter-rouge">glMapBufferRange</code> 是一个 OpenGL 函数，用于将指定缓冲对象的一部分数据<span style="color:red">映射到客户端的地址空间中</span>,可以减少一次CPU 内存数据的读写。 以下是关于 <code class="language-plaintext highlighter-rouge">glMapBufferRange</code> 的详细说明：</p>

<ul>
  <li><strong>作用</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">glMapBufferRange</code> 允许你直接访问缓冲对象的数据，以便在客户端代码中进行读取或写入操作。</li>
      <li>通过映射缓冲区的一部分，你可以有效地操作其中的数据。</li>
    </ul>
  </li>
  <li><strong>参数</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">target</code>：目标缓冲对象类型，通常为 <code class="language-plaintext highlighter-rouge">GL_ARRAY_BUFFER</code> 或 <code class="language-plaintext highlighter-rouge">GL_ELEMENT_ARRAY_BUFFER</code>。</li>
      <li><code class="language-plaintext highlighter-rouge">offset</code>：要映射的数据在缓冲对象中的偏移量。</li>
      <li><code class="language-plaintext highlighter-rouge">length</code>：要映射的数据的长度。</li>
      <li><code class="language-plaintext highlighter-rouge">access</code>：访问权限，可以是 <code class="language-plaintext highlighter-rouge">GL_READ_ONLY</code>、<code class="language-plaintext highlighter-rouge">GL_WRITE_ONLY</code> 或 <code class="language-plaintext highlighter-rouge">GL_READ_WRITE</code>。</li>
      <li><code class="language-plaintext highlighter-rouge">返回值</code>：映射后的指针，用于访问缓冲区数据。</li>
    </ul>
  </li>
  <li><strong>使用场景</strong>：
    <ul>
      <li>在顶点缓冲对象（VBO）中，你可以使用 <code class="language-plaintext highlighter-rouge">glMapBufferRange</code> 来更新顶点数据。</li>
      <li>在像素缓冲对象（PBO）中，你可以使用它来处理像素数据。</li>
    </ul>
  </li>
</ul>

<p>总之，<code class="language-plaintext highlighter-rouge">glMapBufferRange</code> 允许你映射缓冲对象的一部分数据，以便在客户端代码中直接访问和操作。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;GL/glew.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;GLFW/glfw3.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Initialize GLFW and create a window</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">glfwInit</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to initialize GLFW"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">GLFWwindow</span><span class="o">*</span> <span class="n">window</span> <span class="o">=</span> <span class="n">glfwCreateWindow</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="s">"OpenGL Sample"</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">window</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to create GLFW window"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">glfwTerminate</span><span class="p">();</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">glfwMakeContextCurrent</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
    <span class="c1">// Initialize GLEW</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">glewInit</span><span class="p">()</span> <span class="o">!=</span> <span class="n">GLEW_OK</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to initialize GLEW"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// Create a buffer object (VBO)</span>
    <span class="n">GLuint</span> <span class="n">vbo</span><span class="p">;</span>
    <span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vbo</span><span class="p">);</span>
    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">vbo</span><span class="p">);</span>
    <span class="c1">// Allocate storage for the buffer</span>
    <span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">,</span> <span class="n">GL_DYNAMIC_DRAW</span><span class="p">);</span>
    <span class="c1">// Map a portion of the buffer</span>
    <span class="n">GLintptr</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">GLsizeiptr</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
    <span class="n">GLvoid</span><span class="o">*</span> <span class="n">mappedData</span> <span class="o">=</span> <span class="n">glMapBufferRange</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">GL_MAP_WRITE_BIT</span> <span class="o">|</span> <span class="n">GL_MAP_INVALIDATE_BUFFER_BIT</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mappedData</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Modify the data in the mapped region</span>
        <span class="c1">// ...</span>
        <span class="c1">// Unmap the buffer</span>
        <span class="n">glUnmapBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to map buffer"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// Main loop</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="p">(</span><span class="n">window</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// Render your scene using the modified buffer data</span>
        <span class="c1">// ...</span>
        <span class="n">glfwSwapBuffers</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
        <span class="n">glfwPollEvents</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="c1">// Cleanup</span>
    <span class="n">glDeleteBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vbo</span><span class="p">);</span>
    <span class="n">glfwDestroyWindow</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
    <span class="n">glfwTerminate</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">DumpTexture</span><span class="p">(</span><span class="n">GLuint</span> <span class="n">TextureId</span><span class="p">,</span> <span class="n">GLuint</span> <span class="n">x0</span><span class="p">,</span> <span class="n">GLuint</span> <span class="n">y0</span><span class="p">,</span> <span class="n">GLuint</span> <span class="n">x1</span><span class="p">,</span> <span class="n">GLuint</span> <span class="n">y1</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">fbo0</span><span class="p">;</span>
    <span class="n">glGetIntegerv</span><span class="p">(</span> <span class="n">GL_FRAMEBUFFER_BINDING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fbo0</span><span class="p">);</span>
    <span class="n">GLuint</span> <span class="n">fbo</span><span class="p">;</span>
    <span class="n">glGenFramebuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fbo</span><span class="p">);</span>
    <span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">fbo</span><span class="p">);</span>
    <span class="n">glFramebufferTexture2D</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">TextureId</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>    
    <span class="k">if</span> <span class="p">(</span><span class="n">glCheckFramebufferStatus</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">)</span> <span class="o">!=</span> <span class="n">GL_FRAMEBUFFER_COMPLETE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"glCheckFramebufferStatus() failed</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">GLuint</span> <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">x1</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">*</span> <span class="p">(</span><span class="n">y1</span><span class="o">-</span><span class="n">y0</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">;</span>
    <span class="n">GLuint</span> <span class="n">pbo_down</span><span class="p">;</span>
    <span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pbo_down</span><span class="p">);</span>
    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_PIXEL_PACK_BUFFER</span><span class="p">,</span> <span class="n">pbo_down</span><span class="p">);</span>
    <span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_PIXEL_PACK_BUFFER</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">GL_STREAM_READ</span><span class="p">);</span>
    <span class="n">glReadPixels</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span><span class="n">y0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">GL_RGBA</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">GLubyte</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="p">(</span><span class="n">GLubyte</span><span class="o">*</span><span class="p">)</span><span class="n">glMapBufferRange</span><span class="p">(</span><span class="n">GL_PIXEL_PACK_BUFFER</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>  <span class="n">GL_MAP_READ_BIT</span><span class="p">);</span>
    <span class="n">GLubyte</span>  <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="n">glUnmapBuffer</span><span class="p">(</span><span class="n">GL_PIXEL_PACK_BUFFER</span><span class="p">);</span>
    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_PIXEL_PACK_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">stbi_write_png</span><span class="p">(</span><span class="s">"/tmp/texture_img.png"</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">x1</span><span class="o">-</span><span class="n">x0</span><span class="p">),</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">y1</span><span class="o">-</span><span class="n">y0</span><span class="p">),</span> <span class="mi">4</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)((</span><span class="n">x1</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">));</span>
    <span class="n">glBindFramebuffer</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">fbo0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<h1 id="freetype">freetype</h1>

<p>下图是freetype调用的基本框架。</p>

<p><img src="/blog/assets/OpenGL/freetype_func.png" alt="freetype_funcs" /></p>

<p><img src="/blog/assets/OpenGL/freetype_glyph.png" alt="freetype_glyph" /></p>

<p>参看上图，在绘制字符时以baseline为水平基准，则所有的字符就会对齐。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;ft2build.h&gt;</span><span class="cp">
#include FT_FREETYPE_H
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">FT_Library</span> <span class="n">library</span><span class="p">;</span>
    <span class="n">FT_Face</span> <span class="n">face</span><span class="p">;</span>
    <span class="n">FT_Error</span> <span class="n">error</span><span class="p">;</span>
    <span class="c1">// 初始化 FreeType 库</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">FT_Init_FreeType</span><span class="p">(</span><span class="o">&amp;</span><span class="n">library</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Could not initialize FreeType library</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 加载字体文件</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">FT_New_Face</span><span class="p">(</span><span class="n">library</span><span class="p">,</span> <span class="s">"path/to/your/font.ttf"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">face</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Could not load font</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">FT_Done_FreeType</span><span class="p">(</span><span class="n">library</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 设置字体大小</span>
    <span class="n">FT_Set_Pixel_Sizes</span><span class="p">(</span><span class="n">face</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">48</span><span class="p">);</span>
    <span class="c1">// 加载一个字符的字形</span>
    <span class="c1">// freetype 默认使用了灰度抗锯齿， 也可以在加载字形时设定不同的标志(如 FT_LOAD_TARGET_NORMAL 或 FT_LOAD_TARGET_LCD) 来指定不同的抗锯齿方式</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">FT_Load_Char</span><span class="p">(</span><span class="n">face</span><span class="p">,</span> <span class="sc">'A'</span><span class="p">,</span> <span class="n">FT_LOAD_RENDER</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Could not load character</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">FT_Done_Face</span><span class="p">(</span><span class="n">face</span><span class="p">);</span>
        <span class="n">FT_Done_FreeType</span><span class="p">(</span><span class="n">library</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 获取字形位图</span>
    <span class="n">FT_Bitmap</span> <span class="o">*</span><span class="n">bitmap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">face</span><span class="o">-&gt;</span><span class="n">glyph</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">;</span>
    <span class="c1">// 输出位图信息</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">bitmap</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">bitmap</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">putchar</span><span class="p">(</span><span class="n">bitmap</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">y</span> <span class="o">*</span> <span class="n">bitmap</span><span class="o">-&gt;</span><span class="n">pitch</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">?</span> <span class="sc">'*'</span> <span class="o">:</span> <span class="sc">' '</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">putchar</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 释放资源</span>
    <span class="n">FT_Done_Face</span><span class="p">(</span><span class="n">face</span><span class="p">);</span>
    <span class="n">FT_Done_FreeType</span><span class="p">(</span><span class="n">library</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h1 id="抗锯齿">抗锯齿</h1>

<h2 id="line">line</h2>

<p>一般情况下，OpenGL抗锯齿的效果是有的，但是如果你的程序中没有正确设置抗锯齿参数，或者你的显卡不支持抗锯齿，那么抗锯齿就不会起作用。</p>

<p>正确设置抗锯齿参数的方法是：</p>

<ol>
  <li>
    <p>在程序中调用glEnable(GL_LINE_SMOOTH)函数，开启抗锯齿功能；</p>
  </li>
  <li>
    <p>调用glHint(GL_LINE_SMOOTH_HINT, GL_NICEST)函数，设置抗锯齿的精度；</p>
  </li>
  <li>
    <p>调用glLineWidth(1.5f)函数，设置线条的宽度；</p>
  </li>
  <li>
    <p>调用glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)函数，设置混合模式；</p>
  </li>
  <li>
    <p>调用glEnable(GL_BLEND)函数，开启混合功能。</p>
  </li>
</ol>

<p>如果你的显卡不支持抗锯齿，那么你可以尝试更换显卡，或者使用其他抗锯齿技术，比如多重采样抗锯齿（MSAA）</p>

<h2 id="msaa">MSAA</h2>

<p><strong>原理</strong>：
无论三角形遮盖了多少个子采样点，（每个图元中）每个像素只运行一次片段着色器。片段着色器所使用的顶点数据会插值到每个像素的中心，所得到的结果颜色会被储存在每个被遮盖住的子采样点中。当颜色缓冲的子样本被图元的所有颜色填满时，所有的这些颜色将会在每个像素内部平均化。因为上图的4个采样点中只有2个被遮盖住了，<span style="color:red">这个像素的颜色将会是三角形颜色与其他两个采样点的颜色（在这里是无色）的平均值，最终形成一种淡蓝色</span>。</p>

<p><img src="/blog/assets/OpenGL/anti_aliasing_rasterization_samples_filled.png" alt="MSAA_anti_aliasing" /></p>

<p><strong>通过EGL设置多重采样</strong></p>

<p>可以通过eglChooseConfig来设置一个 attrib_list，在这个 attrib_list中设置多重采样的信息</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     <span class="k">const</span> <span class="n">EGLint</span> <span class="n">attribsMSAA</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">EGL_SURFACE_TYPE</span><span class="p">,</span>    <span class="n">EGL_WINDOW_BIT</span><span class="p">,</span>
                <span class="n">EGL_RENDERABLE_TYPE</span><span class="p">,</span> <span class="n">EGL_OPENGL_ES2_BIT</span><span class="p">,</span>
                <span class="n">EGL_BLUE_SIZE</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span>
                <span class="n">EGL_GREEN_SIZE</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span>
                <span class="n">EGL_RED_SIZE</span><span class="p">,</span>   <span class="mi">8</span><span class="p">,</span>
                <span class="n">EGL_ALPHA_SIZE</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="c1">// if you need the alpha channel</span>
                <span class="n">EGL_DEPTH_SIZE</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span><span class="c1">// if you need the depth buffer</span>
                <span class="n">EGL_STENCIL_SIZE</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span>
                <span class="n">EGL_SAMPLE_BUFFERS</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="c1">//打开多采样抗锯齿</span>
                <span class="n">EGL_SAMPLES</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>   <span class="c1">//设置每个片段的采样点数</span>
                <span class="n">EGL_NONE</span>
    <span class="p">};</span>
</code></pre></div></div>
<p>EGL_SAMPLES, 用来指定<span style="color:red">每个片段的样本数</span>，样本数越多抗锯齿效果越好，一般推荐设置 2、4、8 。</p>

<p>但是采样数不能随便设置，我们可以通过 GL_MAX_SAMPLES 查询设备最大支持的采样数。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">int</span> <span class="n">maxSamples</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">glGetIntegerv</span><span class="p">(</span><span class="n">GL_MAX_SAMPLES</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">maxSamples</span><span class="p">);</span>
</code></pre></div></div>

<p><strong>离屏渲染 MSAA</strong></p>

<ol>
  <li>构建多重采样纹理：
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">glBindTexture</span><span class="o">(</span><span class="no">GL_TEXTURE_2D_MULTISAMPLE</span><span class="o">,</span> <span class="n">tex</span><span class="o">);</span>
 <span class="n">glTexImage2DMultisample</span><span class="o">(</span><span class="no">GL_TEXTURE_2D_MULTISAMPLE</span><span class="o">,</span> <span class="n">samples</span><span class="o">,</span> <span class="no">GL_RGB</span><span class="o">,</span> <span class="n">width</span><span class="o">,</span> <span class="n">height</span><span class="o">,</span> <span class="no">GL_TRUE</span><span class="o">);</span>
 <span class="n">glBindTexture</span><span class="o">(</span><span class="no">GL_TEXTURE_2D_MULTISAMPLE</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
</code></pre></div>    </div>
  </li>
  <li>附加到帧缓冲
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">glFramebufferTexture2D</span><span class="o">(</span><span class="no">GL_FRAMEBUFFER</span><span class="o">,</span> <span class="no">GL_COLOR_ATTACHMENT0</span><span class="o">,</span> <span class="no">GL_TEXTURE_2D_MULTISAMPLE</span><span class="o">,</span> <span class="n">tex</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
</code></pre></div>    </div>
  </li>
  <li>渲染到多重采样帧缓冲</li>
</ol>

<p>渲染到多重采样帧缓冲对象的过程都是自动的。只要我们在帧缓冲绑定时绘制任何东西，光栅器就会负责所有的多重采样运算。我们最终会得到一个多重采样颜色缓冲以及/或深度和模板缓冲。因为多重采样缓冲有一点特别，我们不能直接将它们的缓冲图像用于其他运算，比如在着色器中对它们进行采样。</p>

<p>换句话说， <span style="color:red">多重采样的渲染结果无法直接上屏渲染，需要 Blit 到另外一个普通的帧缓冲区或者再进行一次普通的离屏渲染</span></p>

<p>一个多重采样的图像包含比普通图像更多的信息，我们所要做的是缩小或者还原(Resolve)图像。多重采样帧缓冲的还原通常是通过glBlitFramebuffer来完成，它能够将一个帧缓冲中的某个区域复制到另一个帧缓冲中，并且将多重采样缓冲还原。</p>

<p>glBlitFramebuffer会将一个用4个屏幕空间坐标所定义的源区域复制到一个同样用4个屏幕空间坐标所定义的目标区域中。你可能记得在帧缓冲教程中，当我们绑定到GL_FRAMEBUFFER时，我们是同时绑定了读取和绘制的帧缓冲目标。我们也可以将帧缓冲分开绑定至GL_READ_FRAMEBUFFER与GL_DRAW_FRAMEBUFFER。glBlitFramebuffer函数会根据这两个目标，决定哪个是源帧缓冲，哪个是目标帧缓冲。接下来，我们可以将图像位块传送(Blit)到默认的帧缓冲中，将多重采样的帧缓冲传送到屏幕上。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">glBindFramebuffer</span><span class="o">(</span><span class="no">GL_READ_FRAMEBUFFER</span><span class="o">,</span> <span class="n">multisampledFBO</span><span class="o">);</span>
    <span class="n">glBindFramebuffer</span><span class="o">(</span><span class="no">GL_DRAW_FRAMEBUFFER</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="n">glBlitFramebuffer</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">width</span><span class="o">,</span> <span class="n">height</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">width</span><span class="o">,</span> <span class="n">height</span><span class="o">,</span> <span class="no">GL_COLOR_BUFFER_BIT</span><span class="o">,</span> <span class="no">GL_NEAREST</span><span class="o">);</span>
</code></pre></div></div>
<p>or</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    <span class="n">glBindFramebuffer</span><span class="o">(</span><span class="no">GL_FRAMEBUFFER</span><span class="o">,</span> <span class="n">m_FboId</span><span class="o">);</span>
    <span class="n">glViewport</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">screenW</span><span class="o">,</span> <span class="n">screenH</span><span class="o">);</span>
    <span class="n">glClearColor</span><span class="o">(</span><span class="mf">1.0</span><span class="o">,</span> <span class="mf">1.0</span><span class="o">,</span> <span class="mf">1.0</span><span class="o">,</span> <span class="mf">1.0</span><span class="o">);</span>
    <span class="n">glClear</span><span class="o">(</span><span class="no">GL_COLOR_BUFFER_BIT</span><span class="o">);</span>
    <span class="nc">UpdateMVPMatrix</span><span class="o">(</span><span class="n">m_MVPMatrix</span><span class="o">,</span> <span class="n">m_AngleX</span><span class="o">,</span> <span class="n">m_AngleY</span><span class="o">,</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span><span class="n">screenW</span> <span class="o">/</span> <span class="n">screenH</span><span class="o">);</span>
    <span class="n">glUseProgram</span> <span class="o">(</span><span class="n">m_ProgramObj</span><span class="o">);</span>
    <span class="n">glBindVertexArray</span><span class="o">(</span><span class="n">m_VaoId</span><span class="o">);</span>
    <span class="nl">GLUtils:</span><span class="o">:</span><span class="n">setMat4</span><span class="o">(</span><span class="n">m_ProgramObj</span><span class="o">,</span> <span class="s">"u_MVPMatrix"</span><span class="o">,</span> <span class="n">m_MVPMatrix</span><span class="o">);</span>
    <span class="n">glActiveTexture</span><span class="o">(</span><span class="no">GL_TEXTURE1</span><span class="o">);</span>
    <span class="n">glBindTexture</span><span class="o">(</span><span class="no">GL_TEXTURE_2D</span><span class="o">,</span> <span class="n">m_TextureId</span><span class="o">);</span>
    <span class="nl">GLUtils:</span><span class="o">:</span><span class="n">setInt</span><span class="o">(</span><span class="n">m_ProgramObj</span><span class="o">,</span> <span class="s">"s_Texture"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
    <span class="n">glDrawElements</span><span class="o">(</span><span class="no">GL_TRIANGLES</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="no">GL_UNSIGNED_SHORT</span><span class="o">,</span> <span class="o">(</span><span class="kd">const</span> <span class="kt">void</span> <span class="o">*)</span><span class="mi">0</span><span class="o">);</span>

    <span class="c1">//多重采样缓冲区无法直接上屏（渲染），先搞到另外一个缓冲区，然后再上屏</span>
    <span class="n">glBindFramebuffer</span><span class="o">(</span><span class="no">GL_FRAMEBUFFER</span><span class="o">,</span> <span class="n">m_FboId2</span><span class="o">);</span>
    <span class="n">glClearColor</span><span class="o">(</span><span class="mf">1.0</span><span class="o">,</span> <span class="mf">1.0</span><span class="o">,</span> <span class="mf">1.0</span><span class="o">,</span> <span class="mf">1.0</span><span class="o">);</span>
    <span class="n">glClear</span><span class="o">(</span><span class="no">GL_COLOR_BUFFER_BIT</span><span class="o">);</span>
    <span class="n">glBindFramebuffer</span><span class="o">(</span><span class="no">GL_READ_FRAMEBUFFER</span><span class="o">,</span> <span class="n">m_FboId</span><span class="o">);</span> <span class="c1">// 设置GL_READ_FRAMEBUFFER 为m_FboId</span>
    <span class="n">glReadBuffer</span><span class="o">(</span><span class="no">GL_COLOR_ATTACHMENT0</span><span class="o">);</span>
    <span class="n">glBlitFramebuffer</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">screenW</span><span class="o">,</span> <span class="n">screenH</span><span class="o">,</span>
                      <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">screenW</span><span class="o">,</span> <span class="n">screenH</span><span class="o">,</span>
                      <span class="no">GL_COLOR_BUFFER_BIT</span><span class="o">,</span> <span class="no">GL_LINEAR</span><span class="o">);</span>
</code></pre></div></div>

<h2 id="文字渲染中的抗锯齿">文字渲染中的抗锯齿</h2>

<p>文字渲染中的抗锯齿技术主要是为了减少由于像素网格和字体轮廓之间的不匹配而产生的锯齿状边缘。以下是几种常见的抗锯齿手段：</p>

<ol>
  <li><strong>灰度抗锯齿（Grayscale Anti-Aliasing）</strong>：
    <ul>
      <li>通过在文字边缘使用不同灰度的像素来平滑过渡，使边缘看起来更平滑。</li>
      <li>优点是可以显著减少锯齿，缺点是对比度会有所降低，尤其在小字体上效果不明显。</li>
      <li>freetype 默认使用了灰度抗锯齿， 也可以在加载字形时设定不同的标志(如 FT_LOAD_TARGET_NORMAL 或 FT_LOAD_TARGET_LCD) 来指定不同的抗锯齿方式。</li>
    </ul>
  </li>
  <li><strong>次像素抗锯齿（Subpixel Anti-Aliasing）</strong>：
    <ul>
      <li>利用显示屏的次像素结构（通常是RGB子像素）来平滑边缘。</li>
      <li>通过分别控制RGB子像素的亮度，可以达到比灰度抗锯齿更高的水平。</li>
      <li>常见的技术有ClearType（微软）和FreeType（开源）。</li>
    </ul>
  </li>
  <li><strong>LCD渲染（LCD Rendering）</strong>：
    <ul>
      <li>是次像素抗锯齿的一种实现方式，特别针对LCD显示器。</li>
      <li>通过利用LCD显示器的物理特性（RGB子像素排列），提高文字的清晰度和对比度。</li>
    </ul>
  </li>
  <li><strong>向量绘图（Vector Drawing）</strong>：
    <ul>
      <li>采用矢量图形渲染文字，使得文字在任意放大或缩小时都保持平滑。</li>
      <li>这种方法依赖于计算机的高计算能力，对于复杂的字体和大文本量可能会影响性能。</li>
    </ul>
  </li>
  <li><strong>混合抗锯齿（Hybrid Anti-Aliasing）</strong>：
    <ul>
      <li>结合灰度抗锯齿和次像素抗锯齿，取两者优点来实现更平滑的效果。</li>
      <li>这种方法需要较高的计算资源，但可以得到最佳的抗锯齿效果。</li>
    </ul>
  </li>
</ol>

<p>每种抗锯齿技术都有其优缺点，具体选择需要根据显示设备、字体大小、渲染性能要求等因素来决定。</p>

<h1 id="图像处理">图像处理</h1>

<h2 id="对比度调节">对比度调节</h2>

<p><strong>对比度调整的影响</strong></p>

<ul>
  <li><strong>增加对比度</strong>：高亮部分变得更亮，暗部变得更暗，图像更具视觉冲击力。</li>
  <li><strong>减少对比度</strong>：图像更平坦，亮部和暗部的差异减少。</li>
</ul>

<p><span style="color:#FF00FF">通过把颜色调整到[-0.5,0.5]之间，然后乘以一个系数，再调回(0, 1.0)来实现对比度的调节</span></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">blit_frag_src</span> <span class="o">=</span><span class="s">""</span>    
    <span class="s">"varying highp  vec2  varTexCoord;                       </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"uniform sampler2D    dfbSampler;                        </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"void main (void)                                        </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"{                                                       </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"    highp vec4 color = texture2D(dfbSampler, varTexCoord); </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"    color.rgb = (color.rgb-0.5)*1.5 + 0.5;             </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"    gl_FragColor = color;  </span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"}                                                       </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>    
</code></pre></div></div>

<p><strong>详解</strong></p>

<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">color.rgb - 0.5</code></strong>
    <ul>
      <li>将颜色值从原始范围 [0, 1] 转换到范围 [-0.5, 0.5]。</li>
      <li>这样做的目的是为了将颜色值居中，以便更容易进行对比度调整。</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">(color.rgb - 0.5) * contrast</code></strong>
    <ul>
      <li>将转换后的颜色值乘以对比度因子 <code class="language-plaintext highlighter-rouge">contrast</code>。</li>
      <li>增大 <code class="language-plaintext highlighter-rouge">contrast</code> 会增加图像的对比度，使亮的部分更亮，暗的部分更暗。</li>
      <li>减小 <code class="language-plaintext highlighter-rouge">contrast</code> 会减少图像的对比度，使图像变得更平坦。</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">(color.rgb - 0.5) * contrast + 0.5</code></strong>
    <ul>
      <li>将调整对比度后的颜色值从范围 [-0.5, 0.5] 再次转换回原始范围 [0, 1]。</li>
      <li>通过加回 0.5，确保颜色值回到 [0, 1] 范围，适合在标准的RGB颜色空间中表示。</li>
    </ul>
  </li>
</ol>

<h2 id="gamma校正">gamma校正</h2>

<p>Gamma校正是一种调整图像亮度的非线性操作，用于矫正显示设备的非线性响应，从而使图像显示更加自然。</p>

<p>Gamma校正<span style="color:#ff00ff">使用一个指数函数</span>来调整图像的亮度。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kd">const</span> <span class="nx">char</span><span class="o">*</span> <span class="nx">blit_frag_src</span> <span class="o">=</span><span class="dl">""</span>    
    <span class="dl">"</span><span class="s2">varying highp  vec2  varTexCoord;                       </span><span class="se">\n</span><span class="dl">"</span>
    <span class="dl">"</span><span class="s2">uniform sampler2D    dfbSampler;                        </span><span class="se">\n</span><span class="dl">"</span>
    <span class="dl">"</span><span class="s2">void main (void)                                        </span><span class="se">\n</span><span class="dl">"</span>
    <span class="dl">"</span><span class="s2">{                                                       </span><span class="se">\n</span><span class="dl">"</span>
    <span class="dl">"</span><span class="s2">    highp vec4 color = texture2D(dfbSampler, varTexCoord); </span><span class="se">\n</span><span class="dl">"</span>
    <span class="dl">"</span><span class="s2">    color.rgb = pow(color.rgb, vec3(1.0/2.2));           </span><span class="se">\n</span><span class="dl">"</span>
    <span class="dl">"</span><span class="s2">    gl_FragColor = color;  </span><span class="se">\n</span><span class="dl">"</span>
    <span class="dl">"</span><span class="s2">}                                                       </span><span class="se">\n</span><span class="dl">"</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">color</span><span class="p">.</span><span class="nx">rgb</span> <span class="o">=</span> <span class="nf">pow</span><span class="p">(</span><span class="nx">color</span><span class="p">.</span><span class="nx">rgb</span><span class="p">,</span> <span class="nf">vec3</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="nx">gamma</span><span class="p">));</span>
</code></pre></div></div>

<p>这个公式的作用是对颜色值进行Gamma校正。vec3(1.0/gamma) 确保了每个颜色分量都被提升到1.0/gamma次方，以达到Gamma校正的效果。
通过调整gamma的值，你可以控制图像的亮度。通常情况下，gamma=2.2 被认为是标准的Gamma值。</p>

<h2 id="阈值分隔">阈值分隔</h2>

<p>阈值分割：就是根据像素值进行简单的二值化操作</p>

<p>这段片段着色器代码实现了一个简单的图像分割算法，即阈值分割。通过<span style="color:#ff00ff">比较每个像素的亮度值与给定的阈值</span>，可以将图像分割为前景（亮度大于阈值的部分）和背景（亮度小于或等于阈值的部分）。这在一些简单的图像处理任务中非常有用，例如二值化处理。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kd">const</span> <span class="nx">char</span><span class="o">*</span> <span class="nx">blit_frag_src</span> <span class="o">=</span><span class="dl">""</span>    
    <span class="dl">"</span><span class="s2">varying highp  vec2  varTexCoord;                                       </span><span class="dl">"</span>
    <span class="dl">"</span><span class="s2">uniform sampler2D    dfbSampler;                                        </span><span class="dl">"</span>
    <span class="dl">"</span><span class="s2">void main (void)                                                        </span><span class="dl">"</span>
    <span class="dl">"</span><span class="s2">{                                                                       </span><span class="dl">"</span>
    <span class="dl">"</span><span class="s2">    highp vec4 color = texture2D(dfbSampler, varTexCoord);              </span><span class="dl">"</span>
    <span class="dl">"</span><span class="s2">    highp float brightness = dot(color.rgb, vec3(0.299, 0.587, 0.114)); </span><span class="dl">"</span>
    <span class="dl">"</span><span class="s2">    if(brightness &gt; 0.5)                                                </span><span class="dl">"</span>
    <span class="dl">"</span><span class="s2">       gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);                         </span><span class="dl">"</span>
    <span class="dl">"</span><span class="s2">    else                                                                </span><span class="dl">"</span>
    <span class="dl">"</span><span class="s2">       gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);                         </span><span class="dl">"</span>
    <span class="dl">"</span><span class="s2">}                                                                       </span><span class="dl">"</span><span class="p">;</span>
</code></pre></div></div>

<p><span style="color:#ff00ff">颜色的亮度公式</span></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">highp</span> <span class="kt">float</span> <span class="n">brightness</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">color</span><span class="p">.</span><span class="n">rgb</span><span class="p">,</span> <span class="n">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">299</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">587</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">114</span><span class="p">));</span>
</code></pre></div></div>

<p>计算采样颜色的亮度。使用 dot 函数计算颜色的亮度值。亮度计算公式为 <code class="language-plaintext highlighter-rouge">brightness = 0.299 * R + 0.587 * G + 0.114 * B</code>。这是因为人眼对不同颜色的<span style="color:#ff00ff">敏感度</span>不同，所以使用这种<span style="color:#ff00ff">加权平均方法</span>来计算亮度更符合人眼感知.</p>

<h2 id="白平衡">白平衡</h2>

<p>白平衡是摄影和图像处理中的一个重要概念，用于调整图像的颜色，以便使图像中的白色和灰色区域看起来在不同光源下仍然是自然的白色。<span style="color:#ff00ff">不同光源会产生不同的色温，导致图像的颜色偏移</span>。通过白平衡调整，可以校正这些色偏，使得图像的颜色更加真实和自然。</p>

<p><strong>片段着色器</strong></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#version 330 core</span>
<span class="k">in </span>vec2 TexCoord<span class="p">;</span>
out vec4 color<span class="p">;</span>
uniform sampler2D texture1<span class="p">;</span>
uniform vec3 whiteBalanceGain<span class="p">;</span> // vec3<span class="o">(</span>r_gain, g_gain, b_gain<span class="o">)</span>
void main<span class="o">()</span> <span class="o">{</span>
    vec4 texColor <span class="o">=</span> texture<span class="o">(</span>texture1, TexCoord<span class="o">)</span><span class="p">;</span>
    texColor.r <span class="k">*</span><span class="o">=</span> whiteBalanceGain.r<span class="p">;</span>
    texColor.g <span class="k">*</span><span class="o">=</span> whiteBalanceGain.g<span class="p">;</span>
    texColor.b <span class="k">*</span><span class="o">=</span> whiteBalanceGain.b<span class="p">;</span>
    color <span class="o">=</span> texColor<span class="p">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>基于灰度世界假设,计算白平衡增益系数</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">calculateWhiteBalanceGains</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;&amp;</span> <span class="n">imageData</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">r_gain</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">g_gain</span><span class="p">,</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">b_gain</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">r_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">g_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">pixelCount</span> <span class="o">=</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span><span class="p">;</span>
    <span class="c1">// 计算图像中红、绿、蓝通道的平均值。</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pixelCount</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">r_sum</span> <span class="o">+=</span> <span class="n">imageData</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">g_sum</span> <span class="o">+=</span> <span class="n">imageData</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="n">b_sum</span> <span class="o">+=</span> <span class="n">imageData</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="kt">float</span> <span class="n">r_avg</span> <span class="o">=</span> <span class="n">r_sum</span> <span class="o">/</span> <span class="n">pixelCount</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">g_avg</span> <span class="o">=</span> <span class="n">g_sum</span> <span class="o">/</span> <span class="n">pixelCount</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">b_avg</span> <span class="o">=</span> <span class="n">b_sum</span> <span class="o">/</span> <span class="n">pixelCount</span><span class="p">;</span>
    <span class="c1">// 计算平均灰度值。</span>
    <span class="kt">float</span> <span class="n">avg</span> <span class="o">=</span> <span class="p">(</span><span class="n">r_avg</span> <span class="o">+</span> <span class="n">g_avg</span> <span class="o">+</span> <span class="n">b_avg</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
    <span class="c1">// 计算每个通道的增益系数，使其平均值接近于灰度值。</span>
    <span class="n">r_gain</span> <span class="o">=</span> <span class="n">avg</span> <span class="o">/</span> <span class="n">r_avg</span><span class="p">;</span>
    <span class="n">g_gain</span> <span class="o">=</span> <span class="n">avg</span> <span class="o">/</span> <span class="n">g_avg</span><span class="p">;</span>
    <span class="n">b_gain</span> <span class="o">=</span> <span class="n">avg</span> <span class="o">/</span> <span class="n">b_avg</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="降噪">降噪</h2>

<p><strong>均值滤波对图像进行降噪</strong></p>

<p>取坐标点周围9个点的颜色计算平均值</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#version 330 core</span>
<span class="k">in </span>vec2 TexCoord<span class="p">;</span>
out vec4 color<span class="p">;</span>
uniform sampler2D texture1<span class="p">;</span>
uniform vec2 texOffset[9]<span class="p">;</span>
void main<span class="o">()</span> <span class="o">{</span>
    vec3 result <span class="o">=</span> vec3<span class="o">(</span>0.0<span class="o">)</span><span class="p">;</span>
    <span class="k">for</span> <span class="o">(</span>int i <span class="o">=</span> 0<span class="p">;</span> i &lt; 9<span class="p">;</span> i++<span class="o">)</span> <span class="o">{</span>
        result +<span class="o">=</span> texture<span class="o">(</span>texture1, TexCoord + texOffset[i]<span class="o">)</span>.rgb<span class="p">;</span>
    <span class="o">}</span>
    result /<span class="o">=</span> 9.0<span class="p">;</span>
    color <span class="o">=</span> vec4<span class="o">(</span>result, 1.0<span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>纹理偏移量的计算</strong></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">float</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span> <span class="o">/</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
    <span class="n">GLfloat</span> <span class="n">texOffset</span> <span class="o">=</span> <span class="p">{</span>
        <span class="o">-</span><span class="n">offset</span><span class="p">,</span>  <span class="n">offset</span><span class="p">,</span>
         <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span>    <span class="n">offset</span><span class="p">,</span>
         <span class="n">offset</span><span class="p">,</span>  <span class="n">offset</span><span class="p">,</span>
        <span class="o">-</span><span class="n">offset</span><span class="p">,</span>  <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span>
         <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span>    <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span>
         <span class="n">offset</span><span class="p">,</span>  <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span>
        <span class="o">-</span><span class="n">offset</span><span class="p">,</span> <span class="o">-</span><span class="n">offset</span><span class="p">,</span>
         <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span>   <span class="o">-</span><span class="n">offset</span><span class="p">,</span>
         <span class="n">offset</span><span class="p">,</span> <span class="o">-</span><span class="n">offset</span>
    <span class="p">};</span>
</code></pre></div></div>
</section>
            </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div></div>
    </div>
</div>

<!-- introduce mathjax support -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ['$', '$'], ['\\(', '\\)'] ]
  },
  svg: {
    fontCache: 'global'
  }
};
</script>
<script
  type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>


<!-- introduce per-page mermaid support -->

    <script>
    function render_mermaid() {
        mermaid.initialize({
            startOnLoad: false,
            theme: "default",
        });
        window.mermaid.init(undefined, document.querySelectorAll('.language-mermaid'));
    }

    function initialize_mermaid() {
        if (document.readyState === "loading") {
            // Loading hasn't finished yet
            document.addEventListener("DOMContentLoaded", render_mermaid);
        } else {
            // `DOMContentLoaded` has already fired
            render_mermaid();
        }
    }

    if (window.mermaid_script && window.mermaid) {
        initialize_mermaid();
    } else {
        window.mermaid_script = document.createElement("script");
        mermaid_script.onload = initialize_mermaid;
        document.head.appendChild(mermaid_script);
        mermaid_script.defer = true;
        mermaid_script.id = 'mermaid-script';
        mermaid_script.src = '/blog/assets/gitbook/mermaid.min.js';
    }
</script>



<!-- introduce mathjax support -->
<script>
    function fixes_chrome_anchors() {
        let chrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
        if (window.location.hash && chrome) {
            setTimeout(function () {
                var hash = window.location.hash;
                window.location.hash = "";
                window.location.hash = hash;
            }, 300);
        }
    }

    if (document.readyState === "loading") {
        // Loading hasn't finished yet
        document.addEventListener("DOMContentLoaded", fixes_chrome_anchors);
    } else {
        // `DOMContentLoaded` has already fired
        fixes_chrome_anchors();
    }
</script>


                        <a href="/blog/jekyll/2002-08-10-Wayland-Misc.html" class="navigation navigation-prev navigation-unique" aria-label="Previous page: Wayland Misc">
                            <i class="fa fa-angle-left"></i>
                        </a>
                    

                    
                        <a href="/blog/jekyll/2013-03-02-cobalt.html" class="navigation navigation-next navigation-unique" aria-label="Next page: Cobalt">
                            <i class="fa fa-angle-right"></i>
                        </a>
                    
                </div>
            </div>

            <script>
            var gitbook = gitbook || [];
            gitbook.push(function() {
                gitbook.page.hasChanged({
    "page": {
        "title": "Introduction",
        "level": "1.1",
        "depth": 1,
        
        "next": {
            "title": "Cobalt",
            "level": "1.2",
            "depth": 1,
            "path": "_posts/2013-03-2-cobalt.md",
            "ref": "_posts/2013-03-2-cobalt.md",
            "articles": []
        },
        
        "dir": "ltr"
    },    "config": {
        "plugins": ["fontsettings", "highlight", "livereload", "lunr", "search", "sharing", "theme-default", "livereload"],
        "styles": {
            "ebook": "styles/ebook.css",
            "epub": "styles/epub.css",
            "mobi": "styles/mobi.css",
            "pdf": "styles/pdf.css",
            "print": "styles/print.css",
            "website": "styles/website.css"
        },
        "pluginsConfig": {
            "expandable-chapter-small2": {
                "articlesExpand": true,
            },
            "fontsettings": {
                "family": "sans",
                "size": 2,
                "theme": "white"
            },
            "highlight": {},
            "livereload": {},
            "lunr": {
                "ignoreSpecialCharacters": false,
                "maxIndexSize": 1000000
            },
            "search": {},            "sharing": {
                "facebook": false,

                "google": false,

                "github": false,
              
                "github_link": "https://github.com",
              

                "telegram": false,
                "telegram_link": "https://t.me",

                "instapaper": false,

                "twitter": false,
              

                "vk": false,

                "weibo": false,

                "all": ["facebook", "google", "twitter", "weibo", "instapaper", "github", "telegram"]
            },
"theme-default": {
                "showLevel": false,
                "styles": {
                    "ebook": "styles/ebook.css",
                    "epub": "styles/epub.css",
                    "mobi": "styles/mobi.css",
                    "pdf": "styles/pdf.css",
                    "print": "styles/print.css",
                    "website": "styles/website.css"
                }
            },
        },
        "theme": "default",
        "author": "Tao He",
        "pdf": {
            "pageNumbers": true,
            "fontSize": 12,
            "fontFamily": "Arial",
            "paperSize": "a4",
            "chapterMark": "pagebreak",
            "pageBreaksBefore": "/",
            "margin": {
                "right": 62,
                "left": 62,
                "top": 56,
                "bottom": 56
            }
        },
        "structure": {
            "langs": "LANGS.md",
            "readme": "README.md",
        },
        "variables": {},
        "title": "学习笔记",
        "language": "en",
        "gitbook": "*"
    },
    "file": {
        "path": "_posts/2020-08-20-OpenGL_misc.md",
        "mtime": "2003-08-20 00:00:00 +0800",
        "type": "markdown"
    },
    "gitbook": {
        "version": "3.2.3"
    },
    "basePath": "/blog",
    "book": {
        "language": ""
    }
});
            });
            </script>
        </div><script src="/blog/assets/gitbook/gitbook.js"></script>
<script src="/blog/assets/gitbook/theme.js"></script>

<script src="/blog/assets/gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
<script src="/blog/assets/gitbook/gitbook-plugin-copy-code-button/toggle.js"></script>
<script src="/blog/assets/gitbook/gitbook-plugin-expandable-chapters-small2/expandable-chapters-small.js"></script>
<script src="/blog/assets/gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
<script src="/blog/assets/gitbook/gitbook-plugin-search-pro/jquery.mark.min.js"></script>
<script src="/blog/assets/gitbook/gitbook-plugin-search-pro/search.js"></script>
<!-- <script src="/blog/assets/gitbook/gitbook-plugin-sharing/buttons.js"></script> -->
<script src="/blog/assets/gitbook/gitbook-plugin-splitter/splitter.js"></script>

<!--
<script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
<script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
<script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
<script src="../gitbook/gitbook-plugin-search/search.js"></script>
-->

</body>
</html>